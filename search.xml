<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CI/CD 说明</title>
    <url>/2021/04/29/CI-CD-%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>CI&#x2F;CD 包括<code>持续集成（CI）</code>, <code>持续部署（CD）</code>两个内容。</p>
<ul>
<li><code>持续集成</code>的工作原理是将小的代码块推送到 Git 存储库中，并在每次推送时运行脚本管道来构建，测试和验证代码更改，然后再将其合并到主分支中。</li>
<li><code>持续部署</code>可在每次推送到存储库指定分支时将应用程序部署到不同的生产环境。</li>
</ul>
<p>CI&#x2F;CD 具有<code>细粒度</code>，<code>流程化</code>，<code>自动化</code>的特点。</p>
<p>因此使用 CI&#x2F;CD 可以在开发周期内进行代码<code>检查与测试</code>，从而更有效的发现 BUG 和问题，确保生产环境下的运行稳定性；另一方面，CI&#x2F;CD 能够<code>自动</code>完成产品的构建与发布，简化部署流程，提升开发与测试效率。</p>
<span id="more"></span>

<h2 id="CI-x2F-CD-的使用方法"><a href="#CI-x2F-CD-的使用方法" class="headerlink" title="CI&#x2F;CD 的使用方法"></a>CI&#x2F;CD 的使用方法</h2><h3 id="前置基础知识"><a href="#前置基础知识" class="headerlink" title="前置基础知识"></a>前置基础知识</h3><ol>
<li><a href="/2021/04/29/Git-%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/" title="Git 使用规范">Git</a>

<p>CI&#x2F;CD 工具都是通过 Git 代码仓库的提交，合并等事件触发。</p>
</li>
<li><a href="/2019/07/25/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="Linux 常用命令">命令行与脚本</a>

<p>CI&#x2F;CD 所有步骤均通过编写 shell 脚本来指定，完成从代码下载到产品发布的整个流程。</p>
</li>
<li><p><a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">docker</a><br>CI&#x2F;CD 服务通常运行在指定的 docker 镜像中，减少对环境的依赖。</p>
</li>
</ol>
<h3 id="常用的-CI-服务"><a href="#常用的-CI-服务" class="headerlink" title="常用的 CI 服务"></a>常用的 CI 服务</h3><ul>
<li>GitHub Actions</li>
<li>Jenkins</li>
<li>GitLab CI&#x2F;CD</li>
<li>CircleCI</li>
<li>Travis CI</li>
<li>Drone CI</li>
</ul>
<h3 id="CI-x2F-CD-配置文件"><a href="#CI-x2F-CD-配置文件" class="headerlink" title="CI&#x2F;CD 配置文件"></a>CI&#x2F;CD 配置文件</h3><p>几乎所有的 CI 服务都是通过 <code>yaml</code> 类型的配置文件完成对整个产品的测试，构建，部署流程。通常包含以下主要组成部分</p>
<h4 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h4><p>声明当前任务的运行环境，如前端应用的<code>node</code>环境，Spring 应用的<code>maven</code>环境，安卓应用的<code>gradle+androidSdk</code> 环境，以及上传 docker 镜像需要的<code>docker</code>环境。</p>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>环境变量会储存一些需要隐藏显示的账号，密码，token 等字符串，然后通过声明导入当前任务中。</p>
<h4 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h4><p>CI&#x2F;CD 服务均通过编写的脚本逐行执行，自动地完成设计好的流程。</p>
<h2 id="CI-x2F-CD-的工作流程"><a href="#CI-x2F-CD-的工作流程" class="headerlink" title="CI&#x2F;CD 的工作流程"></a>CI&#x2F;CD 的工作流程</h2><p><img src="/2021/04/29/CI-CD-%E8%AF%B4%E6%98%8E/gitlab_workflow_example_11_9.png" alt="CI/CD"></p>
<p><img src="/2021/04/29/CI-CD-%E8%AF%B4%E6%98%8E/gitlab_workflow_example_extended_v12_3.png" alt="DevOps"></p>
<ol>
<li><p>验证</p>
<ul>
<li>通过持续集成自动构建和测试应用程序。</li>
<li>使用代码质量分析源代码质量。</li>
<li>使用浏览器性能测试评估代码更改对浏览器性能的影响。</li>
</ul>
</li>
<li><p>包管理</p>
<ul>
<li>存储并发布 Docker 镜像。</li>
<li>使用 NPM Registry 存储并发布 NPM 包。</li>
</ul>
</li>
<li><p>发布</p>
<ul>
<li>持续部署，自动将应用程序部署到生产环境。</li>
<li>完成安卓 apk 的自动构建与发布。</li>
<li>部署前端产品。</li>
<li>部署静态页面。</li>
<li>将功能一部分进行更新，并让一定比例的用户群访问临时部署的功能。</li>
<li>添加发行说明。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>CI/CD</category>
      </categories>
      <tags>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>GeoJSON格式说明</title>
    <url>/2021/04/08/GeoJSON%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>GeoJSON 是一种对各种地理数据结构进行编码的格式。GeoJSON 对象可以表示几何、特征或者特征集合。GeoJSON 支持下面几何类型：点、线、面、多点、多线、多面和几何集合。GeoJSON 里的特征包含一个几何对象和其他属性，特征集合表示一系列特征。</p>
<span id="more"></span>

<p>一个完整的 GeoJSON 数据结构总是一个（JSON 术语里的）对象。在 GeoJSON 里，对象由名&#x2F;值对–也称作成员的集合组成。对每个成员来说，名字总是字符串。成员的值要么是字符串、数字、对象、数组，要么是下面文本常量中的一个：”true”,”false”和”null”。数组是由值是上面所说的元素组成。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>GeoJSON 特征集合：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FeatureCollection&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;features&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Point&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">102.0</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">]</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;prop0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value0&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LineString&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">[</span><span class="number">102.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">[</span><span class="number">103.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">[</span><span class="number">104.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">[</span><span class="number">105.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prop0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;prop1&quot;</span><span class="punctuation">:</span> <span class="number">0.0</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Polygon&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">[</span><span class="number">101.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">[</span><span class="number">101.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prop0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;prop1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;this&quot;</span><span class="punctuation">:</span> <span class="string">&quot;that&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>JavaScript 对象表示和术语对象、名字、值、数组和数字在 IETF RFC 4627 即<a href="http://www.ietf.org/rfc/rfc4627.txt%E9%87%8C%E5%AE%9A%E4%B9%89%E3%80%82">http://www.ietf.org/rfc/rfc4627.txt里定义。</a></p>
</li>
<li><p>这篇文档里的关键字“必须“，”不允许“，”需要“，”应当“，”应当不“，”应该“，”不应该“，”推荐的“，”也许“和”可选的“在 IETF RFC 2119， 即<a href="http://www.ietf.org/rfc/rfc2119.txt%E9%87%8C%E8%A7%A3%E9%87%8A%E3%80%82">http://www.ietf.org/rfc/rfc2119.txt里解释。</a></p>
</li>
</ul>
<h2 id="GeoJSON-对象"><a href="#GeoJSON-对象" class="headerlink" title="GeoJSON 对象"></a>GeoJSON 对象</h2><p>GeoJSON 总是由一个单独的对象组成。这个对象（指的是下面的 GeoJSON 对象）表示几何、特征或者特征集合。</p>
<ul>
<li>GeoJSON 对象可能有任何数目成员（名&#x2F;值对）。</li>
<li>GeoJSON 对象必须由一个名字为”type”的成员。这个成员的值是由 GeoJSON 对象的类型所确定的字符串。</li>
<li>type 成员的值必须是下面之一：”Point”, “MultiPoint”, “LineString”, “MultiLineString”, “Polygon”,    “MultiPolygon”,   “GeometryCollection”, “Feature”, 或者 “FeatureCollection”。这儿 type 成员值必须如这儿所示。</li>
<li>GeoJSON 对象可能有一个可选的”crs”成员，它的值必须是一个坐标参考系统的对象（见 3.坐标参考系统对象）。</li>
<li>GeoJSON 对象可能有一个”bbox”成员，它的值必须是边界框数组（见 4.边界框）。</li>
</ul>
<h3 id="几何对象"><a href="#几何对象" class="headerlink" title="几何对象"></a>几何对象</h3><p>几何是一种 GeoJSON 对象，这时 type 成员的值是下面字符串之一：”Point”, “MultiPoint”, “LineString”, “MultiLineString”,  “Polygon”, “MultiPolygon”, 或者”GeometryCollection”。</p>
<p>除了“GeometryCollection”外的其他任何类型的 GeoJSON 几何对象必须由一个名字为”coordinates”的成员。coordinates 成员的值总是数组。这个数组里的元素的结构由几何类型来确定。</p>
<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>位置是基本的几何结构。几何对象的”coordinates”成员由一个位置（这儿是几何点）、位置数组（线或者几何多点），位置数组的数组（面、多线）或者位置的多维数组（多面）组成。</p>
<p>位置由数字数组表示。必须至少两个元素，可以有更多元素。元素的顺序必须遵从 x,y,z 顺序（投影坐标参考系统中坐标的东向、北向、高度或者地理坐标参考系统中的坐标长度、纬度、高度）。任何数目的其他元素是允许的—其他元素的说明和意义超出了这篇规格说明的范围。</p>
<p>位置和几何的例子在附录 A.几何例子里呈现。</p>
<h4 id="点"><a href="#点" class="headerlink" title="点"></a>点</h4><p>对类型”Point”来说，“coordinates”成员必须是一个单独的位置。</p>
<h4 id="多点"><a href="#多点" class="headerlink" title="多点"></a>多点</h4><p>对类型”MultiPoint”来说，”coordinates”成员必须是位置数组。</p>
<h4 id="线"><a href="#线" class="headerlink" title="线"></a>线</h4><p>对类型”LineString”来说，“coordinates”成员必须是两个或者多个位置的数组。</p>
<p>线性环市具有 4 个或者更多位置的封闭的线。第一个和最后一个位置是相等的（它们表示相同的的点）。虽然线性环没有鲜明地作为 GeoJSON 几何类型，不过在面几何类型定义里有提到它。</p>
<h4 id="多线"><a href="#多线" class="headerlink" title="多线"></a>多线</h4><p>对类型“MultiLineString”来说，”coordinates”成员必须是一个线坐标数组的数组。</p>
<h4 id="面"><a href="#面" class="headerlink" title="面"></a>面</h4><p>对类型”Polygon”来说，”coordinates”成员必须是一个线性环坐标数组的数组。对拥有多个环的的面来说，第一个环必须是外部环，其他的必须是内部环或者孔。</p>
<h4 id="多面"><a href="#多面" class="headerlink" title="多面"></a>多面</h4><p>对类型”MultiPolygon”来说，”coordinates”成员必须是面坐标数组的数组。</p>
<h4 id="几何集合"><a href="#几何集合" class="headerlink" title="几何集合"></a>几何集合</h4><p>类型为”GeometryCollection”的 GeoJSON 对象是一个集合对象，它表示几何对象的集合。</p>
<p>几何集合必须有一个名字为”geometries”的成员。与”geometries”相对应的值是一个数组。这个数组中的每个元素都是一个 GeoJSON 几何对象。</p>
<h3 id="特征对象"><a href="#特征对象" class="headerlink" title="特征对象"></a>特征对象</h3><p>类型为”Feature”的 GeoJSON 对象是特征对象。</p>
<ul>
<li><p>特征对象必须由一个名字为”geometry”的成员，这个几何成员的值是上面定义的几何对象或者 JSON 的 null 值。</p>
</li>
<li><p>特征对戏那个必须有一个名字为“properties”的成员，这个属性成员的值是一个对象（任何 JSON 对象或者 JSON 的 null 值）。</p>
</li>
<li><p>如果特征是常用的标识符，那么这个标识符应当包含名字为“id”的特征对象成员。</p>
</li>
</ul>
<h4 id="特征集合对象"><a href="#特征集合对象" class="headerlink" title="特征集合对象"></a>特征集合对象</h4><p>类型为”FeatureCollection”的 GeoJSON 对象是特征集合对象。</p>
<p>类型为”FeatureCollection”的对象必须由一个名字为”features”的成员。与“features”相对应的值是一个数组。这个数组中的每个元素都是上面定义的特征对象。</p>
<h2 id="坐标参考系统对象"><a href="#坐标参考系统对象" class="headerlink" title="坐标参考系统对象"></a>坐标参考系统对象</h2><p>GeoJSON 对象的坐标参考系统（CRS）是由它的”crs”成员（指的是下面的 CRS 对象）来确定的。如果对象没有 crs 成员，那么它的父对象或者祖父对象的 crs 成员可能被获取作为它的 crs。如果这样还没有获得 crs 成员，那么默认的 CRS 将应用到 GeoJSON 对象。</p>
<ul>
<li>默认的 CRS 是地理坐标参考系统，使用的是 WGS84 数据，长度和高度的单位是十进制标示。</li>
<li>名字为”crs”成员的值必须是 JSON 对象（指的是下面的 CRS 对象）或者 JSON 的 null。如果 CRS 的值为 null,那么就假设没有 CRS 了。</li>
<li>crs 成员应当位于（特征集合、特征、几何的顺序的）层级结构里 GeoJSON 对象的最顶级，而且在自对象或者孙子对象里不应该重复或者覆盖。</li>
<li>非空的 CRS 对象有两个强制拥有的对象:”type”和”properties”。</li>
<li>type 成员的值必须是字符串，这个字符串说明了 CRS 对象的类型。</li>
<li>属性成员的值必须是对象。</li>
<li>CRS 应不能更改坐标顺序。</li>
</ul>
<h3 id="名字-CRS"><a href="#名字-CRS" class="headerlink" title="名字 CRS"></a>名字 CRS</h3><p>CRS 对象可以通过名字来表明坐标参考系统。在这种情况下，它的”type”成员的值必须是字符串”name”。它的”properties”成员的值必须是包含”name”成员的对象。这个”name”成员的值必须是标识坐标参考系统的字符串。比如“urn:ogc:def:crs:OGC:1.3:CRS84”的 OGC CRS 的 URN 应当优先于旧的标识符如”EPSG:4326”得到选用：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;crs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;urn:ogc:def:crs:OGC:1.3:CRS84&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="连接-CRS"><a href="#连接-CRS" class="headerlink" title="连接 CRS"></a>连接 CRS</h3><p>CRS 对象也可以连接到互联网上的 CRS 参数。在这种情况下，它的”type”成员的值必须是字符串”link”,它的”properties”成员的值必须是一个连接对象（见 3.2.1.连接对象） 。</p>
<h4 id="连接对象"><a href="#连接对象" class="headerlink" title="连接对象"></a>连接对象</h4><p>连接对象由一个必需的成员：”href”，和一个可选的成员:”type”。</p>
<p>必需的”href”成员的值必须是解引用的 URI（统一资源标识）。</p>
<p>可选的”type”成员的值必须是字符串，而且这个字符串暗示了所提供的 URI 里用来表示 CRS 参数的格式。建议值是:”proj4”,”ogcwkt”,esriwkt”,不过可以使用其他值：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;crs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;link&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://example.com/crs/42&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;proj4&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>相对连接常常可以作为辅助文件里的 CRS 的直接处理器：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;crs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;link&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;data.crs&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ogcwkt&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="边界框"><a href="#边界框" class="headerlink" title="边界框"></a>边界框</h2><p>为了包含几何、特征或者特征集合的坐标范围信息，GeoJSON 对象可能有一个名字为”bbox 的成员。bbox 成员的值必须是 2*n 数组，这儿 n 是所包含几何对象的维数，并且所有坐标轴的最低值后面跟着最高者值。bbox 的坐标轴的顺序遵循几何坐标轴的顺序。除此之外，bbox 的坐标参考系统假设匹配它所在 GeoJSON 对象的坐标参考系统。</p>
<p>特征对象上的 bbox 成员的例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bbox&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">-180.0</span><span class="punctuation">,</span> <span class="number">-90.0</span><span class="punctuation">,</span> <span class="number">180.0</span><span class="punctuation">,</span> <span class="number">90.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Polygon&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">-180.0</span><span class="punctuation">,</span> <span class="number">10.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">20.0</span><span class="punctuation">,</span> <span class="number">90.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">180.0</span><span class="punctuation">,</span> <span class="number">-5.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">-30.0</span><span class="punctuation">,</span> <span class="number">-90.0</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>特征集合对象 bbox 成员的例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FeatureCollection&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bbox&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">,</span> <span class="number">105.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;features&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="附录-A-集合例子"><a href="#附录-A-集合例子" class="headerlink" title="附录 A.集合例子"></a>附录 A.集合例子</h2><p>下面例子中的每一个都表示一个完整的 GeoJSON 对象。注意 JSON 对象里的结尾的空白字符没有意义。例子里所用的空白符有助于说明这个数据结构，不过不是必需的。</p>
<h3 id="点-1"><a href="#点-1" class="headerlink" title="点"></a>点</h3><p>点坐标是按照 x,y 顺序的(投影坐标的东向、北向，地理坐标的长度、高度）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Point&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="线-1"><a href="#线-1" class="headerlink" title="线"></a>线</h3><p>线的坐标是位置数组（见 2.1.1.位置）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LineString&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span><span class="number">101.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="面-1"><a href="#面-1" class="headerlink" title="面"></a>面</h3><p>面的坐标是线性环坐标数组的数组。这个数组的第一个元素表示的是外部环。其他后续的元素表示的内部环（或者孔）。</p>
<p>没有孔的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Polygon&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">101.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">101.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>有孔的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Polygon&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">101.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">101.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">100.2</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">100.8</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">100.8</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">100.2</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">100.2</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="多点-1"><a href="#多点-1" class="headerlink" title="多点"></a>多点</h3><p>多点的坐标是位置数组：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MultiPoint&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span><span class="number">101.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="多线-1"><a href="#多线-1" class="headerlink" title="多线"></a>多线</h3><p>多线的坐标是线坐标数组的数组:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MultiLineString&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">101.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">102.0</span><span class="punctuation">,</span> <span class="number">2.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span><span class="number">103.0</span><span class="punctuation">,</span> <span class="number">3.0</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="多面-1"><a href="#多面-1" class="headerlink" title="多面"></a>多面</h3><p>多面的坐标是面坐标数组的数组:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MultiPolygon&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">102.0</span><span class="punctuation">,</span> <span class="number">2.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">103.0</span><span class="punctuation">,</span> <span class="number">2.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">103.0</span><span class="punctuation">,</span> <span class="number">3.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">102.0</span><span class="punctuation">,</span> <span class="number">3.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">102.0</span><span class="punctuation">,</span> <span class="number">2.0</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">101.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">101.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">100.2</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">100.8</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">100.8</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">100.2</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">100.2</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="几何集合-1"><a href="#几何集合-1" class="headerlink" title="几何集合"></a>几何集合</h3><p>几何集合的几何数组里的每个元素都是上面所描述的几何对象之一:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GeometryCollection&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;geometries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Point&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">100.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LineString&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">101.0</span><span class="punctuation">,</span> <span class="number">0.0</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="number">102.0</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 使用规范</title>
    <url>/2021/04/29/Git-%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>Gitea 是一个开源的代码托管平台, 具有占用内存小, 运行速度快等优点, 通常用于代码版本管理以及问题反馈, 个人版本通常使用 Gitea 用作代码仓库.</p>
<span id="more"></span>

<h2 id="账户管理"><a href="#账户管理" class="headerlink" title="账户管理"></a>账户管理</h2><h3 id="新建账户"><a href="#新建账户" class="headerlink" title="新建账户"></a>新建账户</h3><ul>
<li>Gitea 账号需要管理员在<code>管理后台</code>新建, 暂不提供注册功能</li>
<li>新增的 Gitea 账号需要管理员拉入团队中</li>
</ul>
<h3 id="账户配置"><a href="#账户配置" class="headerlink" title="账户配置"></a>账户配置</h3><ol>
<li>个人用户登录 Gitea 账号后, 在用户设置中修改个人头像, 以便于项目组成员区分. 账号使用<code>名字拼音</code></li>
<li>生成 ssh <a href="/2019/06/11/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE%E8%A7%84%E8%8C%83/" title="前端开发配置规范">前端开发配置规范</a></li>
</ol>
<h2 id="新建代码仓库"><a href="#新建代码仓库" class="headerlink" title="新建代码仓库"></a>新建代码仓库</h2><ol>
<li>非管理员无法在项目组中新建项目, 代码仓库的新建<strong>需要</strong>通过管理员完成</li>
<li>仓库目录<strong>必须</strong>包括 <code>.gitignore</code> 文件对代码提交与否进行管理, <strong>严禁</strong>提交如 <code>target/</code>, <code>dist/</code> 等输出目录与 <code>node_modules/</code> 等资源目录, 静态资源目录不做限制</li>
<li>项目<strong>必须</strong>包括 <code>README.md</code> 文件对当前项目进行说明, 包括<ul>
<li>项目的简介</li>
<li>项目的安装与使用方法</li>
<li>项目特殊问题的处理与解决方案</li>
<li>文件夹目录结构</li>
<li>使用的接口列表</li>
</ul>
</li>
<li>分支初始化后<strong>需要</strong>完成一次初始化提交以保证代码历史记录的显示</li>
</ol>
<h2 id="本地代码仓库下载"><a href="#本地代码仓库下载" class="headerlink" title="本地代码仓库下载"></a>本地代码仓库下载</h2><ol>
<li><strong>推荐</strong>通过 <code>git clone</code> 新建本地代码目录</li>
<li><strong>可以</strong>通过本地创建目录后使用 <code>git pull --allow-unrelated-histories</code> 拉取线上仓库并处理冲突后提交, <strong>严禁</strong>提交无历史记录追溯的代码</li>
</ol>
<h2 id="代码分支提交-x2F-合并"><a href="#代码分支提交-x2F-合并" class="headerlink" title="代码分支提交&#x2F;合并"></a>代码分支提交&#x2F;合并</h2><ol>
<li><strong>严禁</strong>使用 <code>git push -f</code> 强制提交代码</li>
<li>项目无法直接提交到 <code>master</code> 分支, 需通过新建分支, 提交 <code>merge/pull request</code> 完成代码合并</li>
<li>代码合并上游分支(如 develop 等基础开发分支)时<strong>推荐</strong>使用 <code>merge[拉取]</code> 方法, 在不熟悉的情况下<strong>严禁</strong> <code>rebase[拉取(变基)]</code> 上游分支</li>
<li>git 提交时<strong>需要</strong>包含每次修改的具体内容, 遵守适量多次的原则, <strong>严禁</strong>一次提交大量更新, 通常单次提交的修改内容不超过 100 行</li>
<li>git 日志提交参考<a href="https://gist.githubusercontent.com/jmaxhu/8e7fb69a7dcec1b9b953/raw/ce7dd000639c2483d88def71bc47661fb36a7d4d/.git-commit-template.txt">日志提交模板</a>, 最基础的格式为 <code>&#123;版本号&#125;, &#123;类型&#125;:&#123;主题&#125;</code></li>
</ol>
<p>长的开发分支<strong>严禁</strong> <code>rebase[拉取(变基)]</code> 上游分支, 这个会带来大量冲突.</p>
<p><strong>推荐</strong>每次开发一个功能时新建一个分支, 命名形如<code>feat-&#123;功能点&#125;</code>, 使用 <code>rebase[拉取(变基)]</code> 完成上游分支的本地合并, 完成功能开发后<strong>必须</strong>删除当前开发分支</p>
<h2 id="代码合并"><a href="#代码合并" class="headerlink" title="代码合并"></a>代码合并</h2><ol>
<li>发起 <code>merge/pull request</code> 时确认人选择为管理员, 审核人设置为其他开发者与测试</li>
<li>代码合并的评审需要审核人确保代码库的<code>整体质量的提升为基础原则</code></li>
<li>代码合并请求会自动向钉钉群组推送通知, 请注意查收并及时处理.</li>
</ol>
]]></content>
      <categories>
        <category>基础开发</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>基础开发</tag>
      </tags>
  </entry>
  <entry>
    <title>H5性能优化方案</title>
    <url>/2019/07/25/H5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="H5-性能优化意义"><a href="#H5-性能优化意义" class="headerlink" title="H5 性能优化意义"></a>H5 性能优化意义</h1><p>对于一个 H5 的产品，功能无疑很重要，但是性能同样是用户体验中不可或缺的一环。原本 H5 的渲染性能就不及 native 的 app，如果不把性能优化做起来，将极大地影响用户使用产品的积极性。</p>
<h2 id="用户感受"><a href="#用户感受" class="headerlink" title="用户感受"></a>用户感受</h2><p>当用户能够在 1-2 秒内打开 H5 页面，看到信息的展示，或者能够开始进行下一步的操作，用户会感觉速度还好，可以接受；而页面如果在 2-5 秒后才进入可用的状态，用户的耐心会逐渐丧失；而如果一个界面超过 5 秒甚至更久才能显示出来，这对用户来说基本是无法忍受的，也许有一部分用户会退出重新进入，但更多的用户会直接放弃使用。</p>
<span id="more"></span>

<h2 id="一秒钟法则"><a href="#一秒钟法则" class="headerlink" title="一秒钟法则"></a>一秒钟法则</h2><p>移动互联网的架构、通讯机制，与有线网络有着巨大的差异，这也给 H5 的开发带来了很大的挑战。</p>
<p><img src="/2019/07/25/H5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/97990a05-a1df-4079-8fa4-d40bec15769b.jpg"></p>
<p>这是一张手机端接入服务器的流程。</p>
<p>首先，手机要通过无线网络协议，从基站获得无线链路分配，才能跟网络进行通讯。无线网络基站、基站控制器这方面，会给手机进行信号的分配，已完成手机连接和交互。获得无线链路后，会进行网络附着、加密、鉴权，核心网络会检查你是不是可以连接在这个网络上，是否开通套餐，是不是漫游等。核心网络有 SGSN 和 GGSN，在这一步完成无线网络协议和有线以太网的协议转换。再下一步，核心网络会给你进行 APN 选择、IP 分配、启动计费。再往下面，才是传统网络的步骤：DNS 查询、响应，建立 TCP 链接，HTTP GET，RTTP RESPONSE 200 OK，HTTP RESPONSE DATA，LAST HTTP RESPONSE DATA，开始 UI 展现。</p>
<p>可见，通过运营商的网络上网，情况比较复杂，经过的节点太多；运营商的网络信号强度变化频繁，连接状态切换快；网络延迟高、丢包率高；网络建立连接的代价高，传输速度快慢不等（从 2G 到 4G，相差很大）。</p>
<p>而我们优化的目标，就是所谓的一秒钟法则，即达成以下的标准：</p>
<ul>
<li>2g 网络：1 秒内完成 dns 查询、和后台服务器建立连接</li>
<li>3g 网络：1 秒内完成首字显示（首字时间）</li>
<li>wifi 网络：1 秒内完成首屏显示（首屏时间）</li>
</ul>
<h1 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h1><h2 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h2><h3 id="首屏加载"><a href="#首屏加载" class="headerlink" title="首屏加载"></a>首屏加载</h3><p>用户从点击按钮开始载入网页，在他的感知中，什么时候是“加载完成”？是首屏加载，即在可见的屏幕范围内，内容展现完全，loading 进度条消失。因此在 H5 性能优化中，一个很重要的目的就是尽可能提升这个“首屏加载”的时间，让它满足“一秒钟法则”。</p>
<h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><p>首先要明确，按需加载虽然能提升首屏加载的速度，但是可能带来更多的界面重绘，影响渲染性能，因此要评估具体的业务场景再做决定。</p>
<h3 id="Lazyload"><a href="#Lazyload" class="headerlink" title="Lazyload"></a>Lazyload</h3><p>Lazyload，即延迟加载，这并不是一个新的技术，在 PC 时代也是非常常用的一种性能优化手段。这个方案的原则是让屏幕外，或者不影响整体效果显示的图片、背景等资源，在界面就绪之后再进行网络加载。</p>
<h3 id="滚屏加载"><a href="#滚屏加载" class="headerlink" title="滚屏加载"></a>滚屏加载</h3><p>滚屏加载是一种常见的无刷新动态加载数据的方案，通常用在列表形式数据展示中。一方面，数据不是通过翻页进行加载，这样就避免了再一次请求和渲染整个页面；另一方面，数据显示的数量是受限的，例如第一次只请求了 10 条数据，也就只需要渲染这 10 条数据，下拉滚屏的时候，再去获得下面 10 条数据。</p>
<h3 id="Media-Query（响应式加载）"><a href="#Media-Query（响应式加载）" class="headerlink" title="Media Query（响应式加载）"></a>Media Query（响应式加载）</h3><p>响应式设计是现在网站设计的一个流行趋势，随着移动互联网的发展，这项技术也越来越受到重视。通过这项技术，我们能够方便地控制资源的加载与显示，例如说在分辨率不同的手机上，分别使用不同的 css，加载不同大小的图片资源。方案参考：<a href="http://www.poluoluo.com/jzxy/201206/167034.html">http://www.poluoluo.com/jzxy/201206/167034.html</a></p>
<h3 id="第三方资源异步加载"><a href="#第三方资源异步加载" class="headerlink" title="第三方资源异步加载"></a>第三方资源异步加载</h3><p>第三方资源有的时候不可控，比如说页面统计、地图显示、分享组件等，这些第三方资源使用的时候要慎重选择，充分考察它们对于性能的影响，使用异步加载的方式进行，防止第三方资源的使用影响到页面本身的功能。</p>
<h3 id="Loading-进度条"><a href="#Loading-进度条" class="headerlink" title="Loading 进度条"></a>Loading 进度条</h3><p>在加载时间较长的时候，务必要让用户明确感知到加载完成的提示，通常是在加载过程中显示 Loading 的进度条，加载完成的时候隐藏它。从心理上，这会让用户有一种“期盼感”，而不至于太过枯燥。</p>
<p>对于一些重量级的 H5 应用，例如游戏，开始前需要加载很多资源才能让后面的游戏过程更为流畅，一个带百分比进度显示的进度条就更加重要。</p>
<h3 id="避免-30-x2F-40-x2F-50-的-http-status"><a href="#避免-30-x2F-40-x2F-50-的-http-status" class="headerlink" title="避免 30*&#x2F;40*&#x2F;50*的 http status"></a>避免 30*&#x2F;40*&#x2F;50*的 http status</h3><ul>
<li>200 是一个正常的 response，我们在浏览器中打开一个网页（后面会讲如何针对移动端进行调试），还会看到 304，即命中浏览器缓存。这两种状态是正常的 http status。</li>
<li>302、301 跳转是常见的跳转，尤其前一种，在我们进行鉴权的时候有时会用到，但这个做法要尽可能地优化，一个页面访问，最多只进行一次 302 跳转即可，切忌频繁地跳转。</li>
<li>404、500，我们对自己开发的代码比较注意，一般不会发生，但是有的时候，加载第三方库，尤其是第三方库中有自己 load 组件的操作，这时，404 和 500 错误可能会在你不知不觉的时候发生。例如钉钉的第三方微应用中，就遇到过 dojo 的组件加载问题，加载的一些子组件失败了，但是又没有影响页面显示，这就很容易被忽略。后面也会再讲，如何去测试和发现这样的隐患。</li>
</ul>
<h3 id="Favicon-ico"><a href="#Favicon-ico" class="headerlink" title="Favicon.ico"></a>Favicon.ico</h3><p>如果我们没有设置图标 ico，则会加载默认的图标：域名目录下的 favicon.ico。很多开发者没有注意到这一点，就会导致这个请求 404 或者 500。</p>
<p>通常，我们在应用内部打开网页，不会显示这个图标出来（除非放到浏览器中显示网页），我们需要保证这个图标存在，尽可能地小（一般 4KB 以下），并且设置一个较长的缓存过期时间。</p>
<h2 id="图片的使用"><a href="#图片的使用" class="headerlink" title="图片的使用"></a>图片的使用</h2><h3 id="格式选择"><a href="#格式选择" class="headerlink" title="格式选择"></a>格式选择</h3><p>显示效果较好的图片格式中，有 webp、jpg 和 png24&#x2F;32 这几种常见的图片格式。一般来说，webp 的图片最小，但在 iOS 或者 android4.0 以下的系统中可能会有兼容性问题需要解决。</p>
<ul>
<li>Jpg 是我们最常使用的方案，大小适中，解码速度快，兼容性问题也基本不存在，是我们在 H5 的应用中使用起来性价比最高的方案。</li>
<li>Png24 或 png32，一般来说，显示效果肯定会比 jpg 更好，但是实际上人眼很难感知出来，所以在 H5 应用中要避免这种格式的大图片。</li>
</ul>
<p><strong>对于少量的图片，推荐用智图或者 tinypng 等工具来帮助自己选择合适的大小、格式。</strong></p>
<h3 id="像素控制"><a href="#像素控制" class="headerlink" title="像素控制"></a>像素控制</h3><p>在 H5 应用中，图片的像素要严格控制，一般来说不建议宽度超过 640px。</p>
<h3 id="小图片合并"><a href="#小图片合并" class="headerlink" title="小图片合并"></a>小图片合并</h3><p>在 html 网页中，如果有多个小图片需要加载，不妨试试 CSS Sprites 方案，尤其是一些基本不变，大小差不多的操作类型图标。</p>
<h3 id="避免-html-代码中的大小重设"><a href="#避免-html-代码中的大小重设" class="headerlink" title="避免 html 代码中的大小重设"></a>避免 html 代码中的大小重设</h3><p>在 html 或者 css 中，如果有类似 width: **px 这样的代码，就要注意看一看了，如果说图片显示的效果是宽度 100px，而下载的图片却是 200px 宽度，那这大小基本上就是所需要的 4 倍面积了，所以在 H5 应用中，使用图片的一个原则就是需要显示成多大，就下载多大的资源。</p>
<h3 id="避免-DataURL"><a href="#避免-DataURL" class="headerlink" title="避免 DataURL"></a>避免 DataURL</h3><p>DataURL 是用 Base64 的方式，将图片变成一串文本编码放入代码的方式。这种方式有好处，因为它可以减少一次 http 交互的请求，对于一些体积特别小的图片，或者是动态生成的图片可以考虑使用。但在 H5 应用中，一般情况下，我们都是需要避免 DataURL 的，因为它的数据体积通常比二进制图片的格式大 1&#x2F;3，而且它不会被浏览器缓存，每次页面刷新都需要重新加载这部分数据。</p>
<h3 id="使用图片的替代-css3-svg-iconfont"><a href="#使用图片的替代-css3-svg-iconfont" class="headerlink" title="使用图片的替代(css3, svg, iconfont)"></a>使用图片的替代(css3, svg, iconfont)</h3><p>CSS3 和 svg 可以更好地使用 GPU 进行渲染加速，而且会避免增加图片资源导致的 http 请求增加。例如一些 div 的圆角效果，就完全可以用用 css 来实现。</p>
<p>Iconfont，可以认为是一种矢量类型的操作字体。如果页面中有较多的操作图标，可以考虑使用 iconfont 来替代图片资源。</p>
<h2 id="域名-x2F-服务端部署"><a href="#域名-x2F-服务端部署" class="headerlink" title="域名&#x2F;服务端部署"></a>域名&#x2F;服务端部署</h2><h3 id="Gzip"><a href="#Gzip" class="headerlink" title="Gzip"></a>Gzip</h3><p>服务端要开启 Gzip 压缩。</p>
<h3 id="资源缓存，长-cache"><a href="#资源缓存，长-cache" class="headerlink" title="资源缓存，长 cache"></a>资源缓存，长 cache</h3><p>合理设置资源的过期时间，尤其对一些静态的不需要改变的资源，将其缓存过期时间设置得长一些。</p>
<h3 id="分域名部署-静态资源域名"><a href="#分域名部署-静态资源域名" class="headerlink" title="分域名部署(静态资源域名)"></a>分域名部署(静态资源域名)</h3><p>将动态资源和静态资源放置在不同的域名下，例如图片，放在自己特定的域名下。这样的好处是，静态资源请求时，不会带上动态域名中所设置的 cookie 头信息，从而减少 http 请求的大小。</p>
<h3 id="减少-Cookie"><a href="#减少-Cookie" class="headerlink" title="减少 Cookie"></a>减少 Cookie</h3><p>尽量减少 Cookie 头信息的大小，因为这部分数据使用的是上行流量，上行带宽更小，所以传输速度更慢，因此要尽量精简其大小。</p>
<h3 id="CDN-加速"><a href="#CDN-加速" class="headerlink" title="CDN 加速"></a>CDN 加速</h3><p>部署 CDN 服务器，或者使用第三方的 CDN 加速服务，优化不同地域接入网站的带宽速度。</p>
<h2 id="代码资源"><a href="#代码资源" class="headerlink" title="代码资源"></a>代码资源</h2><h3 id="Javascript-CSS-合并"><a href="#Javascript-CSS-合并" class="headerlink" title="Javascript, CSS 合并"></a>Javascript, CSS 合并</h3><p>尽量将所有的 js 和 css 合并，减少资源请求的次数。</p>
<h3 id="外联使用-js-css"><a href="#外联使用-js-css" class="headerlink" title="外联使用 js, css"></a>外联使用 js, css</h3><p>外联使用 js 和 css，这样可以有效地利用缓存，避免 html 页面刷新后重新加载这部分代码。</p>
<h3 id="压缩-html-js-css"><a href="#压缩-html-js-css" class="headerlink" title="压缩 html, js, css"></a>压缩 html, js, css</h3><p>压缩代码，尤其是 js 和 css 资源，压缩后的大小可以降低至原来的 1&#x2F;3 以下，有效节约流量。</p>
<h3 id="资源的版本更新"><a href="#资源的版本更新" class="headerlink" title="资源的版本更新"></a>资源的版本更新</h3><p>库 js、css 通常不会更新，但是我们的业务 js 和 css 可能会有更新，如果命中浏览器缓存，可能会让一些新的特性不能及时展现，甚至可能导致逻辑上的冲突。</p>
<p>因此对于这些 js、css 的资源引入，最好用版本号或者更新时间来作为后缀，这样的话，后缀不变，命中缓存；后缀改变，浏览器自动更新最新的代码。</p>
<h3 id="Css-位置"><a href="#Css-位置" class="headerlink" title="Css 位置"></a>Css 位置</h3><p>CSS 要放到 html 代码的开头的 head 标签结束前。如果网页是动态生成的，那么在 head 代码完成后可以强制输出（例如 php 的 flush()操作），这样的话，浏览器就会更快地解析出来 head 中的内容，开始下载 css 文件资源。</p>
<h3 id="Js-位置"><a href="#Js-位置" class="headerlink" title="Js 位置"></a>Js 位置</h3><p>Js 放到前，这样的话，js 的加载不会影响初始页面的渲染。</p>
<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><h3 id="避免空-src"><a href="#避免空-src" class="headerlink" title="避免空 src"></a>避免空 src</h3><p>图片设置为空的 src 地址，在某些浏览器中可能会导致增加一个无效的 http 请求，因此要避免。</p>
<h3 id="避免-css-表达式"><a href="#避免-css-表达式" class="headerlink" title="避免 css 表达式"></a>避免 css 表达式</h3><p>可能会让页面多次执行计算，造成卡顿等性能问题。</p>
<h3 id="避免空-css-规则"><a href="#避免空-css-规则" class="headerlink" title="避免空 css 规则"></a>避免空 css 规则</h3><p>降低 css 渲染计算的成本</p>
<h3 id="避免直接设置元素-style"><a href="#避免直接设置元素-style" class="headerlink" title="避免直接设置元素 style"></a>避免直接设置元素 style</h3><p>直接设置 style 属性，一方面在 html 代码中不利于缓存，另一方面也不利于样式的复用，因此要避免，通过指定 id 或者 class 的方式，在 css 代码块中进行样式调整。</p>
<h2 id="服务端接口"><a href="#服务端接口" class="headerlink" title="服务端接口"></a>服务端接口</h2><h3 id="接口合并"><a href="#接口合并" class="headerlink" title="接口合并"></a>接口合并</h3><p>如果页面需要请求两部分以上的数据接口，建议将其合并，否则会增加一次 http 请求。</p>
<h3 id="减少接口数据量"><a href="#减少接口数据量" class="headerlink" title="减少接口数据量"></a>减少接口数据量</h3><p>有的时候，服务端会把一些无关紧要的数据返回回来，尤其是类似于更新时间、状态等信息，如果在客户端不影响内容的逻辑展示，不妨在接口返回的数据中直接去掉这些内容。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存接口数据，在一些数据新旧敏感性不高的场景下很有作用，在非首次加载数据时候优先使用上次请求来的缓存数据，可以让页面更加快速地渲染出来，而不用等待一个新的 http 请求结束之后再渲染。这一点我们在后面还会再次提及。</p>
<h2 id="其他一些建议"><a href="#其他一些建议" class="headerlink" title="其他一些建议"></a>其他一些建议</h2><ul>
<li>合理使用 css<ul>
<li>正确使用 Display 属性 Display 属性会影响页面的渲染，因此请合理使用</li>
<li>display:inline 后不应该再使用 width、height、margin、padding 以及 float</li>
<li>display:inline-block 后不应该再使用 float</li>
<li>display:block 后不应该再使用 vertical-align</li>
<li>display:table-*后不应该再使用 margin 或者 float</li>
<li>不滥用 float</li>
<li>不声明过多的 font-size</li>
<li>值为 0 时不需要单位</li>
<li>标准化各种浏览器前缀</li>
<li>无前缀应放在最后</li>
<li>CSS 动画只用 （-webkit- 无前缀）两种即可</li>
<li>其它前缀为 -webkit- -moz- -ms- 无前缀 四种，（-o-Opera 浏览器改用 blink 内核，所以淘- 汰）</li>
</ul>
</li>
<li>选择器<ul>
<li>避免让选择符看起来像是正则表达式。高级选择器不容易读懂，执行耗时也长</li>
<li>尽量使用 ID 选择器</li>
<li>尽量使用 css3 动画</li>
</ul>
</li>
<li>资源加载<ul>
<li>使用 srcset</li>
<li>首次加载不超过 1024KB（或者可以说是越小越好）</li>
</ul>
</li>
<li>html 和 js<ul>
<li>减少重绘和回流</li>
<li>缓存 dom 选择和计算</li>
<li>缓存列表.length</li>
<li>尽量使用事件代理,避免批量绑定事件</li>
<li>使用 touchstart，touchend 代替 click</li>
<li>Html 使用 viewport</li>
<li>减少 dom 节点</li>
<li>合理使用 requestAnimationFrame 动画代替 setTimeOut</li>
<li>适当使用 Canvas 动画</li>
<li>TouchMove, Scroll 事件会导致多次渲染</li>
</ul>
</li>
</ul>
<h2 id="更快一步"><a href="#更快一步" class="headerlink" title="更快一步"></a>更快一步</h2><p>前面的很多建议与普通的 PC 端 web 网页的开发是一致的，但是在移动互联网应用下，仅仅做到这些，可能只有 60 分，那么怎样才能得到 80 分甚至更高？</p>
<h3 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h3><p>钉钉的审批微应用，使用的就是单页架构。在这种架构下，基本不存在页面跳转的等待时间，只需要执行 js 逻辑触发界面变化，最多进行一次网络请求，获得服务端数据，其他资源均不需要再次请求。</p>
<h3 id="资源离线"><a href="#资源离线" class="headerlink" title="资源离线"></a>资源离线</h3><p>再快的网络交互，毕竟也是跨越了数个网络节点，因此一张图片、一个 js，优化到了极致，也照样可能需要几百毫秒的时间来获得。因此想要打破这个极限，就要使用资源离线的策略。</p>
<p>在钉钉的微应用中，就使用了这样的一个“离线包”策略。一些固定的图片、js 库等，被打包放入 app 中（或根据需要，在 app 启动的时候进行下载更新）。</p>
<p>微应用中，网页代码里面加载网络资源的需求，就变成了直接加载本地文件，速度自然得到再一次巨大的提升。</p>
<h3 id="本地数据持久化和更新机制-版本管理"><a href="#本地数据持久化和更新机制-版本管理" class="headerlink" title="本地数据持久化和更新机制(版本管理)"></a>本地数据持久化和更新机制(版本管理)</h3><p>对于一些时效性没有那么高的数据，可以考虑将接口数据缓存。那么页面的渲染将变成这样的流程：</p>
<p><img src="/2019/07/25/H5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/5c6a89dd-69d3-4491-aabb-ad0d1d5e7d85.png"></p>
<p>而非首次进入界面，流程如下：</p>
<p><img src="/2019/07/25/H5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/64c3379b-45c3-45a3-9280-c8f9689fcc1f.png"></p>
<p>可以看出，在非首次进入界面的时候，页面不需要等待网络数据返回，就可以进行界面渲染，渲染的初始数据来自于本地的缓存，页面可以“秒开”。而当服务端的数据返回之后，本地的渲染会再次更新，缓存也被更新。</p>
<p>采用这样的方案有利有弊，好处显而易见，首屏加载的速度简直太快了——静态资源来自本地，数据接口来自本地，这在 2G、3G 或者其他网络速度较慢的时候，也可以让用户在极短的时间内就看到内容。但是这种方案也并非万能。</p>
<ol>
<li>首次加载不可避免，还是会请求网络。</li>
<li>服务端有更新的时候，客户端不能够快速感知，页面可能还停留在一个“旧的版本”上，尤其是网络速度较慢时，可能还是需要经过好几秒，页面才会更新至最新版本。因此如果应用对数据的新旧很敏感的话，这种方案就不适合</li>
<li>数据更新后，需要重新渲染界面，界面刷新的性能消耗比正常情况更多，而且增加了程序的复杂度，容易出错。</li>
</ol>
<h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>有时，我们能够通过用户的行为统计，预判出用户下一步可能进行的操作。假设，我们统计出来针对某个微应用，用户首页渲染完成之后，大部分会点击列表中的第一个项目查看详情。那么在首页渲染完成之后，我们就可以先预先加载第一个项目的部分内容，那么针对这部分用户，他们实际点击之后，立即就能看到新的页面中的内容。</p>
<p>当然，这个方式也并不是在所有场景下都使用。一方面，需要做好充分的用户调研，掌握用户的使用习惯；另一方面，对于小部分用户而言，预加载所带来的就是不必要的流量消耗。</p>
<h1 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h1><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><p>在功能测试中，我们通常可以用 chrome 来测试不同的分辨率下，或是不同的设备上，网页的展现情况。在我们做性能优化的时候，也可以用这种方式来进行调试，方便地观察在特定设备上，静态资源是否按照我们想象的那样去加载了。</p>
<p><img src="/2019/07/25/H5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/3e9446f5-e962-42c1-a471-4548f39e2d79.png"></p>
<p>例如，我们想看下百度首页在某个设备下的表现。通过 F12 进入控制台，点击图中的短箭头标示出来的那个设备图标，然后就可以在 Device 和 Network 中选择不同的设备和网络状况。</p>
<p><img src="/2019/07/25/H5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/60032c93-e06f-4615-8e30-13f4183ea9b6.png"></p>
<p>例如 iphone5 下，这个地图的图标，明显就可以看到是用 iconfont 来实现的效果。</p>
<p>当然，这个功能也仅仅是一种模拟，通过控制屏幕分辨率、UserAgent 等来模拟设备请求，在实际的设备上，又该怎么查看呢？</p>
<p>还是 Chrome，我们在地址栏中输入 chrome:&#x2F;&#x2F;inspect（注意：Android 版本需要是 4.4+，并且应用中的 WebView 必须进行相应的调试声明配置）</p>
<p><img src="/2019/07/25/H5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/23717eca-d582-4907-b6ea-5da9761398c3.png"></p>
<p>在这里点击 inspect，则可进入我们熟悉的 F12 控制台界面，只不过 debug 的对象变成了我们在手机应用中的网页。</p>
<p><img src="/2019/07/25/H5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/3894498a-5c50-43cb-8466-a414e63980c0.png"></p>
<p>输入 performance.timing.domComplete - performance.timing.navigationStart，就可以打印出网页加载的时间，domComplete 表示所有的处理都已完成并且所有的附属资源都已经下载完毕。navigationStart 表示开始加载新页面。两者相减，就代表这个网页完成渲染所需要的时间了。</p>
<p>同样地，我们可以在 Elements tab 中，debug 网页，查看各个资源的使用，在 Network 中，看看加载了哪些资源，是否都做过了压缩。</p>
<p>然而，这种方式，还是有一定缺陷。1. 如果打开网页经过了跳转，那么我们只能在这里看到最后一个 url 页面的加载情况。2. 第一次打开页面的时候，在 Network 中，默认是不显示请求的详情的，当我们选择了 preserve log upon navigation 之后才会捕获，因此首次进入页面的加载情况，我们就很难获得了。</p>
<p>那么有没有一种方法，让我们能够更方便地去查看首次访问时，各种资源的加载使用情况呢？</p>
<h3 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h3><p>Charles Proxy，可以说是 H5 测试的一个神器。它的作用是在 PC 端开启一个代理服务器，手机连到这个代理服务器上之后，所有的 http 请求就都可以在这里看得清清楚楚。经过配置证书选项，https 的请求也可以正常查看。</p>
<p>从图中，我们明显可以看到，有一些 404 的异常请求，这些都将对我们 H5 应用的性能造成影响。如果我们发现有一些资源的 Duration 比较大，那这些可能是服务端响应太慢，自然也可以作为我们优化的依据。</p>
<h2 id="测试标准"><a href="#测试标准" class="headerlink" title="测试标准"></a>测试标准</h2><p>在钉钉的测试中，形成了一套标准。</p>
<p>| 指标项 | 遵循的原则                 | 优先级 | 检查项                                                                 | 说明                                                      |<br>| :—– | :————————- | :—– | :——————————————————————— | :——————————————————– | —————————— |<br>| 内存   | 内存无泄漏                 | P0     | 主功能页面反复打开，功能的重复调用，内存无泄漏                         | 可以使用 sysdump,也可以用我们开发的 perfeasy 工具进行观察 |<br>|        |                            | P1     | 主功能页面，持续操作，退出后，内存占用不超过总内存的 5%                | perfeasy                                                  |<br>| CPU    | 减少无端的 CPU 使用        | P1     | 灭屏，静置 2 分钟，在 5 分钟内 CPU 使用平均 1%                         | adb 连接后, 使用 top 命令                                 |<br>|        |                            |        | 主干功能正常操作 CPU 占用不超过 60%, 持续 5 秒                         | perfeasy                                                  |<br>| 电量   | 避免无端电量消耗           | P0     | 灭屏状态下，无线程持续运行                                             | 一般来说, 静置 cpu 正常, 这一项就没有问题                 |<br>|        |                            |        | 灭屏，window.setTimeout()方法停止                                      | 一般来说, 静置 cpu 正常, 这一项就没有问题同上             |<br>|        |                            |        | 灭屏，window.setInterval()方法停止                                     | 同上                                                      |<br>|        |                            |        | ajax 超时时间设置为 5000ms 以内                                        | 结合代码                                                  |<br>|        |                            |        | ajax 无 retry 逻辑                                                     | 结合代码                                                  |<br>| 资源   | 资源的正确使用             | P0     | 是否存在资源的重复拉取                                                 | charles                                                   |<br>|        |                            | P1     | H5 页面首屏总大小不超过 200K                                           | charles, chrome                                           |<br>|        |                            | P1     | 抓包检查(js&#x2F;css&#x2F;html)代码去除了空格&#x2F;注释，JS 文件变量名变成 a&#x2F;b 等代替 | charles, chrome                                           |<br>|        |                            | P1     | H5 引用的单张图片小于 60K                                              | charles, chrome                                           | 如果影响了显示质量, 可酌情调整 |<br>| 流畅度 | 确保给到用户流畅的展示体验 | P1     | 流畅的实时动画展示，avgFPS&gt;&#x3D;45                                         | perfeasy                                                  |<br>| 时延   | 确保给到用户流畅的切换体验 | P0     | wifi 网络下，首次进入页面 onload 时间&lt;1000ms                           | Chrome                                                    |<br>| 时延   | 确保给到用户流畅的切换体验 | P0     | wifi 网络下，首次进入页面 onload 时间&lt;1000ms                           | Chrome                                                    |<br>|        |                            |        | wifi 网络下，非首次进入页面 onload 时间&lt;500ms                          | Chrome                                                    |<br>|        |                            |        | 3G 正常网络， 首次进入页面 onload 时间&lt;2000ms                          | chrome, 树莓派模拟 3G                                     |<br>|        |                            |        | 3G 正常网络， 非首次进入页面 onload 时间&lt;1000ms                        | chrome, 树莓派模拟 3G                                     |</p>
<h2 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h2><h3 id="图片未优化"><a href="#图片未优化" class="headerlink" title="图片未优化"></a>图片未优化</h3><p>通过 charles 可以方便地进行测试。从请求监控的情况看，有一张图片超过了 60KB，宽度 640px，但是在应用中，实际显示的是一张小缩略图，是通过代码控制让它显示成小图的，因此修改方案很简单，将所有头像的图片均改为获取 120px 宽度的即可。<br><img src="/2019/07/25/H5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/1e72c743-db5a-4659-b290-22a181f94096.png"></p>
<h3 id="按需加载-1"><a href="#按需加载-1" class="headerlink" title="按需加载"></a>按需加载</h3><ul>
<li>钉钉的教学页面<ul>
<li>多个 slide 页面, 每个页面有 2-3 个图片, 其中有一个是大图显示</li>
<li>图片是客户提供的, 最大的图片大约是 300KB 以上</li>
<li>第一次进入页面后, 所有 slide 的图片均进行加载</li>
<li>3G 网络下, loading 的图标大约持续 6000ms 后才会消失</li>
</ul>
</li>
<li>优化方案<ul>
<li>尽可能优化图片, 但是压缩后发现噪点明显增加, 影响了显示效果</li>
<li>修改加载方案, 第一次进入后, 只加载本页的图片</li>
<li>loading 时间降低至 1 秒左右</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 常用命令</title>
    <url>/2019/07/25/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h1><h2 id="apt-get-Debian-x2F-Ubuntu-系统包管理器"><a href="#apt-get-Debian-x2F-Ubuntu-系统包管理器" class="headerlink" title="apt-get Debian&#x2F;Ubuntu 系统包管理器"></a>apt-get Debian&#x2F;Ubuntu 系统包管理器</h2><p><code>apt-get</code> 是 Debian&#x2F;Ubuntu 系统中一个用于快速下载&#x2F;安装的简单命令行管理工具</p>
<h3 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h3><span id="more"></span>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令</span></span><br><span class="line">update -检索新的包列表</span><br><span class="line">upgrade -升级可更新的所有软件包</span><br><span class="line">install -安装新软件包（pkg是libc6不是libc6.deb）</span><br><span class="line">remove -删除软件包</span><br><span class="line">autoremove -自动删除所有未使用的软件包</span><br><span class="line">purge -删除软件包和配置文件</span><br><span class="line">clean -清除已下载的归档文件</span><br><span class="line">autoclean -清除旧的下载的档案文件</span><br><span class="line">check -验证是否有损坏的依赖</span><br><span class="line">download -下载二进制包到当前目录</span><br><span class="line"><span class="comment"># 选项：</span></span><br><span class="line">-q ：不输出任何信息</span><br><span class="line">-qq ：除了错误之外，没有输出</span><br><span class="line">-d ：仅下载，不要安装或解压缩存档</span><br><span class="line">-y ：对所有确定询问都选择Yes，并且不提示</span><br><span class="line">-f ：尝试纠正被破坏依赖关系的系统</span><br><span class="line">-m ：如果存档是可定位的，则尝试继续</span><br><span class="line">-u ：显示升级包的列表</span><br><span class="line">-b ：在获取源代码包后构建源包</span><br><span class="line"><span class="comment"># 更多的命令可以用 apt-get --help 查看。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检索 新的包列表</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="comment"># 升级 可更新的所有软件包（注意这个命令会升级所有的软件包，所以会升级很长时间）</span></span><br><span class="line">apt-get upgrade</span><br><span class="line"><span class="comment"># 安装 Nginx 软件包</span></span><br><span class="line">apt-get install nginx</span><br><span class="line"><span class="comment"># 卸载 Nginx 软件包</span></span><br><span class="line">apt-get remove nginx</span><br><span class="line"><span class="comment"># 卸载 Nginx 软件包 并删除所有相关配置文件</span></span><br><span class="line">apt-get remove --purge nginx</span><br><span class="line"><span class="comment"># 在安装软件和卸载的时候，为了避免误操作，都会询问是否继续，每次都要输入 y 来确定会很麻烦，可以加上 -y 参数</span></span><br><span class="line"><span class="comment"># 安装 Nginx 软件包 并不显示确定提示</span></span><br><span class="line">apt-get install nginx -y</span><br><span class="line"><span class="comment"># 卸载 Nginx 软件包，删除所有相关配置文件 并不显示提示</span></span><br><span class="line">apt-get remove --purge nginx -y</span><br><span class="line"><span class="comment"># 清除 旧的/无用 的软件包</span></span><br><span class="line">apt-get clean &amp;&amp; apt-get autoclean</span><br><span class="line"><span class="comment"># 下载 Nginx 二进制软件包到当前目录，但不解压和安装</span></span><br><span class="line">apt-get download nginx -d</span><br><span class="line"><span class="comment"># 更多的命令可以用 apt-get --help 查看。</span></span><br></pre></td></tr></table></figure>

<h2 id="yum-CentOS-系统包管理器"><a href="#yum-CentOS-系统包管理器" class="headerlink" title="yum CentOS 系统包管理器"></a>yum CentOS 系统包管理器</h2><p>yum 是 CentOS 系统中 一个用于快速下载&#x2F;安装的简单命令行管理工具！</p>
<h3 id="参数介绍-1"><a href="#参数介绍-1" class="headerlink" title="参数介绍"></a>参数介绍</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令：</span></span><br><span class="line">update -检索新的包列表</span><br><span class="line">upgrade -升级软件包</span><br><span class="line">search -搜索软件包</span><br><span class="line">install -安装软件包</span><br><span class="line">list -列出软件包或者软件包组</span><br><span class="line">info -显示软件包或者软件包组的详细信息</span><br><span class="line">erase -删除软件包（这两个命令一样）</span><br><span class="line">remove -删除软件包（这两个命令一样）</span><br><span class="line">groupinfo -显示有关包组的详细信息</span><br><span class="line">groupinstall -安装软件包组（就像一种软件合集）</span><br><span class="line">grouplist -列出可用的软件包组</span><br><span class="line">groupremove -删除软件包组</span><br><span class="line">check -检查软件包</span><br><span class="line">check-update -检查可更新的软件包</span><br><span class="line">clean -清除缓存目录内的软件包</span><br><span class="line">deplist -列出一个包的依赖关系</span><br><span class="line">distribution-synchronization -同步已安装的软件包到最新的版本</span><br><span class="line">downgrad -降级一个软件包</span><br><span class="line">reinstall -重新安装软件包（自动删除重装）</span><br><span class="line">repolist -显示配置的软件包仓库</span><br><span class="line">resolvedep -确定软件包需要的依赖关系</span><br><span class="line"><span class="comment"># 选项：</span></span><br><span class="line">-t ：容忍错误</span><br><span class="line">-C ：完全从系统缓存运行，不要更新缓存</span><br><span class="line">-R 分钟：最大命令等待时间</span><br><span class="line">-q ：安静的操作</span><br><span class="line">-y ：对于所有问题回答是</span><br><span class="line">--nogpgcheck ：禁用gpg签名检查</span><br><span class="line"><span class="comment"># 更多的命令可以用 yum --help 查看。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检索 新的包列表</span></span><br><span class="line">yum update</span><br><span class="line"><span class="comment"># 安装 Nginx 软件包</span></span><br><span class="line">yum install nginx</span><br><span class="line"><span class="comment"># 安装 Development Tools 软件包组（这个软件包组中包含了编译所需的软件）</span></span><br><span class="line"><span class="comment"># 注意：当软件包或者软件包组的名字中包含空格的时候，请把 软件包或软件包组 加上双引号！</span></span><br><span class="line">yum groupinstall <span class="string">&quot;Development Tools&quot;</span></span><br><span class="line"><span class="comment"># 卸载 Nginx 软件包</span></span><br><span class="line">yum erase nginx / yum remove nginx</span><br><span class="line"><span class="comment"># 卸载 Development Tools 软件包组</span></span><br><span class="line">yum groupremove <span class="string">&quot;Development Tools&quot;</span></span><br><span class="line"><span class="comment"># 升级 所有可更新的软件包</span></span><br><span class="line">yum upgrade</span><br><span class="line"><span class="comment"># 升级 Nginx 可更新的软件包</span></span><br><span class="line">yum upgrade nginx</span><br><span class="line"><span class="comment"># 在安装软件和卸载的时候，为了避免误操作，都会询问是否继续，每次都要输入 y 来确定会很麻烦，可以加上 -y 参数</span></span><br><span class="line"><span class="comment"># 安装 Nginx 软件包 并不显示确定提示</span></span><br><span class="line">yum install nginx -y</span><br><span class="line"><span class="comment"># 卸载 Nginx 软件包 并不显示确定提示</span></span><br><span class="line">yum erase nginx -y / yum remove nginx -y</span><br><span class="line"><span class="comment"># 搜索 Nginx 软件包是否存着</span></span><br><span class="line">yum search nginx</span><br><span class="line"><span class="comment"># 列出 可用的软件包</span></span><br><span class="line">yum list</span><br><span class="line"><span class="comment"># 列出 可用的软件包组</span></span><br><span class="line">yum grouplist</span><br><span class="line"><span class="comment"># 清除 缓存目录中的所有软件包</span></span><br><span class="line">yum clean</span><br><span class="line"><span class="comment"># 清除 缓存目录中的 Nginx 软件包</span></span><br><span class="line">yum clean nginx</span><br><span class="line"><span class="comment"># 重装 Nginx 软件包</span></span><br><span class="line">yum reinstall nginx</span><br><span class="line"><span class="comment"># 更多的命令可以用 yum --help 查看。</span></span><br></pre></td></tr></table></figure>

<h1 id="文件-x2F-文件夹-操作"><a href="#文件-x2F-文件夹-操作" class="headerlink" title="文件&#x2F;文件夹 操作"></a>文件&#x2F;文件夹 操作</h1><p>以下除特殊说明，都以当前目录为 &#x2F;root 示例。</p>
<h2 id="mkdir-新建文件夹"><a href="#mkdir-新建文件夹" class="headerlink" title="mkdir 新建文件夹"></a>mkdir 新建文件夹</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前文件夹新建一个 bash 文件夹，完整的绝对路径就是 /root/bash</span></span><br><span class="line"><span class="built_in">mkdir</span> bash</span><br><span class="line"><span class="comment"># 更多的命令可以用 mkdir --help 查看。</span></span><br><span class="line"><span class="built_in">cd</span> 进入 文件夹</span><br><span class="line"><span class="comment"># 你当前在 /root目录中，使用这个命令会进入 /root/bash目录，这是相对路径</span></span><br><span class="line"><span class="built_in">cd</span> bash</span><br><span class="line"><span class="comment"># 如果你不在 /root目录中的话，就不能用上面的相对路径了，就需要绝对路径</span></span><br><span class="line"><span class="built_in">cd</span> /root/bash</span><br><span class="line"><span class="comment"># 假设你当前在 /root/bash目录中，使用相对路径，你可以用这个命令进入上一级 /root目录， .. 代表相对路径 上级目录</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="comment"># 当然你也可以用绝对路径来进入上一级 /root目录</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br></pre></td></tr></table></figure>

<h2 id="cd-进入-文件夹"><a href="#cd-进入-文件夹" class="headerlink" title="cd 进入 文件夹"></a>cd 进入 文件夹</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 你当前在 /root目录中，使用这个命令会进入 /root/bash目录，这是相对路径</span></span><br><span class="line"><span class="built_in">cd</span> bash</span><br><span class="line"><span class="comment"># 如果你不在 /root目录中的话，就不能用上面的相对路径了，就需要绝对路径</span></span><br><span class="line"><span class="built_in">cd</span> /root/bash</span><br><span class="line"><span class="comment"># 假设你当前在 /root/bash目录中，使用相对路径，你可以用这个命令进入上一级 /root目录， .. 代表相对路径 上级目录</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="comment"># 当然你也可以用绝对路径来进入上一级 /root目录</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br></pre></td></tr></table></figure>

<h2 id="cp-复制或重命名-文件-x2F-文件夹"><a href="#cp-复制或重命名-文件-x2F-文件夹" class="headerlink" title="cp 复制或重命名 文件&#x2F;文件夹"></a>cp 复制或重命名 文件&#x2F;文件夹</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制当前目录内的 log.txt文件到 /var目录</span></span><br><span class="line"><span class="built_in">cp</span> log.txt /var/log.txt</span><br><span class="line"><span class="comment"># 复制当前目录内的 bash文件夹到 /home目录</span></span><br><span class="line"><span class="built_in">cp</span> -R bash /home/bash</span><br><span class="line"><span class="built_in">cp</span> *.txt /var/log</span><br><span class="line"><span class="comment"># 复制当前目录内的所有以 test开头的文件到 /var/log目录</span></span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">test</span>*/var/log</span><br><span class="line"><span class="comment"># 复制当前目录内的所有以 test开头 以.txt后缀结尾的文件到 /var/log目录</span></span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">test</span>*.txt /var/log</span><br><span class="line"><span class="comment"># 假设当前目录是 /root/test/log，要把这个目录中的所有.txt后缀的文件复制到上一级目录 /root/test，那么这样做</span></span><br><span class="line"><span class="built_in">cp</span> *.txt ..</span><br><span class="line"><span class="comment"># .. 就是相对路径，代表上一级目录，当然你也可以用绝对路径，这样更不容易出错</span></span><br><span class="line"><span class="built_in">cp</span> *.txt /root/test</span><br><span class="line"><span class="comment"># 重命名当前目录内的 log.txt文件为 log2.txt</span></span><br><span class="line"><span class="built_in">cp</span> log.txt log2.txt</span><br><span class="line"><span class="comment"># 复制当前目录内的 log.txt文件到 /var目录并重命名为 log1.txt</span></span><br><span class="line"><span class="built_in">cp</span> log.txt /var/log1.txt</span><br><span class="line"><span class="comment"># 复制当前目录内的 bash文件夹到 /home目录并重命名为 bash2</span></span><br><span class="line"><span class="built_in">cp</span> -R bash /home/bash2</span><br><span class="line"><span class="comment"># 复制当前目录内的 log.txt文件到 /var目录，但是 /var 目录中已经存着 log.txt，那么会提示 cp: overwrite `/var/log.txt&#x27;? 可以用 -f 强制覆盖</span></span><br><span class="line"><span class="built_in">cp</span> -f <span class="built_in">log</span> /var/log.txt</span><br><span class="line"><span class="comment"># 复制当前目录内的 log.txt log1.txt log2.txt文件和 log233目录到 /home/log目录中</span></span><br><span class="line"><span class="built_in">cp</span> -R log.txt log1.txt log2.txt log233 /home/log</span><br><span class="line"><span class="comment"># 更多的命令可以用 cp --help 查看。</span></span><br></pre></td></tr></table></figure>

<h2 id="mv-移动或重命名-文件-x2F-文件夹"><a href="#mv-移动或重命名-文件-x2F-文件夹" class="headerlink" title="mv 移动或重命名 文件&#x2F;文件夹"></a>mv 移动或重命名 文件&#x2F;文件夹</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关于 mv 命令，可以参考上面 cp 的使用方法，没什么区别，只是一个是复制，一个是移动，把上面 cp 命令改成 mv 就能套用了。</span></span><br><span class="line"><span class="comment"># 移动当前目录内的 log.txt文件到 /var目录</span></span><br><span class="line"><span class="built_in">mv</span> log.txt /var/log.txt</span><br><span class="line"><span class="comment"># 移动当前目录内的 bash文件夹到 /home目录</span></span><br><span class="line"><span class="built_in">mv</span> bash /home/bash</span><br><span class="line"><span class="comment"># 重命名当前目录内的 log.txt文件为 log2.txt</span></span><br><span class="line"><span class="built_in">mv</span> log.txt log2.txt</span><br><span class="line"><span class="comment"># 复制当前目录内的 log.txt文件到 /var目录并重命名为 log1.txt</span></span><br><span class="line"><span class="built_in">mv</span> log.txt /var/log1.txt</span><br><span class="line"><span class="comment"># 复制当前目录内的 bash文件夹到 /home目录并重命名为 bash2</span></span><br><span class="line"><span class="built_in">mv</span> bash /home/bash2</span><br><span class="line"><span class="comment"># 更多的命令可以用 mv --help 查看。</span></span><br></pre></td></tr></table></figure>

<h2 id="rm-删除-文件-x2F-文件夹"><a href="#rm-删除-文件-x2F-文件夹" class="headerlink" title="rm 删除 文件&#x2F;文件夹"></a>rm 删除 文件&#x2F;文件夹</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除当前目录下的 log.txt文件</span></span><br><span class="line"><span class="built_in">rm</span> log.txt</span><br><span class="line"><span class="comment"># 删除当前目录下所有.txt后缀的文件</span></span><br><span class="line"><span class="built_in">rm</span> *.txt</span><br><span class="line"><span class="comment"># 使用 rm 命令删除时，会提示你是否确定删除，输入 y 即删除，输入 n 则取消</span></span><br><span class="line"><span class="comment"># rm: remove regular file `log.txt&#x27;? y</span></span><br><span class="line"><span class="comment"># 删除当前目录下所有.txt后缀的文件</span></span><br><span class="line"><span class="built_in">rm</span> *.txt</span><br><span class="line"><span class="comment"># 删除当前目录下所有以 test开头的文件</span></span><br><span class="line"><span class="built_in">rm</span> <span class="built_in">test</span>*</span><br><span class="line"><span class="comment"># 删除当前目录下所有以 test开头 以.txt后缀结尾的文件</span></span><br><span class="line"><span class="built_in">rm</span> <span class="built_in">test</span>*.txt</span><br><span class="line"><span class="comment"># 当你用 rm 删除目录的时候会发现提示这不是一个文件</span></span><br><span class="line"><span class="comment"># rm bash</span></span><br><span class="line"><span class="comment"># rm: cannot remove `bash&#x27;: Is a directory</span></span><br><span class="line"><span class="comment"># 可以加上 -r 来归递删除目录及其目录下的内容</span></span><br><span class="line"><span class="built_in">rm</span> -r bash</span><br><span class="line"><span class="comment"># 因为为了避免手误删除错误，所以 rm默认是加上了 -i 的参数，也就是每一次删除文件/目录都会提示，如果觉得烦可以用 -rf 参数</span></span><br><span class="line"><span class="built_in">rm</span> -rf bash</span><br><span class="line"><span class="comment"># rm -rf 这个命令请慎重使用，而且千万不要使用 rm -rf / 或者 rm -rf /* 之类的命令(系统自杀)，可能会让你系统爆炸，所以使用请慎重！</span></span><br><span class="line"><span class="comment"># 更多的命令可以用 rm --help 查看。</span></span><br></pre></td></tr></table></figure>

<h1 id="查找-操作"><a href="#查找-操作" class="headerlink" title="查找 操作"></a>查找 操作</h1><h2 id="find-文件查找"><a href="#find-文件查找" class="headerlink" title="find 文件查找"></a>find 文件查找</h2><p>find 命令用于查找文件系统中的指定文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line">find 要查找的路径表达式</span><br><span class="line"><span class="comment"># 在当前目录及其子目录下查找文件 “1.txt”；</span></span><br><span class="line">find . -name 1.txt</span><br><span class="line"><span class="comment"># 在 “/tmp” 目录及其子目录下查找文件“1.txt”。</span></span><br><span class="line">find /tmp -name 1.txt</span><br></pre></td></tr></table></figure>

<h2 id="grep-文件内容查找"><a href="#grep-文件内容查找" class="headerlink" title="grep 文件内容查找"></a>grep 文件内容查找</h2><p>grep 命令用于查找指定的模式匹配</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line">grep [命令选项] 要查找的匹配模式 [要查找的文件]</span><br><span class="line"><span class="comment"># 在 “test.txt” 文件中查找cams 字符串；</span></span><br><span class="line">grep cams test.txt</span><br><span class="line"><span class="comment"># 在 “/root/cams” 目录及其子目录下的所有文件中，查找cams 字符串；</span></span><br><span class="line">grep -r cams /root/cams</span><br><span class="line"><span class="comment"># grep 命令除了能够查找文件外，还能够将任意输出流重定向到grep 进行查找：</span></span><br><span class="line"><span class="comment"># 查找进程名中包含 “ora” 的所有进程信息。</span></span><br><span class="line">ps -ef | grep ora</span><br></pre></td></tr></table></figure>

<h1 id="查看-x2F-编辑文件-操作"><a href="#查看-x2F-编辑文件-操作" class="headerlink" title="查看&#x2F;编辑文件 操作"></a>查看&#x2F;编辑文件 操作</h1><h2 id="ls-显示目录中文件"><a href="#ls-显示目录中文件" class="headerlink" title="ls 显示目录中文件"></a>ls 显示目录中文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前目录下的所有文件</span></span><br><span class="line"><span class="built_in">ls</span> -a</span><br><span class="line"><span class="comment"># 命令后面加上 绝对路径/相对路径 就会显示指定文件夹内的所有文件</span></span><br><span class="line"><span class="built_in">ls</span> -a bash/log</span><br><span class="line"><span class="comment"># 相对路径，当前目录是 /root ，欲查看的目录是 /root/bash/log</span></span><br><span class="line"><span class="built_in">ls</span> -a /root/bash/log</span><br><span class="line"><span class="comment"># 绝对路径， 当前目录是 /root ，欲查看的目录是 /root/bash/log</span></span><br><span class="line"><span class="comment"># 更多的命令可以用 ls --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h2 id="du-查看-文件-x2F-文件夹-占用磁盘空间的大小"><a href="#du-查看-文件-x2F-文件夹-占用磁盘空间的大小" class="headerlink" title="du 查看 文件&#x2F;文件夹 占用磁盘空间的大小"></a>du 查看 文件&#x2F;文件夹 占用磁盘空间的大小</h2><h3 id="参数介绍-2"><a href="#参数介绍-2" class="headerlink" title="参数介绍"></a>参数介绍</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-h ：以人类易读的方式显示</span><br><span class="line">-a ：显示目录占用的磁盘空间大小，并显示其下目录和文件占用磁盘空间的大小</span><br><span class="line">-s ：显示目录占用的磁盘空间大小，但不显示其下子目录和文件占用的磁盘空间大小</span><br><span class="line">-c ：显示几个目录或文件占用的磁盘空间大小，还要统计它们的总和</span><br><span class="line">--apparent-size：显示目录或文件自身的大小</span><br><span class="line">-l ：统计硬链接占用磁盘空间的大小</span><br><span class="line">-L ：统计符号链接所指向的文件占用的磁盘空间大小</span><br><span class="line"><span class="comment"># 待写...</span></span><br><span class="line"><span class="comment"># 更多的命令可以用 du --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示 /root 文件夹的大小，但不显示其子目录和文件的大小</span></span><br><span class="line"><span class="built_in">du</span> -sh</span><br><span class="line"><span class="comment"># 显示 /root 文件夹的大小，并显示其子目录和文件的大小</span></span><br><span class="line"><span class="built_in">du</span> -ah</span><br><span class="line"><span class="comment"># 待写...</span></span><br><span class="line"><span class="comment"># 更多的命令可以用 du --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h2 id="cat-查看文件内容"><a href="#cat-查看文件内容" class="headerlink" title="cat 查看文件内容"></a>cat 查看文件内容</h2><p>假设 log.txt 文件的内容为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">test233</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">test666</span><br><span class="line">test2366</span><br><span class="line">test8888</span><br></pre></td></tr></table></figure>

<h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 log.txt 文件的所有内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例如下</span></span><br><span class="line"></span><br><span class="line">test233</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">test666</span><br><span class="line">test2366</span><br><span class="line">test8888</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log.txt 文件的所有内容，并对所有行编号</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> -n log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例如下：</span></span><br><span class="line"></span><br><span class="line">1 test233</span><br><span class="line">2 <span class="built_in">test</span></span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5 test666</span><br><span class="line">6</span><br><span class="line">7 test2366</span><br><span class="line">8 test8888</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log.txt 文件的所有内容，并对非空行编号</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> -b log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例如下：</span></span><br><span class="line"></span><br><span class="line">1 test233</span><br><span class="line">2 <span class="built_in">test</span></span><br><span class="line">3 test666</span><br><span class="line">4 test2366</span><br><span class="line">5 test8888</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log.txt 文件的所有内容，并对非空行编号，且不输出多行空行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> -bs log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例如下：</span></span><br><span class="line"></span><br><span class="line">1 test233</span><br><span class="line">2 <span class="built_in">test</span></span><br><span class="line">3 test666</span><br><span class="line">4 test2366</span><br><span class="line">5 test8888</span><br></pre></td></tr></table></figure>

<h3 id="清空文件"><a href="#清空文件" class="headerlink" title="清空文件"></a>清空文件</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清空当前目录中的 log.txt 文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /dev/null&gt; log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空 /var 目录中的 log.txt 文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /dev/null&gt;/var/log.txt</span><br></pre></td></tr></table></figure>

<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入文本到当前目录中的 log.txt 文件中(加入文本到文件内容最后)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; log.txt &lt;&lt;-<span class="string">EOF</span></span><br><span class="line"><span class="string">test</span></span><br><span class="line"><span class="string">test233</span></span><br><span class="line"><span class="string">test666</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空文件并写入文本到 /var 目录中的 log.txt 文件中(先清空后写入)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt;/var/log.txt &lt;&lt;-<span class="string">EOF</span></span><br><span class="line"><span class="string">test</span></span><br><span class="line"><span class="string">test233</span></span><br><span class="line"><span class="string">test666</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 cat --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h2 id="head-查看文件内容（主要用于正查）"><a href="#head-查看文件内容（主要用于正查）" class="headerlink" title="head 查看文件内容（主要用于正查）"></a>head 查看文件内容（主要用于正查）</h2><h3 id="参数介绍-3"><a href="#参数介绍-3" class="headerlink" title="参数介绍"></a>参数介绍</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-c 数字：显示指定文件的前 xx 字节的内容（bytes）</span><br><span class="line">-n 数字：显示指定文件的前 xx 行的内容</span><br><span class="line">-q ：不显示包含指定文件名的文件头（当使用 <span class="built_in">head</span> 打开多个文件的时候，会去在每个文件输出结果的顶部添加一个包含文件名的文件头用于区分）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 head --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="使用示例"></a>使用示例</h3><p>假设 log.txt 文件内容为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">test3</span><br><span class="line">test4</span><br><span class="line">test5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log.txt 文件的全部内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">head</span> log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log.txt 文件的前 4 字节的内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">head</span> -c 4 log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例</span></span><br><span class="line"></span><br><span class="line">doub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log.txt 文件的前 2 行的内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">head</span> -n 2 log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例</span></span><br><span class="line"></span><br><span class="line">test1</span><br><span class="line">test2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log.txt 文件的从倒数第 2 行到行首的内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">head</span> -n -2 log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例</span></span><br><span class="line"></span><br><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">test3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log.txt log1.txt log2.txt 文件的前 3 行内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">head</span> -n 3 log.txt log1.txt log2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 head --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h2 id="tail-查看文件内容（主要用于倒查）"><a href="#tail-查看文件内容（主要用于倒查）" class="headerlink" title="tail 查看文件内容（主要用于倒查）"></a>tail 查看文件内容（主要用于倒查）</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-c 数字：如果数字为正数(例如-c +5)，显示指定文件从行首第 xx 字节到最后的内容；如果数字为负数(例如-c -5)，显示指定文件从行尾第 xx 字节到最后内容。</span><br><span class="line">-n 数字：如果数字为正数(例如-c +3)，显示指定文件从行首第 xx 行到最后的内容；如果数字为负数(例如-c -3)，显示指定文件从行尾第 xx 行到最后的内容。</span><br><span class="line">-f ：即时输出文件变化后增加的内容，也就是监视一个文件的内容变化（常用于监视日志输出），使用 Ctrl ＋ C 终止</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 tail --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例-4"><a href="#使用示例-4" class="headerlink" title="使用示例"></a>使用示例</h3><p>假设 log.txt 文件内容为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">test3</span><br><span class="line">test4</span><br><span class="line">test5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log.txt 文件的全部内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tail</span> log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log.txt 文件从行首 第 25 字节到最后的内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tail</span> -c +25 log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例</span></span><br><span class="line"></span><br><span class="line">bi4</span><br><span class="line">test5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log.txt 文件从行尾 第 4 字节到最前面的内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tail</span> -c -4 log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例</span></span><br><span class="line"></span><br><span class="line">bi5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log.txt 文件的从第 2 行到最后一行的内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tail</span> -n +2 log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例</span></span><br><span class="line"></span><br><span class="line">test2</span><br><span class="line">test3</span><br><span class="line">test4</span><br><span class="line">test5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log.txt 文件的后 2 行的内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tail</span> -n -2 log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例</span></span><br><span class="line"></span><br><span class="line">test4</span><br><span class="line">test5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 持续查看（监视） log.txt 文件的变化内容（新增加的内容），使用 Ctrl ＋ C 终止</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tail</span> -f log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log.txt log1.txt log2.txt 文件的前 3 行内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tail</span> -n 3 log.txt log1.txt log2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 tail --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h2 id="sed-查看-x2F-编辑文件内容"><a href="#sed-查看-x2F-编辑文件内容" class="headerlink" title="sed 查看&#x2F;编辑文件内容"></a>sed 查看&#x2F;编辑文件内容</h2><h3 id="参数介绍-4"><a href="#参数介绍-4" class="headerlink" title="参数介绍"></a>参数介绍</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-i ：操作后应用保存到原文件（如果不加这个参数，那么任何修改都不会影响原文件里的内容，只会把结果输出）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 待写...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 sed --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例-5"><a href="#使用示例-5" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 log.txt 第 3 行的内容</span></span><br><span class="line"></span><br><span class="line">sed <span class="string">&#x27;3p&#x27;</span> log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log.txt 第 2-8 行的内容</span></span><br><span class="line"></span><br><span class="line">sed <span class="string">&#x27;2,8p&#x27;</span> log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 log.txt 第 4 行</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;4d&#x27;</span> log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 log.txt 第 3-7 行</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;3,7d&#x27;</span> log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 log.txt 第 1 行</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;1d&#x27;</span> log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 log.txt 最后 1 行</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;\$d&#x27;</span> log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 log.txt 文件中所有包含 233 内容的行</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;/233/d&#x27;</span> log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换 log.txt 文件中所有 233 为 666</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;s/233/666/&#x27;</span> log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换 log.txt 文件中所有 /ver 为 test/，因为有斜杠，所以需要使用 \ 转义，但是单引号会导致无法转义，所以要改成双引号。</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&quot;s/\/ver/test\//&quot;</span> log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 待写...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 sed --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h1 id="vi、vim、nano-编辑文件内容"><a href="#vi、vim、nano-编辑文件内容" class="headerlink" title="vi、vim、nano 编辑文件内容"></a>vi、vim、nano 编辑文件内容</h1><h2 id="vi-介绍"><a href="#vi-介绍" class="headerlink" title="vi 介绍"></a>vi 介绍</h2><p>vi 是 Linux 很棒的一个文本编辑器，不过也存在一些缺点，比如操作略麻烦。而 vim 就相当于 vi 的扩展或者加强版，主要介绍 vim。</p>
<h2 id="vim-介绍"><a href="#vim-介绍" class="headerlink" title="vim 介绍"></a>vim 介绍</h2><p>vim 相当于 vi 的扩展或者加强版，一些系统只安装了 vi，所以想要用 vim 还需要手动安装( yum install vim -y &#x2F; apt-get install vim -y)，安装 vim 后，会自动替换或者说整合 vi。</p>
<p>当你使用 vi 命令的时候，首先进入的是 命令行模式，这个模式就是 vi 自身的功能，而点击 I 键 后就会进入编辑模式(插入模式)，这时候就可以直接输入字符了，这个就是 vim 的扩展功能了。当修改完成后，按 ESC 键 即可退出编辑模式回到命令行模式，这时候输入 :wq 并回车代表保存并退出，如果不想保存可以使用 :q! 不保存强制退出。<br>vim 的命令行 命令很多，我也没打算都写出来，只写出最常用的好了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开当前目录下的 log.txt 文件，如果没有那么会新建 log.txt 文件（安装 vim 后，使用 vi 和 vim 打开文件没区别）</span></span><br><span class="line"></span><br><span class="line">vi log.txt</span><br><span class="line">vim log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令行模式下，直接输入以下 符号和字母(区分大小写)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 进入编辑模式（插入模式，按 Esc 键 即可返回命令行模式）</span></span><br><span class="line"></span><br><span class="line">i</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除光标当前所在的一行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除文件内所有内容</span></span><br><span class="line"></span><br><span class="line">dddG</span><br><span class="line"></span><br><span class="line"><span class="comment">## 复制光标当前所在的一行</span></span><br><span class="line"></span><br><span class="line">yy</span><br><span class="line"></span><br><span class="line"><span class="comment">## 粘贴刚才复制的一行内容</span></span><br><span class="line"></span><br><span class="line">p</span><br><span class="line"></span><br><span class="line"><span class="comment">## 撤销上个操作（误操作可以用这个恢复）</span></span><br><span class="line"></span><br><span class="line">u</span><br><span class="line"></span><br><span class="line"><span class="comment">## 保存当前文件（ : 是英文的冒号）</span></span><br><span class="line"></span><br><span class="line">:w</span><br><span class="line"></span><br><span class="line"><span class="comment">## 另存当前文件内容为 log2.txt</span></span><br><span class="line"></span><br><span class="line">:w log2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">## 退出当前文件</span></span><br><span class="line"></span><br><span class="line">:q</span><br><span class="line"></span><br><span class="line"><span class="comment">## 不保存 并强制退出当前文件</span></span><br><span class="line"></span><br><span class="line">:q!</span><br><span class="line"></span><br><span class="line"><span class="comment">## 保存并退出当前文件</span></span><br><span class="line"></span><br><span class="line">:wq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 vi --help / vim --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h2 id="nano-介绍"><a href="#nano-介绍" class="headerlink" title="nano 介绍"></a>nano 介绍</h2><p>nano 我挺少用的，一些系统也默认安装了这个 文本编辑器，在一些地方比 vim 好用，不过我已经习惯了 vim。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开当前目录下的 log.txt 文件，如果没有那么会新建 log.txt 文件</span></span><br><span class="line"></span><br><span class="line">nano log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入后直接就可以输入修改文本内容了，修改后我们可以使用这个 按键保存内容</span></span><br><span class="line"></span><br><span class="line">Ctrl+O</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不需要编辑了，那么可以用这个 按键退出当前文件</span></span><br><span class="line"></span><br><span class="line">Ctrl+X</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你在退出前已经修改但没有保存，那么会提醒你是否保存，如果保存就输入 y ，不保存输入 n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后就会让你输入要保存的文件名（默认原文件名，所以直接按 Enter 回车即可，除非你要另存为其他文件名）</span></span><br><span class="line"></span><br><span class="line">Enter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 nano --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h1 id="解压缩-操作"><a href="#解压缩-操作" class="headerlink" title="解压缩 操作"></a>解压缩 操作</h1><p>在 Linux 中经常会下载到压缩文件，而压缩文件的格式有很多，比如 zip、rar、gz、xz、tar.gz、tar.xz 等。<br>比较常见的就是各种 .tar、.tar.xz、.tar.gz、.tar.bz、.tar.bz2、.tar.Z 后缀压缩包，这几个的解压缩命令基本一样，说明一下参数的意义。<br>tar 本身只是一个打包的作用，而 .tar 后面的 .zx &#x2F; .gz &#x2F; .bz 等等才是压缩格式，也就是比如 log.tar.gz 压缩包，就是先用 .tar 把指定文件&#x2F;文件夹打包到一起，然后再用 gz 来压缩打包后的 .tar 为 .tar.gz 。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-x 是从压缩文件提取(解压)文件出来，所以在解压命令中都有这个参数。</span><br><span class="line">-c ：创建一个新的压缩包文件，所以在压缩命令中都有这个参数。</span><br><span class="line">-f ：指定要解压的压缩包文件或要压缩的文件/文件夹，所以这个参数必须放在解压缩命令参数的最后，然后后面跟着要解压到压缩包文件或要压缩的文件/文件夹。</span><br><span class="line">-j ：解压缩 bz / bz2 格式的参数</span><br><span class="line">-J ：解压缩 xz / lzip 格式的参数</span><br><span class="line">-z ：解压缩 gz / tgz 格式的参数</span><br><span class="line">-Z ：解压缩 Z 格式的参数</span><br><span class="line">-v ：详细列出解压缩过程中处理的文件</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 tar --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h2 id="tar-gz-zip-等-解压-压缩包-示例"><a href="#tar-gz-zip-等-解压-压缩包-示例" class="headerlink" title="tar gz zip 等 解压 压缩包 示例"></a>tar gz zip 等 解压 压缩包 示例</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压后缀为 .tar 的压缩包</span></span><br><span class="line"></span><br><span class="line">tar -xf log.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压后缀为 .tar.xz 的压缩包</span></span><br><span class="line"></span><br><span class="line">tar -xJf log.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压后缀为 .tar.gz 的压缩包，有两个方法</span></span><br><span class="line"></span><br><span class="line">tar -xzf log.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压后缀为 .gz 的压缩包，有两个方法，如提示命令不存在，请安装 yum install gzip -y / apt-get install gzip -y</span></span><br><span class="line"></span><br><span class="line">gzip -d log.gz</span><br><span class="line">gunzip log.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压后缀为 .bz / .bz2 / tar.bz2 的压缩包，有两个方法</span></span><br><span class="line"></span><br><span class="line">bzip2 -d log.bz</span><br><span class="line">bunzip2 log.bz</span><br><span class="line">tar -jxf log.tar.bz</span><br><span class="line"></span><br><span class="line">bzip2 -d log.bz2</span><br><span class="line">bunzip2 log.bz2</span><br><span class="line">tar -jxf log.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压后缀为 .Z / tar.Z 的压缩包，有两个方法</span></span><br><span class="line"></span><br><span class="line">uncompress log.Z log.txt</span><br><span class="line">uncompress log.Z <span class="built_in">log</span></span><br><span class="line">tar xZf log.tar.Z log.txt</span><br><span class="line">tar xZf log.tar.Z <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压后缀为 .rar 的压缩包，如提示命令不存在，请安装 yum install unrar -y / apt-get install unrar -y ，注意 rar 和 unrar 是分开的</span></span><br><span class="line"></span><br><span class="line">unrar x log.rar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压后缀为 .zip 的压缩包，如提示命令不存在，请安装 yum install unzip -y / apt-get install unzip -y，注意 zip 和 unzip 是分开的</span></span><br><span class="line"></span><br><span class="line">unzip log.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 tar --help / gzip --help / unrar --help / unzip --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h2 id="压缩-文件-x2F-文件夹-示例"><a href="#压缩-文件-x2F-文件夹-示例" class="headerlink" title="压缩 文件&#x2F;文件夹 示例"></a>压缩 文件&#x2F;文件夹 示例</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分别压缩当前目录下的 log.txt 文件 / log 文件夹为 log.tar 压缩包</span></span><br><span class="line"></span><br><span class="line">tar -cf log.tar log.txt</span><br><span class="line">tar -cf log.tar <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要压缩多个文件和文件夹，那么只需要在后面一直加下去即可</span></span><br><span class="line"></span><br><span class="line">tar -cf log.tar log.txt doub.txt <span class="built_in">log</span> bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别压缩当前目录下的 log.txt 文件 / log 文件夹为 log.tar.xz 压缩包，以下的其他后缀压缩命令都是一样</span></span><br><span class="line"></span><br><span class="line">tar -cJf log.tar.xz log.txt</span><br><span class="line">tar -cJf log.tar.xz <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别压缩当前目录下的 log.txt 文件 / log 文件夹为 log.tar.gz 压缩包</span></span><br><span class="line"></span><br><span class="line">tar -czf log.tar.gz log.txt</span><br><span class="line">tar -czf log.tar.gz <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别压缩当前目录下的 log.txt 文件 / log 文件夹为 log.gz 压缩包</span></span><br><span class="line"></span><br><span class="line">gzip log.gz log.txt</span><br><span class="line">gzip log.gz <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别压缩当前目录下的 log.txt 文件 / log 文件夹为 log.tar.bz 压缩包</span></span><br><span class="line"></span><br><span class="line">暂时没查到</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别压缩当前目录下的 log.txt 文件 / log 文件夹为 log.bz / log.tar.bz / log.bz2 / log.tar.bz2 压缩包</span></span><br><span class="line"></span><br><span class="line">bzip2 -z log.txt</span><br><span class="line">bzip2 -z <span class="built_in">log</span></span><br><span class="line">tar cjf log.tar.bz2 log.txt</span><br><span class="line">tar cjf log.tar.bz2 <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别压缩当前目录下的 log.txt 文件 / log 文件夹为 log.Z / log.tar.Z 压缩包</span></span><br><span class="line"></span><br><span class="line">compress log.txt</span><br><span class="line">compress <span class="built_in">log</span></span><br><span class="line">tar cZf log.tar.Z log.txt</span><br><span class="line">tar cZf log.tar.Z <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别压缩当前目录下的 log.txt 文件 / log 文件夹为 log.rar 压缩包，如提示命令不存在，请安装 yum install rar -y / apt-get install rar -y ，注意 rar 和 unrar 是分开的</span></span><br><span class="line"></span><br><span class="line">unrar a log.rar log.txt</span><br><span class="line">unrar a log.rar <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别压缩当前目录下的 log.txt 文件 / log 文件夹为 log.zip 压缩包，如提示命令不存在，请安装 yum install zip -y / apt-get install zip -y ，注意 zip 和 unzip 是分开的</span></span><br><span class="line"></span><br><span class="line">zip log.zip log.txt</span><br><span class="line">zip log.zip <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 tar --help / gzip --help / rar --help / zip --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h1 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h1><h2 id="wget-下载工具"><a href="#wget-下载工具" class="headerlink" title="wget 下载工具"></a>wget 下载工具</h2><p>wget 是 Linux 系统最常用的工具之一，命令行方式的多功能下载工具，支持 HTTP，HTTPS 和 FTP 协议。</p>
<h3 id="参数介绍-5"><a href="#参数介绍-5" class="headerlink" title="参数介绍"></a>参数介绍</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只介绍最常用的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果提示命令不存在，那么使用 yum install wget -y / apt-get install wget -y 来安装（有一些非常精简的系统可能会没装）</span></span><br><span class="line"></span><br><span class="line">-b ：启动后，后台下载</span><br><span class="line">-q ：安静模式（不输出任何信息）</span><br><span class="line">-c ：断点续传下载文件</span><br><span class="line">-O ：指定下载后的文件名（可使用绝对路径目录+文件名）</span><br><span class="line">-P ：指定下载后的文件目录（-P 只能指定下载目录，并不能指定文件名）</span><br><span class="line">-t ：设置重试次数（0 代表无限）</span><br><span class="line">-T ：设置超时时间（单位：秒）</span><br><span class="line">-N ：只获取比本地新的文件（新的覆盖旧的）</span><br><span class="line">-4：仅连接至 IPv4 地址</span><br><span class="line">-6：仅连接至 IPv6 地址</span><br><span class="line">--limit-rate=xxxk :限制下载速度（k 代表 KB/S）</span><br><span class="line">--post-data ：通过 POST 方式发送数据</span><br><span class="line">--no-check-certificate ：不验证服务器的 SSL 证书</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 wget --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例-6"><a href="#使用示例-6" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载一个文件到当前目录</span></span><br><span class="line"></span><br><span class="line">wget https://softs.pw/100MB.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件到当前目录并重命名为 200MB.bin</span></span><br><span class="line"></span><br><span class="line">wget -O <span class="string">&quot;200MB.bin&quot;</span> https://softs.pw/100MB.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件到 /root 目录（-P 只能指定下载目录，并不能指定文件名）</span></span><br><span class="line"></span><br><span class="line">wget -P <span class="string">&quot;/root&quot;</span> https://softs.pw/100MB.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件到 /root/test 目录并重命名为 200MB.bin</span></span><br><span class="line"></span><br><span class="line">wget -O <span class="string">&quot;/root/test/200MB.bin&quot;</span> https://softs.pw/100MB.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件完成之前 wget 进程结束了，那么可以使用断点续传重新下载中断的文件（前提是下载服务器支持断点续传）</span></span><br><span class="line"></span><br><span class="line">wget -c https://softs.pw/100MB.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过后台下载文件到 /root/test 目录并重命名为 200MB.bin</span></span><br><span class="line"></span><br><span class="line">wget -b -O <span class="string">&quot;/root/test/200MB.bin&quot;</span> https://softs.pw/100MB.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Continuing in background, pid 2333.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output will be written to `wget-log&#x27;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台下后，你可以使用以下命令来查看下载进度：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tail</span> -f wget-log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有时候一些 Linux 系统中的 SSL 证书不完整，会导致下载一些 HTTPS 网站文件的时候会验证 SSL 证书失败，可以这样做</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不验证服务器 SSL 证书，下载文件到当前目录并重命名为 200MB.bin</span></span><br><span class="line"></span><br><span class="line">wget --no-check-certificate -O <span class="string">&quot;200MB.bin&quot;</span> https://softs.pw/100MB.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 wget 发送 POST 请求数据</span></span><br><span class="line"></span><br><span class="line">wget --post-data <span class="string">&quot;user=test&amp;passwd=23333&quot;</span> https://xxx.xx/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件到当前目录 并仅通过 IPv4 连接 只获取比本地新的文件，限速 200KB/S</span></span><br><span class="line"></span><br><span class="line">wget --limit-rate=200k-N -4 https://softs.pw/100MB.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件到当前目录 并重试次数为 1，超时时间为 2 秒</span></span><br><span class="line"></span><br><span class="line">wget -t1 -T2 https://softs.pw/100MB.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 wget 来获取服务器的外网 IP（-qO- 代表运行完会输出下载的信息，并不会保存到本地文件）</span></span><br><span class="line"></span><br><span class="line">wget -qO- ipinfo.io/ip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 wget --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h2 id="curl-下载工具"><a href="#curl-下载工具" class="headerlink" title="curl 下载工具"></a>curl 下载工具</h2><p>curl 是 Linux 系统一个利用 URL 规则在命令行下工作的文件传输工具，是一款很强大的 HTTP 命令行工具。它支持文件的上传和下载，是综合传输工具，但习惯称 curl 为下载工具。</p>
<h3 id="参数介绍-6"><a href="#参数介绍-6" class="headerlink" title="参数介绍"></a>参数介绍</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只介绍最常用的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果提示命令不存在，那么使用 yum install curl -y / apt-get install curl -y 来安装（有一些非常精简的系统可能会没装）</span></span><br><span class="line"></span><br><span class="line">-s ：安静模式（不会输出任何信息）</span><br><span class="line">-C ：断点续传下载文件</span><br><span class="line">-o ：输出写入到文件中</span><br><span class="line">-O ：输出写入到文件，文件名为远程文件的名称</span><br><span class="line">-k ：不验证服务器 SSL 证书</span><br><span class="line">-T ：上传文件</span><br><span class="line">-4：仅连接至 IPv4 地址</span><br><span class="line">-6：仅连接至 IPv6 地址</span><br><span class="line">-m ：设置传输总时间（单位：秒）</span><br><span class="line">--retry：设置重试次数</span><br><span class="line">--data ：通过 POST 方式发送数据</span><br><span class="line">--limit-rate xxxK ：限制下载速度（K 代表 KB/S）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 curl --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例-7"><a href="#使用示例-7" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取当前服务器的外网 IP</span></span><br><span class="line"></span><br><span class="line">curl ipinfo.io/ip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取一个文件保存到当前目录中</span></span><br><span class="line"></span><br><span class="line">wget -O https://softs.pw/Bash/ssr.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取一个文件保存到 /root/test 目录中 并修改文件名为 233.sh</span></span><br><span class="line"></span><br><span class="line">curl -o <span class="string">&quot;/root/test/233.sh&quot;</span> https://softs.pw/Bash/ssr.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件完成之前 curl 进程结束了，那么可以使用断点续传重新下载中断的文件（前提是下载服务器支持断点续传）</span></span><br><span class="line"></span><br><span class="line">curl -C -O https://softs.pw/100MB.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有时候一些 Linux 系统中的 SSL 证书不完整，会导致访问/下载一些 HTTPS 网站/文件的时候会验证 SSL 证书失败，可以这样做</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不验证服务器 SSL 证书，下载文件到当前目录并重命名为 233.sh</span></span><br><span class="line"></span><br><span class="line">curl -k -o <span class="string">&quot;233.sh&quot;</span> https://softs.pw/Bash/ssr.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 curl 发送 GET 请求数据</span></span><br><span class="line"></span><br><span class="line">curl https://xxx.xx/?user=<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 curl 发送 POST 请求数据</span></span><br><span class="line"></span><br><span class="line">curl --data <span class="string">&quot;user=test&amp;passwd=23333&quot;</span> https://xxx.xx/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件到当前目录 并仅通过 IPv4 连接，限速 200KB/S</span></span><br><span class="line"></span><br><span class="line">curl --limit-rate 200K-4 https://softs.pw/100MB.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件到当前目录 并重试次数为 1，超时时间为 2 秒</span></span><br><span class="line"></span><br><span class="line">curl --retry1-m 10 https://softs.pw/100MB.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 curl --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h2 id="netstat-查看链接和端口监听等信息"><a href="#netstat-查看链接和端口监听等信息" class="headerlink" title="netstat 查看链接和端口监听等信息"></a>netstat 查看链接和端口监听等信息</h2><h3 id="参数介绍-7"><a href="#参数介绍-7" class="headerlink" title="参数介绍"></a>参数介绍</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-n ：不显示别名（主机名/域名以数字或 IP 显示）</span><br><span class="line">-e ：显示其他/更多信息</span><br><span class="line">-p ：显示进程 PID/进程名</span><br><span class="line">-c ：持续输出（设置后会每隔 1 秒输出一次，Ctrl+C 终止）</span><br><span class="line">-l ：显示正在监听的套接字</span><br><span class="line">-a ：显示全部信息</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这些就不很常用了。</span></span><br><span class="line"></span><br><span class="line">-r ：显示路由表</span><br><span class="line">-i ：显示网络接口（网卡）</span><br><span class="line">-g ：显示多播组信息</span><br><span class="line">-s ：显示网络统计</span><br><span class="line">-M ：显示伪装连接</span><br><span class="line">-v ：显示正在进行的工作</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 netstat --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例-8"><a href="#使用示例-8" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前服务器的所有连接信息</span></span><br><span class="line"></span><br><span class="line">netstat -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前服务器的所有 TCP 连接信息</span></span><br><span class="line"></span><br><span class="line">netstat -at</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前服务器的所有 UDP 连接信息</span></span><br><span class="line"></span><br><span class="line">netstat -au</span><br></pre></td></tr></table></figure>

<p>一般来说经常使用这个命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前服务器的所有正在监听 TCP 端口的信息，并且 显示进程 PID 和进程名，但不显示别名（域名以 IP 显示），这个命令算是最常用的了。</span></span><br><span class="line"></span><br><span class="line">netstat -lntp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例</span></span><br><span class="line"></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name</span><br><span class="line">tcp 0 0 0.0.0.0:80 0.0.0.0:_ LISTEN 14233/nginx.conf</span><br><span class="line">tcp 0 0 0.0.0.0:22 0.0.0.0:_ LISTEN 1555/sshd</span><br><span class="line">tcp 0 0 0.0.0.0:443 0.0.0.0:_ LISTEN 14233/nginx.conf</span><br><span class="line">tcp6 0 0 :::22 :::_ LISTEN 1555/sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示监听 80 端口的进程 PID 和进程名，grep 是匹配并显示 符合关键词的行。</span></span><br><span class="line"></span><br><span class="line">netstat -lntp|grep <span class="string">&quot;:80&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例</span></span><br><span class="line"></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name</span><br><span class="line">tcp 0 0 0.0.0.0:80 0.0.0.0:\* LISTEN 14233/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 ssh 的监听情况，grep 是匹配并显示 符合关键词的行。</span></span><br><span class="line"></span><br><span class="line">netstat -lntp|grep <span class="string">&quot;ssh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例</span></span><br><span class="line"></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name</span><br><span class="line">tcp 0 0 0.0.0.0:22 0.0.0.0:\* LISTEN 1555/sshd</span><br></pre></td></tr></table></figure>

<p>表头解释</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Proto：连接协议（tcp/udp 是 IPv4，tcp6/udp6 是 IPv6）</span><br><span class="line">Recv-Q ：接收队列（基本都是 0，如果不是代表堆积）</span><br><span class="line">Send-Q ：发送队列（基本都是 0，如果不是代表堆积）</span><br><span class="line">LocalAddress：本地地址和端口</span><br><span class="line">ForeignAddress：对外地址和端口</span><br><span class="line">State：连接状态</span><br><span class="line">PID/Program name ：进程 PID/进程名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔 1 秒显示一次当前服务器的所有连接信息</span></span><br><span class="line"></span><br><span class="line">netstat -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔 1 秒显示一次当前服务器的所有 TCP 连接信息</span></span><br><span class="line"></span><br><span class="line">netstat -ct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔 1 秒显示一次当前服务器的所有 UDP 连接信息</span></span><br><span class="line"></span><br><span class="line">netstat -cu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前服务器的路由表</span></span><br><span class="line"></span><br><span class="line">netstat -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前服务器的网络接口信息（网卡）</span></span><br><span class="line"></span><br><span class="line">netstat -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前服务器的网络统计信息</span></span><br><span class="line"></span><br><span class="line">netstat -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 netstat --help 来查看。</span></span><br></pre></td></tr></table></figure>

<p>在使用 netstat 命令中，会显示一些连接状态，下面是各状态的意思：<br>LISTEN</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监听来自远程连接的 TCP 端口连接请求</span></span><br><span class="line"></span><br><span class="line">SYN-SENT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在发送连接请求后，等待匹配的连接请求</span></span><br><span class="line"></span><br><span class="line">SYN-RECEIVED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在收到和发送一个连接请求后，等待对方对连接请求的确认</span></span><br><span class="line"></span><br><span class="line">ESTABLISHED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代表一个打开的连接</span></span><br><span class="line"></span><br><span class="line">FIN-WAIT-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待远程 TCP 连接中断请求，或先前的连接中断请求的确认</span></span><br><span class="line"></span><br><span class="line">FIN-WAIT-2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从远程 TCP 等待连接中断请求</span></span><br><span class="line"></span><br><span class="line">CLOSE-WAIT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待从本地用户发来的连接中断请求</span></span><br><span class="line"></span><br><span class="line">CLOSING</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待远程 TCP 对连接中断的确认</span></span><br><span class="line"></span><br><span class="line">LAST-ACK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待原来的发向远程 TCP 的连接中断请求的确认</span></span><br><span class="line"></span><br><span class="line">TIME-WAIT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待足够的时间，以确保远程 TCP 接收到连接中断请求的确认</span></span><br><span class="line"></span><br><span class="line">CLOSED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有任何连接状态（或者关闭了连接）</span></span><br></pre></td></tr></table></figure>

<h1 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h1><h2 id="ps-查看进程信息"><a href="#ps-查看进程信息" class="headerlink" title="ps 查看进程信息"></a>ps 查看进程信息</h2><h3 id="参数介绍-8"><a href="#参数介绍-8" class="headerlink" title="参数介绍"></a>参数介绍</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">待写...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 man ps 来查看。</span></span><br><span class="line"></span><br><span class="line">使用示例：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前进程信息</span></span><br><span class="line"></span><br><span class="line">ps -ef</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 ssh 进程（ grep -v grep 表示排除关键词 grep，因为使用 grep 匹配 ssh，也会把 grep 自己的进程匹配进去的）</span></span><br><span class="line"></span><br><span class="line">ps -ef|grep -v grep|grep ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例</span></span><br><span class="line"></span><br><span class="line">UID PID PPID C STIME TTY TIME CMD <span class="comment">#注意使用上面命令的话是不会显示表头这一行的，我只是为了更好理解加上的</span></span><br><span class="line">root 17381001/27?00:08:56/usr/sbin/sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 待写...</span></span><br></pre></td></tr></table></figure>

<p>表头解释：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">UID ：启动进程的用户</span><br><span class="line">PID ：进程标识符（进程 1 代表 init 是整个系统的父进程）</span><br><span class="line">PPID ：父进程标识符（进程 1 代表 init 是整个系统的父进程）</span><br><span class="line">C ：CPU 占用率%</span><br><span class="line">STIME ：启动进程的日期</span><br><span class="line">TTY ：终端号</span><br><span class="line">TIME ：进程运行时间（非休眠状态）</span><br><span class="line">CMD ：启动进程的命令（或进程名/进程程序所在目录）</span><br></pre></td></tr></table></figure>

<h2 id="kill-结束进程"><a href="#kill-结束进程" class="headerlink" title="kill 结束进程"></a>kill 结束进程</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当我们想要结束一个进程的时候，我们可以用 kill 命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PID 是每个进程的一个唯一标识符，可以使用上面的 ps 命令来查看你要结束进程的 PID。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设我们要结束 Nginx 的进程，那么这样做（ grep -v grep 表示排除关键词 grep，因为使用 grep 匹配 ssh，也会把 grep 自己的进程匹配进去的）：</span></span><br><span class="line"></span><br><span class="line">ps -ef|grep -v grep|grep <span class="string">&quot;nginx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例</span></span><br><span class="line"></span><br><span class="line">UID PID PPID C STIME TTY TIME CMD <span class="comment">#注意使用上面命令的话是不会显示表头这一行的，我只是为了更好理解加上的</span></span><br><span class="line">root 23561004/03?00:03:12 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后我们可以看到第二列的 PID 进程标识符，然后我们 kill 即可。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -92356</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中断进程 -2 相当于 程序运行在前台，然后输入 Ctrl+C 的效果，但是进程有权利忽略，所以不一定能结束进程</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -2 PID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制结束进程 -9 ，注意：强制结束某个进程后，可能会造成进程数据丢失等问题！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure>

<h2 id="free-查看内存使用信息"><a href="#free-查看内存使用信息" class="headerlink" title="free 查看内存使用信息"></a>free 查看内存使用信息</h2><h3 id="参数介绍-9"><a href="#参数介绍-9" class="headerlink" title="参数介绍"></a>参数介绍</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-b ：以字节(bytes/B)为单位显示</span><br><span class="line">-k ：以 KB 为单位显示</span><br><span class="line">-m ：以 MB 为单位显示</span><br><span class="line">-g ：以 GB 为单位显示</span><br><span class="line">--tera ：以 TB 为单位显示</span><br><span class="line">-h ：以人类易读的方式输出</span><br><span class="line">--si ：以 1000 为单位转换，而不是 1024（1MB=1*1024KB 改成 1MB=1*1000KB）</span><br><span class="line">-t ：显示内存总数行</span><br><span class="line">-s 时间：每隔 X 秒输出一次（重复输出监视内存，使用 Ctrl+C 终止）</span><br><span class="line">-c 次数：每隔 1 秒输出 X 次</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 free --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例-9"><a href="#使用示例-9" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前系统内存（默认 free = free -k，单位为 KB）</span></span><br><span class="line"></span><br><span class="line">free</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例</span></span><br><span class="line"></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line"></span><br><span class="line">Mem: 250872 237752 13120 0 34620 70520</span><br><span class="line">-/+ buffers/cache: 132612 118260</span><br><span class="line">Swap: 643064 1744 641320</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以单位 B/KB/MB/GB/TG 显示当前系统内存</span></span><br><span class="line"></span><br><span class="line">free -b / free -k / free -m / free -g / free --tera</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以人类易读的方式 显示当前系统内存</span></span><br><span class="line"></span><br><span class="line">free -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例</span></span><br><span class="line"></span><br><span class="line">            total       used       free     shared    buffers     cached</span><br><span class="line">Mem:        244M        232M        12M       0B        33M         68M</span><br><span class="line">-/+ buffers/cache:      129M        115M</span><br><span class="line">Swap:       627M        1.7M        626M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 1000 为单位转换并使用 MB 为单位 显示当前系统内存（1MB=1*1024KB 改成 1MB=1*1000KB）</span></span><br><span class="line"></span><br><span class="line">free -m --si</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔 3 秒并使用 MB 为单位 显示一次当前系统内存</span></span><br><span class="line"></span><br><span class="line">free -ms 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔 1 秒并使用 MB 为单位 显示 5 次当前系统内存</span></span><br><span class="line"></span><br><span class="line">free -mc 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔 2 秒并使用 MB 为单位 总共显示 6 次当前系统内存</span></span><br><span class="line"></span><br><span class="line">free -m -c 6-s 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 free --help 来查看。</span></span><br></pre></td></tr></table></figure>

<p>表头解释：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 说明示例</span></span><br><span class="line"></span><br><span class="line">             total       used         free     shared    buffers     cached</span><br><span class="line">Mem:          244M        232M        12M       0B        33M         69M</span><br><span class="line">-/+ buffers/cache:        129M        115M</span><br><span class="line">Swap:         627M        1.7M        626M</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mem 行，表示物理内存统计</span></span><br><span class="line"></span><br><span class="line">total :系统 总物理内存</span><br><span class="line">used :系统 已分配物理内存（但非全部都在使用，包含 buffers 好 cached）</span><br><span class="line">free :系统 未分配物理内存</span><br><span class="line">shared :系统 共享内存，一般都是 0</span><br><span class="line">buffers :系统 分配但未使用的 buffers 数量</span><br><span class="line">cached :系统 分配但未使用的 cached 数量</span><br><span class="line"></span><br><span class="line"><span class="comment"># -/+ buffers/cache 行，表示物理内存的缓存统计</span></span><br><span class="line"></span><br><span class="line">used :系统 实际使用的内存</span><br><span class="line"></span><br><span class="line"><span class="comment"># user= Mem 行 used-buffers-cached（232-33-69=130，因单位转换问题 所以会有一点差距）</span></span><br><span class="line"></span><br><span class="line">free :系统 实际可用的内存</span><br><span class="line"></span><br><span class="line"><span class="comment"># free= Mem 行 free+buffers+cached（12+33+69=114，因单位转换问题 所以会有一点差距）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以我们看系统的真实 使用/剩余内存 只需要看这一行即可！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Swap 行，表示硬盘的交换分区（虚拟内存）统计</span></span><br><span class="line"></span><br><span class="line">total :系统 总虚拟内存</span><br><span class="line">used :系统 已分配虚拟内存</span><br><span class="line">free :系统 未分配虚拟内存</span><br><span class="line"></span><br><span class="line"><span class="comment"># KVM 虚拟化的 VPS，可以用这个教程手动添加 SWAP 虚拟内存：https://doub.io/linux-jc7/</span></span><br></pre></td></tr></table></figure>

<h2 id="date-查看-x2F-设置-系统时间"><a href="#date-查看-x2F-设置-系统时间" class="headerlink" title="date 查看&#x2F;设置 系统时间"></a>date 查看&#x2F;设置 系统时间</h2><h3 id="参数介绍-10"><a href="#参数介绍-10" class="headerlink" title="参数介绍"></a>参数介绍</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-d ：以指定的时间格式显示时间</span><br><span class="line">-f ：显示 DATE FILE 文件中的每行时间（我也不懂）</span><br><span class="line">-r ：显示文件/文件夹最后修改时间</span><br><span class="line">-s ：设置系统时间</span><br><span class="line">-u ：显示 UTC 时间</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间格式</span></span><br><span class="line"></span><br><span class="line">%%-显示字符%</span><br><span class="line">%a -星期几的缩写(Sun..Sat)</span><br><span class="line">%A -星期几的完整名称（Sunday...Saturday）</span><br><span class="line">%b -月份的缩写(Jan..Dec)</span><br><span class="line">%B -月份的完整名称(January..December)</span><br><span class="line">%c -日期与时间。只输入 <span class="built_in">date</span> 指令也会显示同样的结果</span><br><span class="line">%C -世纪(年份除 100 后去整)[00-99]</span><br><span class="line">%d -日期(以 01-31 来表示)。</span><br><span class="line">%D -日期(含年月日)。</span><br><span class="line">%e -一个月的第几天(1..31)</span><br><span class="line">%F -日期，同%Y-%m-%d</span><br><span class="line">%g -年份(yy)</span><br><span class="line">%G -年份(yyyy)</span><br><span class="line">%h -同%b</span><br><span class="line">%H -小时(00..23)</span><br><span class="line">%I -小时(01..12)</span><br><span class="line">%j -一年的第几天(001..366)</span><br><span class="line">%k -小时(0..23)</span><br><span class="line">%l -小时(1..12)</span><br><span class="line">%m -月份(01..12)</span><br><span class="line">%M -分钟(00..59)</span><br><span class="line">%n -换行</span><br><span class="line">%N -纳秒(000000000..999999999)</span><br><span class="line">%p - AM or PM</span><br><span class="line">%P - am or pm</span><br><span class="line">%r -12 小时制时间(hh:mm:ss [AP]M)</span><br><span class="line">%R -24 小时制时间(hh:mm)</span><br><span class="line">%s -从 00:00:001970-01-01 UTC 开始的秒数</span><br><span class="line">%S -秒(00..60)</span><br><span class="line">%t -制表符</span><br><span class="line">%T -24 小时制时间(hh:mm:ss)</span><br><span class="line">%u -一周的第几天(1..7);1 表示星期一</span><br><span class="line">%U -一年的第几周，周日为每周的第一天(00..53)</span><br><span class="line">%V -一年的第几周，周一为每周的第一天(01..53)</span><br><span class="line">%w -一周的第几天(0..6);0 代表周日</span><br><span class="line">%W -一年的第几周，周一为每周的第一天(00..53)</span><br><span class="line">%x -日期(mm/dd/yy)</span><br><span class="line">%X -时间(%H:%M:%S)</span><br><span class="line">%y -年份(00..99)</span><br><span class="line">%Y -年份(1970…)</span><br><span class="line">%z - RFC-2822 风格数字格式时区(-0500)</span><br><span class="line">%Z -时区(e.g., EDT),无法确定时区则为空</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 date --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例-10"><a href="#使用示例-10" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示 当前系统时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：Wed Apr 5 12:38:44 CST 2017</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前系统的 UTC 时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> -u</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：Wed Apr 5 04:30:06 UTC 2017</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 log.txt 文件的最后修改时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> -r log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 当前日期的年份</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> +%Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：2017</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 当前日期的月份</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> +%m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 各种格式类型的日期</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> +%D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：04/05/17</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> +%Y-%m-%d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：2017-04-05</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> +%m/%d/%y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：04/05/17</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> +%m/%d/%Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：04/05/2017</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 Unix 时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> +%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：1491367399</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示一个完整的时间（年、月、日、小时、分钟、秒钟、周几 时区）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> <span class="string">&quot;+%Y-%m-%d %H:%I:%S %u %Z&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：2017-04-05 12:12:15 3 CST</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 系统时间（年、月、日）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;2017-04-05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 系统时间（小时、分钟、秒钟）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;10:29:05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 系统时间（年、月、日、小时、分钟、秒钟）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;2017-04-05 10:29:05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 date --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h2 id="chmod-修改-文件-x2F-文件夹-权限"><a href="#chmod-修改-文件-x2F-文件夹-权限" class="headerlink" title="chmod 修改 文件&#x2F;文件夹 权限"></a>chmod 修改 文件&#x2F;文件夹 权限</h2><h3 id="参数介绍-11"><a href="#参数介绍-11" class="headerlink" title="参数介绍"></a>参数介绍</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-c :只输出被改变权限的文件信息</span><br><span class="line">-f :当 <span class="built_in">chmod</span> 不能改变文件模式时，不通知文件的用户</span><br><span class="line">-R :可递归遍历子目录，把修改应到目录下所有文件和子目录</span><br><span class="line">-v :无论修改是否成功，输出每个文件的信息</span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作符号：</span></span><br><span class="line"></span><br><span class="line">+:添加某个权限。</span><br><span class="line">-:取消某个权限。</span><br><span class="line">=:赋予给定权限并取消其他所有权限（如果有的话）。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权限设置字母：</span></span><br><span class="line"></span><br><span class="line">r :可读</span><br><span class="line">w :可写</span><br><span class="line">x :可执行</span><br><span class="line">X :只有目标文件对某些用户是可执行的或该目标文件是目录时才追加 x 属性</span><br><span class="line">s :在文件执行时把进程的属主或组 ID 置为该文件的文件属主。方式“u ＋ s”设置文件的用户 ID 位，“g ＋ s”设置组 ID 位</span><br><span class="line">t :保存程序的文本到交换设备上</span><br><span class="line">u :当前用户的权限</span><br><span class="line">g :当前用户同组的权限</span><br><span class="line">o :其他用户的权限</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权限设定数字：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数字表示的属性含义：</span></span><br><span class="line"></span><br><span class="line">0：表示没有权限</span><br><span class="line">1：表示可执行权限</span><br><span class="line">2：表示可写权限</span><br><span class="line">4：表示可读权限</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后将其相加，所以数字属性的格式应为 3 个从 0 到 7 的八进制数，其顺序是（u）（g）（o）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想让某个文件的属主有“读/写”二种权限，需要把 4（可读）+2（可写）＝ 6（读/写）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 chmod --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例-11"><a href="#使用示例-11" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当需要运行 可执行的脚本或者程序（比如 Go 语言编写的软件）的时候，需要赋予执行权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x ssr.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋予 log.txt 文件可读权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 444 log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋予 /ver/log 文件夹 可读、可写权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 666 log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋予 /home/www 文件夹 可读、可写、可执行权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 777 log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋予 /home/www 文件夹极其所有子目录和文件 可读、可写、可执行权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> -R 777 log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 chmod --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h2 id="uname-获取操作系统信息"><a href="#uname-获取操作系统信息" class="headerlink" title="uname 获取操作系统信息"></a>uname 获取操作系统信息</h2><h3 id="参数介绍-12"><a href="#参数介绍-12" class="headerlink" title="参数介绍"></a>参数介绍</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-a：显示全部信息</span><br><span class="line">-m：显示系统位数</span><br><span class="line">-n：显示主机名称</span><br><span class="line">-r：显示操作系统的发行编号</span><br><span class="line">-s：显示操作系统的名称</span><br><span class="line">-v：显示操作系统的版本</span><br><span class="line">-p：输出处理器类型或<span class="string">&quot;unknown&quot;</span></span><br><span class="line">-i：输出硬件平台或<span class="string">&quot;unknown&quot;</span></span><br><span class="line">-o：输出操作系统名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多的命令可以用 uname --help 来查看。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例-12"><a href="#使用示例-12" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> <span class="comment">#在使用 uname 的时候，相当于是使用 uname -s</span></span><br><span class="line">Linux</span><br><span class="line">$ <span class="built_in">uname</span> -a</span><br><span class="line">Linux doub.io 2.6.32-042stab120.6<span class="comment">#1 SMP Thu Oct 27 16:59:03 MSK 2016 i686 GNU/Linux</span></span><br><span class="line">$ <span class="built_in">uname</span> -m <span class="comment">#输出一般是 64 位: x86_64 / 32 位: i386 或分支 i686</span></span><br><span class="line">i686</span><br><span class="line">$ <span class="built_in">uname</span> -n</span><br><span class="line">doub.io</span><br><span class="line">$ <span class="built_in">uname</span> -r</span><br><span class="line">2.6.32-042stab120.6</span><br><span class="line">$ <span class="built_in">uname</span> -s</span><br><span class="line">Linux</span><br><span class="line">$ <span class="built_in">uname</span> -v</span><br><span class="line"><span class="comment">#1 SMP Thu Oct 27 16:59:03 MSK 2016</span></span><br><span class="line">$ <span class="built_in">uname</span> -p</span><br><span class="line">unknown</span><br><span class="line">$ <span class="built_in">uname</span> -i</span><br><span class="line">unknown</span><br><span class="line">$ <span class="built_in">uname</span> -o</span><br><span class="line">GNU/Linux</span><br></pre></td></tr></table></figure>

<h2 id="cron-定时任务"><a href="#cron-定时任务" class="headerlink" title="cron 定时任务"></a>cron 定时任务</h2><p>crontab 是用来定期执行程序的命令。</p>
<p>当安装完成操作系统之后，默认便会启动此任务调度命令。</p>
<p>cron 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</p>
<p>而 linux 任务调度的工作主要分为以下两类：</p>
<ol>
<li>系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存</li>
<li>个人执行的工作：某个用户定期要做的工作，例如每隔 10 分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置</li>
</ol>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">crontab [ -u user ] file</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">crontab [ -u user ] &#123; -l | -r | -e &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># crontab 是用来让使用者在固定时间或固定间隔执行程序之用，换句话说，也就是类似使用者的时程表。</span></span><br><span class="line">-u : user 是指设定指定 user 的时程表，这个前提是你必须要有其权限(比如说是 root)才能够指定他人的时程表。如果不使用 -u user 的话，就是表示设定自己的时程表。</span><br><span class="line">-e : 执行文字编辑器来设定时程表，内定的文字编辑器是 VI，如果你想用别的文字编辑器，则请先设定 VISUAL 环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe)</span><br><span class="line">-r : 删除目前的时程表</span><br><span class="line">-l : 列出目前的时程表</span><br></pre></td></tr></table></figure>

<h3 id="日程表格式"><a href="#日程表格式" class="headerlink" title="日程表格式"></a>日程表格式</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">f1 f2 f3 f4 f5 program</span><br></pre></td></tr></table></figure>

<ul>
<li>其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。</li>
<li>当 f1 为 _ 时表示每分钟都要执行 program，f2 为 _ 时表示每小时都要执行程序，其馀类推</li>
<li>当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推</li>
<li>当 f1 为 _&#x2F;n 时表示每 n 分钟个时间间隔执行一次，f2 为 _&#x2F;n 表示每 n 小时个时间间隔执行一次，其馀类推</li>
<li>当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推</li>
</ul>
<h3 id="使用示例-13"><a href="#使用示例-13" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每月每天每小时的第 0 分钟执行一次 /bin/ls</span></span><br><span class="line">0 * * * * /bin/ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次 /usr/bin/backup</span></span><br><span class="line">0 6-12/3 * 12 * /usr/bin/backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 周一到周五每天下午 5:00 寄一封信给 alex@domain.name</span></span><br><span class="line">0 17 * * 1-5 mail -s <span class="string">&quot;hi&quot;</span> alex@domain.name &lt; /tmp/maildata</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分....执行 echo &quot;haha&quot;</span></span><br><span class="line">20 0-23/2 * * * <span class="built_in">echo</span> <span class="string">&quot;haha&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 意思是每两个小时重启一次apache</span></span><br><span class="line">0 */2 * * * /sbin/service httpd restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 意思是每天7：50开启ssh服务</span></span><br><span class="line">50 7 * * * /sbin/service sshd start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 意思是每天22：50关闭ssh服务</span></span><br><span class="line">50 22 * * * /sbin/service sshd stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每月1号和15号检查/home 磁盘</span></span><br><span class="line">0 0 1,15 * * fsck /home</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每小时的第一分执行 /home/bruce/backup这个文件</span></span><br><span class="line">1 * * * * /home/bruce/backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每周一至周五3点钟，在目录/home中，查找文件名为*.xxx的文件，并删除4天前的文件。</span></span><br><span class="line">00 03 * * 1-5 find /home <span class="string">&quot;*.xxx&quot;</span> -mtime +4 -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 意思是每月的1、11、21、31日是的6：30执行一次ls命令</span></span><br><span class="line">30 6 */10 * * <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础开发</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mapbox 地图教程</title>
    <url>/2019/07/30/Mapbox-%E5%9C%B0%E5%9B%BE%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Mapbox-地图使用教程"><a href="#Mapbox-地图使用教程" class="headerlink" title="Mapbox 地图使用教程"></a>Mapbox 地图使用教程</h1><h2 id="Mapbox-地图初始化"><a href="#Mapbox-地图初始化" class="headerlink" title="Mapbox 地图初始化"></a>Mapbox 地图初始化</h2><p>本文主要针对于使用本地 GeoJSON 数据创建地图服务, 最终目的是使用本地 WebServer 启动静态地图页面, 如果需要使用 Mapbox 线上资源, 请参考 <a href="https://docs.mapbox.com/mapbox-gl-js/example/simple-map/">Mapbox 线上示例</a></p>
<span id="more"></span>

<p>完整示例 <a href="./mapbox-sample.zip">mapbox-sample.zip</a></p>
<h3 id="创建-HTML-引入资源"><a href="#创建-HTML-引入资源" class="headerlink" title="创建 HTML 引入资源"></a>创建 HTML 引入资源</h3><p>打开编辑器, 创建 <code>index.html</code>, 并生成基础 HTML 结构.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">&quot;initial-scale=1,maximum-scale=1,user-scalable=no&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Mapbox Map<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>引入 <code>mapbox-gl.js</code> 和 <code>mapbox-gl.css</code> 文件, 由于官方的资源库连接速度较慢, 这里使用 <code>BootCDN</code> 的 CDN 服务.</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta</span><br><span class="line">      name=&quot;viewport&quot;</span><br><span class="line">      content=&quot;initial-scale=1,maximum-scale=1,user-scalable=no&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Mapbox Map&lt;/title&gt;</span><br><span class="line"><span class="addition">+    &lt;script src=&quot;https://cdn.bootcss.com/mapbox-gl/1.1.0/mapbox-gl.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="addition">+    &lt;link href=&quot;https://cdn.bootcss.com/mapbox-gl/1.1.0/mapbox-gl.css&quot; rel=&quot;stylesheet&quot; /&gt;</span></span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>由于本文目的在于使用本地 WebServer 启动地图页面, 需要将上述文件下载到本地, 与 index.html 放在相同目录下, 并修改 HTML 文件.</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta</span><br><span class="line">      name=&quot;viewport&quot;</span><br><span class="line">      content=&quot;initial-scale=1,maximum-scale=1,user-scalable=no&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Mapbox Map&lt;/title&gt;</span><br><span class="line"><span class="deletion">-   &lt;script src=&quot;https://cdn.bootcss.com/mapbox-gl/1.1.0/mapbox-gl.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;link href=&quot;https://cdn.bootcss.com/mapbox-gl/1.1.0/mapbox-gl.css&quot; rel=&quot;stylesheet&quot; /&gt;</span></span><br><span class="line"><span class="addition">+   &lt;script src=&quot;./mapbox-gl.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="addition">+   &lt;link href=&quot;./mapbox-gl.css&quot; rel=&quot;stylesheet&quot; /&gt;</span></span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="创建地图容器"><a href="#创建地图容器" class="headerlink" title="创建地图容器"></a>创建地图容器</h3><p>在 HTML 文件 <code>body</code> 标签中间增加</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta</span><br><span class="line">      name=&quot;viewport&quot;</span><br><span class="line">      content=&quot;initial-scale=1,maximum-scale=1,user-scalable=no&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Mapbox Map&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;./mapbox-gl.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link href=&quot;./mapbox-gl.css&quot; rel=&quot;stylesheet&quot; /&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"><span class="addition">+    &lt;div id=&quot;map&quot;&gt;&lt;/div&gt;</span></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>head 标签里增加 map 的样式表</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta</span><br><span class="line">      name=&quot;viewport&quot;</span><br><span class="line">      content=&quot;initial-scale=1,maximum-scale=1,user-scalable=no&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Mapbox Map&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;./mapbox-gl.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link href=&quot;./mapbox-gl.css&quot; rel=&quot;stylesheet&quot; /&gt;</span><br><span class="line"><span class="addition">+    &lt;style&gt;</span></span><br><span class="line"><span class="addition">+      body &#123;</span></span><br><span class="line"><span class="addition">+        margin: 0;</span></span><br><span class="line"><span class="addition">+        padding: 0;</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+      #map &#123;</span></span><br><span class="line"><span class="addition">+        position: absolute;</span></span><br><span class="line"><span class="addition">+        top: 0;</span></span><br><span class="line"><span class="addition">+        bottom: 0;</span></span><br><span class="line"><span class="addition">+        width: 100%;</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+    &lt;/style&gt;</span></span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;map&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="地图初始化"><a href="#地图初始化" class="headerlink" title="地图初始化"></a>地图初始化</h3><p>当前目录创建 <code>index.js</code>, 并在 HTML 文件中引入</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta</span><br><span class="line">      name=&quot;viewport&quot;</span><br><span class="line">      content=&quot;initial-scale=1,maximum-scale=1,user-scalable=no&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Mapbox Map&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;./mapbox-gl.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link href=&quot;./mapbox-gl.css&quot; rel=&quot;stylesheet&quot; /&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      body &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      #map &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        width: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;map&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line"><span class="addition">+  &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>在 <code>index.js</code> 文件中增加地图初始化定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> mapboxgl.<span class="title class_">Map</span>(&#123;</span><br><span class="line">  <span class="attr">container</span>: <span class="string">&quot;map&quot;</span>, <span class="comment">// 使用 id = map 的元素用于地图容器</span></span><br><span class="line">  <span class="attr">style</span>: &#123;</span><br><span class="line">    <span class="comment">// 样式版本, 本地加载使用 version: 8</span></span><br><span class="line">    <span class="attr">version</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="comment">// 无数据源使用</span></span><br><span class="line">    <span class="attr">sources</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 图层定义</span></span><br><span class="line">    <span class="attr">layers</span>: [</span><br><span class="line">      <span class="comment">// 背景层</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&quot;background&quot;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;background&quot;</span>,</span><br><span class="line">        <span class="attr">paint</span>: &#123;</span><br><span class="line">          <span class="comment">// 背景颜色</span></span><br><span class="line">          <span class="string">&quot;background-color&quot;</span>: <span class="string">&quot;#75cff0&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用浏览器打开 index.html, 此时显示为一片蓝色背景的地图</p>
<p><img src="/2019/07/30/Mapbox-%E5%9C%B0%E5%9B%BE%E6%95%99%E7%A8%8B/1564468837023-2edea0a8-eac8-41c9-8727-77a868b27cbe.png" alt="image.png"></p>
<h2 id="使用本地-GeoJSON-数据"><a href="#使用本地-GeoJSON-数据" class="headerlink" title="使用本地 GeoJSON 数据"></a>使用本地 GeoJSON 数据</h2><h3 id="下载地图资源"><a href="#下载地图资源" class="headerlink" title="下载地图资源"></a>下载地图资源</h3><p>Mapbox 使用本地数据时, 需要引入</p>
<ul>
<li>地图资源 <a href="./maps.zip">maps.zip</a>. 这里使用大熊猫基地的地图数据作为示例.</li>
<li>英文字体包 <a href="./font.zip">font.zip</a>. 汉字字体可以使用页面字体加载, 英文字体必须通过 glyphs 加载.</li>
<li>地图雪碧图 <a href="./sprite.zip">sprite.zip</a>. 通常是一个项目使用一组雪碧图, 包含原始大小和 2x 的图片与 json 文件.</li>
</ul>
<p>雪碧图的生成参考 <a href="/2019/07/23/%E9%9B%AA%E7%A2%A7%E5%9B%BE%E5%88%B6%E4%BD%9C/">Mapbox 雪碧图制作</a> 教程.</p>
<p>下载上述文件并解压到前文的根目录下, 此时的目录结构如下, font 目录下为形如 <code>0-255.pbf</code> 的多个 pbf 文件.</p>
<p><img src="/2019/07/30/Mapbox-%E5%9C%B0%E5%9B%BE%E6%95%99%E7%A8%8B/1564469650662-1a2d992f-c88e-4013-a1d4-347e4f199860.png" alt="image.png"></p>
<h3 id="下载安装-serve-用于启动本地-WebServer"><a href="#下载安装-serve-用于启动本地-WebServer" class="headerlink" title="下载安装 serve 用于启动本地 WebServer"></a>下载安装 serve 用于启动本地 WebServer</h3><p>需要安装 <a href="https://nodejs.org/zh-cn/">nodejs</a>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i -g serve</span><br></pre></td></tr></table></figure>

<p>在当前目录打开命令行, 输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ serve</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果如下</span></span><br><span class="line"><span class="comment">###   ┌───────────────────────────────────────────────┐</span></span><br><span class="line"><span class="comment">###   │                                               │</span></span><br><span class="line"><span class="comment">###   │   Serving!                                    │</span></span><br><span class="line"><span class="comment">###   │                                               │</span></span><br><span class="line"><span class="comment">###   │   - Local:            http://localhost:5000   │</span></span><br><span class="line"><span class="comment">###   │   - On Your Network:  http://10.0.75.1:5000   │</span></span><br><span class="line"><span class="comment">###   │                                               │</span></span><br><span class="line"><span class="comment">###   │   Copied local address to clipboard!          │</span></span><br><span class="line"><span class="comment">###   │                                               │</span></span><br><span class="line"><span class="comment">###   └───────────────────────────────────────────────┘</span></span><br></pre></td></tr></table></figure>

<p>在本地启动了一个 WebServer, 监听 5000 端口, 默认打开当前目录下的 index.html 文件.</p>
<p>在浏览器中打开 <a href="http://localhost:5000/">http://localhost:5000</a>, 可以看到与前文相同的页面</p>
<p><img src="/2019/07/30/Mapbox-%E5%9C%B0%E5%9B%BE%E6%95%99%E7%A8%8B/1564471992521-cac164ef-fed0-4f75-ad78-9f5a0d8af8a7.png" alt="image.png"></p>
<h3 id="增加地图数据源"><a href="#增加地图数据源" class="headerlink" title="增加地图数据源"></a>增加地图数据源</h3><p>修改 index.js 文件, 修改 sources 的值</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line"></span><br><span class="line">const map = new mapboxgl.Map(&#123;</span><br><span class="line">  container: &quot;map&quot;, // 使用 id = map 的元素用于地图容器</span><br><span class="line">  style: &#123;</span><br><span class="line">    // 样式版本, 本地加载使用 version: 8</span><br><span class="line">    version: 8,</span><br><span class="line">    // 使用 maps 目录下的 GeoJSON 文件作为数据源</span><br><span class="line">    sources: &#123;</span><br><span class="line"><span class="addition">+      // 图标数据</span></span><br><span class="line"><span class="addition">+      label: &#123;</span></span><br><span class="line"><span class="addition">+        type: &quot;geojson&quot;,</span></span><br><span class="line"><span class="addition">+        data: &quot;./maps/label.geojson&quot;</span></span><br><span class="line"><span class="addition">+      &#125;,</span></span><br><span class="line"><span class="addition">+      // 面数据</span></span><br><span class="line"><span class="addition">+      polygon: &#123;</span></span><br><span class="line"><span class="addition">+        type: &quot;geojson&quot;,</span></span><br><span class="line"><span class="addition">+        data: &quot;./maps/polygon.geojson&quot;</span></span><br><span class="line"><span class="addition">+      &#125;,</span></span><br><span class="line"><span class="addition">+      // 线数据</span></span><br><span class="line"><span class="addition">+      line: &#123;</span></span><br><span class="line"><span class="addition">+        type: &quot;geojson&quot;,</span></span><br><span class="line"><span class="addition">+        data: &quot;./maps/line.geojson&quot;</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    // 图层定义</span><br><span class="line">    layers: [</span><br><span class="line">      // 背景层</span><br><span class="line">      &#123;</span><br><span class="line">        id: &quot;background&quot;,</span><br><span class="line">        type: &quot;background&quot;,</span><br><span class="line">        paint: &#123;</span><br><span class="line">          // 背景颜色</span><br><span class="line">          &quot;background-color&quot;: &quot;#75cff0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="增加地图样式"><a href="#增加地图样式" class="headerlink" title="增加地图样式"></a>增加地图样式</h3><p>加载数据源后, 依然无法看到实际的地图显示, 这是因为还没有添加需要显示的面图层, 增加 layers 中图层</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line"></span><br><span class="line">const map = new mapboxgl.Map(&#123;</span><br><span class="line">  // 使用 id = map 的元素用于地图容器</span><br><span class="line">  container: &quot;map&quot;,</span><br><span class="line">  // 样式</span><br><span class="line">  style: &#123;</span><br><span class="line">    // 样式版本, 本地加载使用 version: 8</span><br><span class="line">    version: 8,</span><br><span class="line">    // 使用 maps 目录下的 GeoJSON 文件作为数据源</span><br><span class="line">    sources: &#123;</span><br><span class="line">      // 图标数据</span><br><span class="line">      label: &#123;</span><br><span class="line">        type: &quot;geojson&quot;,</span><br><span class="line">        data: &quot;./maps/label.geojson&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      // 面数据</span><br><span class="line">      polygon: &#123;</span><br><span class="line">        type: &quot;geojson&quot;,</span><br><span class="line">        data: &quot;./maps/polygon.geojson&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      // 线数据</span><br><span class="line">      line: &#123;</span><br><span class="line">        type: &quot;geojson&quot;,</span><br><span class="line">        data: &quot;./maps/line.geojson&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 图层定义</span><br><span class="line">    layers: [</span><br><span class="line">      // 背景层</span><br><span class="line">      &#123;</span><br><span class="line">        id: &quot;background&quot;,</span><br><span class="line">        type: &quot;background&quot;,</span><br><span class="line">        paint: &#123;</span><br><span class="line">          // 背景颜色</span><br><span class="line">          &quot;background-color&quot;: &quot;#75cff0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"><span class="addition">+      // 填充层</span></span><br><span class="line"><span class="addition">+      &#123;</span></span><br><span class="line"><span class="addition">+        id: &quot;fill&quot;,</span></span><br><span class="line"><span class="addition">+        type: &quot;fill&quot;,</span></span><br><span class="line"><span class="addition">+        source: &quot;polygon&quot;,</span></span><br><span class="line"><span class="addition">+        filter: [</span></span><br><span class="line"><span class="addition">+          &quot;in&quot;,</span></span><br><span class="line"><span class="addition">+          &quot;type&quot;,</span></span><br><span class="line"><span class="addition">+          &quot;bottom&quot;,</span></span><br><span class="line"><span class="addition">+          &quot;grass&quot;,</span></span><br><span class="line"><span class="addition">+          &quot;green&quot;,</span></span><br><span class="line"><span class="addition">+          &quot;green_down&quot;,</span></span><br><span class="line"><span class="addition">+          &quot;green_middle&quot;,</span></span><br><span class="line"><span class="addition">+          &quot;river&quot;,</span></span><br><span class="line"><span class="addition">+          &quot;highway&quot;,</span></span><br><span class="line"><span class="addition">+          &quot;road&quot;</span></span><br><span class="line"><span class="addition">+        ],</span></span><br><span class="line"><span class="addition">+        paint: &#123;</span></span><br><span class="line"><span class="addition">+          // 填充颜色</span></span><br><span class="line"><span class="addition">+          &quot;fill-color&quot;: [</span></span><br><span class="line"><span class="addition">+            // 按照 geojson type 属性进行过滤</span></span><br><span class="line"><span class="addition">+            &quot;match&quot;,</span></span><br><span class="line"><span class="addition">+            [&quot;get&quot;, &quot;type&quot;],</span></span><br><span class="line"><span class="addition">+            &quot;grass&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#d0e0c7&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;green&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#9dcaaa&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;green_middle&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#B5D7BC&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;green_down&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#C5DFBC&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;river&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#9ED3F3&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;highway&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#F1F1F3&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;bottom&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#ffffff&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;road&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#FFFDF0&quot;,</span></span><br><span class="line"><span class="addition">+            // 默认值</span></span><br><span class="line"><span class="addition">+            &quot;#000000&quot;</span></span><br><span class="line"><span class="addition">+          ],</span></span><br><span class="line"><span class="addition">+          // 填充轮廓颜色</span></span><br><span class="line"><span class="addition">+          &quot;fill-outline-color&quot;: [</span></span><br><span class="line"><span class="addition">+            &quot;match&quot;,</span></span><br><span class="line"><span class="addition">+            [&quot;get&quot;, &quot;type&quot;],</span></span><br><span class="line"><span class="addition">+            &quot;grass&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#d0e0c7&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;green&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#9dcaaa&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;green_middle&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#B5D7BC&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;green_down&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#C5DFBC&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;river&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#9ED3F3&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;highway&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#F1F1F3&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;bottom&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#ffffff&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;road&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#FFFDF0&quot;,</span></span><br><span class="line"><span class="addition">+            &quot;#000000&quot;</span></span><br><span class="line"><span class="addition">+          ]</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>刷新展示页面, 依然只有地图显示.</p>
<p>由于地图的默认中心设置在 [0,0], 并未处于数据源的中心, 需要在 <code>map</code> 的参数中增加 <code>zoom</code>, <code>minZoom</code>, <code>maxZoom</code>, <code>center</code> 属性</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line"></span><br><span class="line">const map = new mapboxgl.Map(&#123;</span><br><span class="line">  container: &quot;map&quot;, // 使用 id = map 的元素用于地图容器</span><br><span class="line"><span class="addition">+  // 当前地图显示等级</span></span><br><span class="line"><span class="addition">+  zoom: 16,</span></span><br><span class="line"><span class="addition">+  // 地图最小缩放等级</span></span><br><span class="line"><span class="addition">+  minZoom: 15,</span></span><br><span class="line"><span class="addition">+  // 地图最大缩放等级</span></span><br><span class="line"><span class="addition">+  maxZoom: 18,</span></span><br><span class="line"><span class="addition">+  // 地图中心</span></span><br><span class="line"><span class="addition">+  center: [104.14417, 30.73596]</span></span><br><span class="line">  // 样式</span><br><span class="line">  style:&#123;</span><br><span class="line">  //.....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>刷新页面, 展示结果如下, 此时可以使用鼠标拖动与缩放地图</p>
<p><img src="/2019/07/30/Mapbox-%E5%9C%B0%E5%9B%BE%E6%95%99%E7%A8%8B/1564472657034-2fc2f814-a3ea-4b0d-885d-abd9b9770131.png" alt="image.png"></p>
<p>此时刷新页面, 会提示出错</p>
<p><img src="/2019/07/30/Mapbox-%E5%9C%B0%E5%9B%BE%E6%95%99%E7%A8%8B/1564474414825-175e6556-5454-4793-aa68-bd29b55360da.png" alt="image.png"></p>
<h3 id="增加-glyphs-与-sprite-路径"><a href="#增加-glyphs-与-sprite-路径" class="headerlink" title="增加 glyphs 与 sprite 路径"></a>增加 glyphs 与 sprite 路径</h3><p>需要指定样式使用的字体包路径, 在 style 中添加属性 glyphs</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line"></span><br><span class="line">const map = new mapboxgl.Map(&#123;</span><br><span class="line">  //.......</span><br><span class="line"></span><br><span class="line">  // 样式</span><br><span class="line">  style: &#123;</span><br><span class="line">    // 样式版本, 本地加载使用 version: 8</span><br><span class="line">    version: 8,</span><br><span class="line"><span class="addition">+    // 字体包路径</span></span><br><span class="line"><span class="addition">+    glyphs: &quot;./&#123;fontstack&#125;/&#123;range&#125;.pbf&quot;</span></span><br><span class="line">    //......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/2019/07/30/Mapbox-%E5%9C%B0%E5%9B%BE%E6%95%99%E7%A8%8B/1564474489428-cf614528-aa6a-4956-bd62-9bf5e222d4c0.png" alt="image.png"></p>
<p>可以看到文字已经加入地图上, 但图标还未显示成功, 使用相同的方法, 在 style 中增加属性 sprite</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line"></span><br><span class="line">const map = new mapboxgl.Map(&#123;</span><br><span class="line">  //.......</span><br><span class="line"></span><br><span class="line">  // 样式</span><br><span class="line">  style: &#123;</span><br><span class="line">    // 样式版本, 本地加载使用 version: 8</span><br><span class="line">    version: 8,</span><br><span class="line">    // 字体包路径</span><br><span class="line">    glyphs: &quot;./&#123;fontstack&#125;/&#123;range&#125;.pbf&quot;,</span><br><span class="line"><span class="addition">+    // 雪碧图路径</span></span><br><span class="line"><span class="addition">+    sprite: &quot;./sprite/sprite&quot;</span></span><br><span class="line">    //......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="解决图标路径-BUG"><a href="#解决图标路径-BUG" class="headerlink" title="解决图标路径 BUG"></a>解决图标路径 BUG</h3><p>刷新页面, 无法加载地图, 报错 <code>Unable to parse URL object</code></p>
<p><img src="/2019/07/30/Mapbox-%E5%9C%B0%E5%9B%BE%E6%95%99%E7%A8%8B/1564474650796-f3a4f188-06f1-4724-8cf7-84653246d200.png" alt="image.png"></p>
<p>Mapbox 无法解析相对路径下的 sprite 路径, 需要修改 sprite 属性, 使用当前页面路径进行填充.</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line"></span><br><span class="line"><span class="addition">+ // 当前页面绝对路径, sprite 无法使用相对路径获取, 因此定义 locationURL</span></span><br><span class="line"><span class="addition">+ const locationURL =</span></span><br><span class="line"><span class="addition">+   window.location.origin +</span></span><br><span class="line"><span class="addition">+   window.location.pathname.substring(</span></span><br><span class="line"><span class="addition">+     0,</span></span><br><span class="line"><span class="addition">+     window.location.pathname.lastIndexOf(&quot;/&quot;)</span></span><br><span class="line"><span class="addition">+   );</span></span><br><span class="line"></span><br><span class="line">const map = new mapboxgl.Map(&#123;</span><br><span class="line">  //......</span><br><span class="line"></span><br><span class="line">  style: &#123;</span><br><span class="line">    // 样式版本, 本地加载使用 version: 8</span><br><span class="line">    version: 8,</span><br><span class="line">    // 字体包路径</span><br><span class="line">    glyphs: &quot;./&#123;fontstack&#125;/&#123;range&#125;.pbf&quot;,</span><br><span class="line">    // 雪碧图路径</span><br><span class="line"><span class="deletion">-   sprite: &quot;./sprite/sprite&quot;</span></span><br><span class="line"><span class="addition">+   sprite: `$&#123;locationURL&#125;/sprite/sprite`</span></span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此时的地图展示如下</p>
<p><img src="/2019/07/30/Mapbox-%E5%9C%B0%E5%9B%BE%E6%95%99%E7%A8%8B/1564474853992-0105e276-e295-49be-aab9-57c4c0a97ff6.png" alt="image.png"></p>
<p>完整 index.js 文件如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前页面绝对路径, sprite 无法使用相对路径获取, 因此定义 locationURL</span></span><br><span class="line"><span class="keyword">const</span> locationURL =</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">origin</span> +</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>.<span class="title function_">substring</span>(</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> mapboxgl.<span class="title class_">Map</span>(&#123;</span><br><span class="line">  <span class="attr">container</span>: <span class="string">&quot;map&quot;</span>, <span class="comment">// 使用 id = map 的元素用于地图容器</span></span><br><span class="line">  <span class="comment">// 当前地图显示等级</span></span><br><span class="line">  <span class="attr">zoom</span>: <span class="number">16</span>,</span><br><span class="line">  <span class="comment">// 地图最小缩放等级</span></span><br><span class="line">  <span class="attr">minZoom</span>: <span class="number">15</span>,</span><br><span class="line">  <span class="comment">// 地图最大缩放等级</span></span><br><span class="line">  <span class="attr">maxZoom</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="comment">// 地图中心</span></span><br><span class="line">  <span class="attr">center</span>: [<span class="number">104.14417</span>, <span class="number">30.73596</span>],</span><br><span class="line">  <span class="comment">// 样式</span></span><br><span class="line">  <span class="attr">style</span>: &#123;</span><br><span class="line">    <span class="comment">// 样式版本, 本地加载使用 version: 8</span></span><br><span class="line">    <span class="attr">version</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="comment">// 字体包路径</span></span><br><span class="line">    <span class="attr">glyphs</span>: <span class="string">&quot;./&#123;fontstack&#125;/&#123;range&#125;.pbf&quot;</span>,</span><br><span class="line">    <span class="comment">// 雪碧图路径</span></span><br><span class="line">    <span class="attr">sprite</span>: <span class="string">`<span class="subst">$&#123;locationURL&#125;</span>/sprite/sprite`</span>,</span><br><span class="line">    <span class="comment">// 使用 maps 目录下的 GeoJSON 文件作为数据源</span></span><br><span class="line">    <span class="attr">sources</span>: &#123;</span><br><span class="line">      <span class="comment">// 图标数据</span></span><br><span class="line">      <span class="attr">label</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;geojson&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="string">&quot;./maps/label.geojson&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 面数据</span></span><br><span class="line">      <span class="attr">polygon</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;geojson&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="string">&quot;./maps/polygon.geojson&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 线数据</span></span><br><span class="line">      <span class="attr">line</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;geojson&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="string">&quot;./maps/line.geojson&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 图层定义</span></span><br><span class="line">    <span class="attr">layers</span>: [</span><br><span class="line">      <span class="comment">// 背景层</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&quot;background&quot;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;background&quot;</span>,</span><br><span class="line">        <span class="attr">paint</span>: &#123;</span><br><span class="line">          <span class="comment">// 背景颜色</span></span><br><span class="line">          <span class="string">&quot;background-color&quot;</span>: <span class="string">&quot;#75cff0&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 填充层</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&quot;fill&quot;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;fill&quot;</span>,</span><br><span class="line">        <span class="attr">source</span>: <span class="string">&quot;polygon&quot;</span>,</span><br><span class="line">        <span class="attr">filter</span>: [</span><br><span class="line">          <span class="string">&quot;in&quot;</span>,</span><br><span class="line">          <span class="string">&quot;type&quot;</span>,</span><br><span class="line">          <span class="string">&quot;bottom&quot;</span>,</span><br><span class="line">          <span class="string">&quot;grass&quot;</span>,</span><br><span class="line">          <span class="string">&quot;green&quot;</span>,</span><br><span class="line">          <span class="string">&quot;green_down&quot;</span>,</span><br><span class="line">          <span class="string">&quot;green_middle&quot;</span>,</span><br><span class="line">          <span class="string">&quot;river&quot;</span>,</span><br><span class="line">          <span class="string">&quot;highway&quot;</span>,</span><br><span class="line">          <span class="string">&quot;road&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">paint</span>: &#123;</span><br><span class="line">          <span class="comment">// 填充颜色</span></span><br><span class="line">          <span class="string">&quot;fill-color&quot;</span>: [</span><br><span class="line">            <span class="comment">// 按照 geojson type 属性进行过滤</span></span><br><span class="line">            <span class="string">&quot;match&quot;</span>,</span><br><span class="line">            [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;type&quot;</span>],</span><br><span class="line">            <span class="string">&quot;grass&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#d0e0c7&quot;</span>,</span><br><span class="line">            <span class="string">&quot;green&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#9dcaaa&quot;</span>,</span><br><span class="line">            <span class="string">&quot;green_middle&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#B5D7BC&quot;</span>,</span><br><span class="line">            <span class="string">&quot;green_down&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#C5DFBC&quot;</span>,</span><br><span class="line">            <span class="string">&quot;river&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#9ED3F3&quot;</span>,</span><br><span class="line">            <span class="string">&quot;highway&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#F1F1F3&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bottom&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line">            <span class="string">&quot;road&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#FFFDF0&quot;</span>,</span><br><span class="line">            <span class="comment">// 默认值</span></span><br><span class="line">            <span class="string">&quot;#000000&quot;</span>,</span><br><span class="line">          ],</span><br><span class="line">          <span class="comment">// 填充轮廓颜色</span></span><br><span class="line">          <span class="string">&quot;fill-outline-color&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;match&quot;</span>,</span><br><span class="line">            [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;type&quot;</span>],</span><br><span class="line">            <span class="string">&quot;grass&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#d0e0c7&quot;</span>,</span><br><span class="line">            <span class="string">&quot;green&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#9dcaaa&quot;</span>,</span><br><span class="line">            <span class="string">&quot;green_middle&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#B5D7BC&quot;</span>,</span><br><span class="line">            <span class="string">&quot;green_down&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#C5DFBC&quot;</span>,</span><br><span class="line">            <span class="string">&quot;river&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#9ED3F3&quot;</span>,</span><br><span class="line">            <span class="string">&quot;highway&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#F1F1F3&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bottom&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line">            <span class="string">&quot;road&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#FFFDF0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;#000000&quot;</span>,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 道路文字</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&quot;roadLabel&quot;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;symbol&quot;</span>,</span><br><span class="line">        <span class="attr">source</span>: <span class="string">&quot;line&quot;</span>,</span><br><span class="line">        <span class="attr">filter</span>: [<span class="string">&quot;in&quot;</span>, <span class="string">&quot;type&quot;</span>, <span class="string">&quot;highway&quot;</span>, <span class="string">&quot;motorway&quot;</span>],</span><br><span class="line">        <span class="attr">layout</span>: &#123;</span><br><span class="line">          <span class="string">&quot;symbol-spacing&quot;</span>: <span class="number">350</span>,</span><br><span class="line">          <span class="string">&quot;symbol-placement&quot;</span>: <span class="string">&quot;line&quot;</span>,</span><br><span class="line">          <span class="string">&quot;text-field&quot;</span>: <span class="string">&quot;&#123;label&#125;&quot;</span>,</span><br><span class="line">          <span class="string">&quot;text-font&quot;</span>: [<span class="string">&quot;font&quot;</span>],</span><br><span class="line">          <span class="string">&quot;text-size&quot;</span>: [<span class="string">&quot;match&quot;</span>, [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;type&quot;</span>], <span class="string">&quot;highway&quot;</span>, <span class="number">16</span>, <span class="number">18</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">paint</span>: &#123;</span><br><span class="line">          <span class="string">&quot;text-color&quot;</span>: <span class="string">&quot;#415A59&quot;</span>,</span><br><span class="line">          <span class="string">&quot;text-halo-color&quot;</span>: <span class="string">&quot;#fff&quot;</span>,</span><br><span class="line">          <span class="string">&quot;text-halo-width&quot;</span>: <span class="number">0.5</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 图标与文字</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&quot;label&quot;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;symbol&quot;</span>,</span><br><span class="line">        <span class="attr">source</span>: <span class="string">&quot;label&quot;</span>,</span><br><span class="line">        <span class="attr">layout</span>: &#123;</span><br><span class="line">          <span class="string">&quot;icon-image&quot;</span>: <span class="string">&quot;&#123;type&#125;&quot;</span>,</span><br><span class="line">          <span class="string">&quot;icon-size&quot;</span>: <span class="number">0.3</span>,</span><br><span class="line">          <span class="string">&quot;text-field&quot;</span>: <span class="string">&quot;&#123;label&#125;&quot;</span>,</span><br><span class="line">          <span class="string">&quot;text-font&quot;</span>: [<span class="string">&quot;font&quot;</span>],</span><br><span class="line">          <span class="string">&quot;text-size&quot;</span>: <span class="number">12</span>,</span><br><span class="line">          <span class="string">&quot;text-offset&quot;</span>: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">          <span class="string">&quot;text-anchor&quot;</span>: <span class="string">&quot;top&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">paint</span>: &#123;</span><br><span class="line">          <span class="string">&quot;text-color&quot;</span>: <span class="string">&quot;#415A59&quot;</span>,</span><br><span class="line">          <span class="string">&quot;text-halo-color&quot;</span>: <span class="string">&quot;#fff&quot;</span>,</span><br><span class="line">          <span class="string">&quot;text-halo-width&quot;</span>: <span class="number">0.5</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
        <tag>mapbox</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql高性能优化规范建议</title>
    <url>/2020/09/02/Mysql%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<p>转载自 <a href="https://www.cnblogs.com/huchong/p/10219318.html">https://www.cnblogs.com/huchong/p/10219318.html</a></p>
<h2 id="数据库命令规范"><a href="#数据库命令规范" class="headerlink" title="数据库命令规范"></a>数据库命令规范</h2><ol>
<li><p>所有数据库对象名称必须使用小写字母并用下划线分割</p>
</li>
<li><p>所有数据库对象名称禁止使用 mysql 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</p>
</li>
<li><p>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</p>
</li>
<li><p>临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期(时间戳)为后缀</p>
</li>
<li><p>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</p>
</li>
</ol>
<span id="more"></span>

<h2 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h2><h3 id="1-所有表必须使用-Innodb-存储引擎"><a href="#1-所有表必须使用-Innodb-存储引擎" class="headerlink" title="1. 所有表必须使用 Innodb 存储引擎"></a>1. 所有表必须使用 Innodb 存储引擎</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（mysql5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）</span><br><span class="line">Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好</span><br></pre></td></tr></table></figure>

<h3 id="2-数据库和表的字符集统一使用-UTF8"><a href="#2-数据库和表的字符集统一使用-UTF8" class="headerlink" title="2. 数据库和表的字符集统一使用 UTF8"></a>2. 数据库和表的字符集统一使用 UTF8</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储emoji表情的需要，字符集需要采用utf8mb4字符集</span><br></pre></td></tr></table></figure>

<h3 id="3-所有表和字段都需要添加注释"><a href="#3-所有表和字段都需要添加注释" class="headerlink" title="3. 所有表和字段都需要添加注释"></a>3. 所有表和字段都需要添加注释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用comment从句添加表和列的备注</span><br><span class="line">从一开始就进行数据字典的维护</span><br></pre></td></tr></table></figure>

<h3 id="4-尽量控制单表数据量的大小，建议控制在-500-万以内"><a href="#4-尽量控制单表数据量的大小，建议控制在-500-万以内" class="headerlink" title="4. 尽量控制单表数据量的大小，建议控制在 500 万以内"></a>4. 尽量控制单表数据量的大小，建议控制在 500 万以内</h3><p>500 万并不是 Mysql 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题<br>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>
<h3 id="5-谨慎使用-Mysql-分区表"><a href="#5-谨慎使用-Mysql-分区表" class="headerlink" title="5. 谨慎使用 Mysql 分区表"></a>5. 谨慎使用 Mysql 分区表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分区表在物理上表现为多个文件，在逻辑上表现为一个表</span><br><span class="line">谨慎选择分区键，跨分区查询效率可能更低</span><br><span class="line">建议采用物理分表的方式管理大数据</span><br></pre></td></tr></table></figure>

<h3 id="6-尽量做到冷热数据分离，减小表的宽度"><a href="#6-尽量做到冷热数据分离，减小表的宽度" class="headerlink" title="6. 尽量做到冷热数据分离，减小表的宽度"></a>6. 尽量做到冷热数据分离，减小表的宽度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mysql限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节</span><br><span class="line"></span><br><span class="line">减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO）</span><br><span class="line">更有效的利用缓存，避免读入无用的冷数据</span><br><span class="line">经常一起使用的列放到一个表中（避免更多的关联操作）</span><br></pre></td></tr></table></figure>

<h3 id="7-禁止在表中建立预留字段"><a href="#7-禁止在表中建立预留字段" class="headerlink" title="7. 禁止在表中建立预留字段"></a>7. 禁止在表中建立预留字段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">预留字段的命名很难做到见名识义</span><br><span class="line">预留字段无法确认存储的数据类型，所以无法选择合适的类型</span><br><span class="line">对预留字段类型的修改，会对表进行锁定</span><br></pre></td></tr></table></figure>

<h3 id="8-禁止在数据库中存储图片，文件等大的二进制数据"><a href="#8-禁止在数据库中存储图片，文件等大的二进制数据" class="headerlink" title="8. 禁止在数据库中存储图片，文件等大的二进制数据"></a>8. 禁止在数据库中存储图片，文件等大的二进制数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时</span><br><span class="line">通常存储于文件服务器，数据库只存储文件地址信息</span><br></pre></td></tr></table></figure>

<h3 id="9-禁止在线上做数据库压力测试"><a href="#9-禁止在线上做数据库压力测试" class="headerlink" title="9. 禁止在线上做数据库压力测试"></a>9. 禁止在线上做数据库压力测试</h3><h3 id="10-禁止从开发环境，测试环境直接连接生成环境数据库"><a href="#10-禁止从开发环境，测试环境直接连接生成环境数据库" class="headerlink" title="10. 禁止从开发环境，测试环境直接连接生成环境数据库"></a>10. 禁止从开发环境，测试环境直接连接生成环境数据库</h3><h2 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="数据库字段设计规范"></a>数据库字段设计规范</h2><h3 id="1-优先选择符合存储需要的最小的数据类型"><a href="#1-优先选择符合存储需要的最小的数据类型" class="headerlink" title="1. 优先选择符合存储需要的最小的数据类型"></a>1. 优先选择符合存储需要的最小的数据类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原因是：列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，</span><br><span class="line">索引的性能也就越差</span><br><span class="line">方法：</span><br></pre></td></tr></table></figure>

<ul>
<li>将字符串转换成数字类型存储，如：将 IP 地址转换成整形数据</li>
</ul>
<p>mysql 提供了两个方法来处理 ip 地址</p>
<p>inet_aton 把 ip 转为无符号整型(4-8 位)<br>inet_ntoa 把整型的 ip 转为地址</p>
<p>插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间<br>显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。</p>
<ul>
<li>对于非负型的数据（如自增 ID、整型 IP）来说，要优先使用无符号整型来存储</li>
</ul>
<p>因为：无符号相对于有符号可以多出一倍的存储空间<br>SIGNED INT -2147483648<del>2147483647<br>UNSIGNED INT 0</del>4294967295</p>
<p>VARCHAR(N)中的 N 代表的是字符数，而不是字节数<br>使用 UTF8 存储 255 个汉字 Varchar(255)&#x3D;765 个字节</p>
<p>过大的长度会消耗更多的内存</p>
<h3 id="2-避免使用-TEXT、BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据"><a href="#2-避免使用-TEXT、BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据" class="headerlink" title="2. 避免使用 TEXT、BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据"></a>2. 避免使用 TEXT、BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h3><ul>
<li>建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</li>
</ul>
<p>Mysql 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行<br>而且对于这种数据，Mysql 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型</p>
<p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select * 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询</p>
<ul>
<li>TEXT 或 BLOB 类型只能使用前缀索引</li>
</ul>
<p>因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p>
<h3 id="3-避免使用-ENUM-类型"><a href="#3-避免使用-ENUM-类型" class="headerlink" title="3. 避免使用 ENUM 类型"></a>3. 避免使用 ENUM 类型</h3><p>修改 ENUM 值需要使用 ALTER 语句<br>ENUM 类型的 ORDER BY 操作效率低，需要额外操作<br>禁止使用数值作为 ENUM 的枚举值</p>
<h3 id="4-尽可能把所有列定义为-NOT-NULL"><a href="#4-尽可能把所有列定义为-NOT-NULL" class="headerlink" title="4. 尽可能把所有列定义为 NOT NULL"></a>4. 尽可能把所有列定义为 NOT NULL</h3><p>原因：<br>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间<br>进行比较和计算时要对 NULL 值做特别的处理</p>
<h3 id="5-使用-TIMESTAMP（4-个字节）或-DATETIME-类型（8-个字节）存储时间"><a href="#5-使用-TIMESTAMP（4-个字节）或-DATETIME-类型（8-个字节）存储时间" class="headerlink" title="5. 使用 TIMESTAMP（4 个字节）或 DATETIME 类型（8 个字节）存储时间"></a>5. 使用 TIMESTAMP（4 个字节）或 DATETIME 类型（8 个字节）存储时间</h3><p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07<br>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高<br>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p>
<p>经常会有人用字符串存储日期型的数据（不正确的做法）<br>缺点 1：无法用日期函数进行计算和比较<br>缺点 2：用字符串存储日期要占用更多的空间</p>
<h3 id="6-同财务相关的金额类数据必须使用-decimal-类型"><a href="#6-同财务相关的金额类数据必须使用-decimal-类型" class="headerlink" title="6. 同财务相关的金额类数据必须使用 decimal 类型"></a>6. 同财务相关的金额类数据必须使用 decimal 类型</h3><ul>
<li>非精准浮点：float,double</li>
<li>精准浮点：decimal</li>
</ul>
<p>Decimal 类型为精准浮点数，在计算时不会丢失精度<br>占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节<br>可用于存储比 bigint 更大的整型数据</p>
<h2 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h2><h3 id="1-限制每张表上的索引数量，建议单张表索引不超过-5-个"><a href="#1-限制每张表上的索引数量，建议单张表索引不超过-5-个" class="headerlink" title="1. 限制每张表上的索引数量，建议单张表索引不超过 5 个"></a>1. 限制每张表上的索引数量，建议单张表索引不超过 5 个</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">索引并不是越多越好！索引可以提高效率同样可以降低效率</span><br><span class="line"></span><br><span class="line">索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率</span><br><span class="line"></span><br><span class="line">因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个</span><br><span class="line">索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能</span><br></pre></td></tr></table></figure>

<h3 id="2-禁止给表中的每一列都建立单独的索引"><a href="#2-禁止给表中的每一列都建立单独的索引" class="headerlink" title="2. 禁止给表中的每一列都建立单独的索引"></a>2. 禁止给表中的每一列都建立单独的索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好</span><br></pre></td></tr></table></figure>

<h3 id="3-每个-Innodb-表必须有个主键"><a href="#3-每个-Innodb-表必须有个主键" class="headerlink" title="3. 每个 Innodb 表必须有个主键"></a>3. 每个 Innodb 表必须有个主键</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的</span><br><span class="line">每个表都可以有多个索引，但是表的存储顺序只能有一种</span><br><span class="line">Innodb是按照主键索引的顺序来组织表的</span><br><span class="line"></span><br><span class="line">不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</span><br><span class="line">不要使用UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</span><br><span class="line">主键建议使用自增ID值</span><br></pre></td></tr></table></figure>

<h2 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="常见索引列建议"></a>常见索引列建议</h2><ol>
<li><p>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</p>
</li>
<li><p>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</p>
<p>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</p>
</li>
<li><p>多表 join 的关联列</p>
</li>
</ol>
<h2 id="如何选择索引列的顺序"><a href="#如何选择索引列的顺序" class="headerlink" title="如何选择索引列的顺序"></a>如何选择索引列的顺序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少</span><br></pre></td></tr></table></figure>

<ol>
<li>区分度最高的放在联合索引的最左侧（区分度&#x3D;列中不同值的数量&#x2F;列的总行数）</li>
<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li>
<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li>
</ol>
<h2 id="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"><a href="#避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"></a>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重复索引示例：primary key(id)、index(id)、unique index(id)</span><br><span class="line">冗余索引示例：index(a,b,c)、index(a,b)、index(a)</span><br></pre></td></tr></table></figure>

<h2 id="对于频繁的查询优先考虑使用覆盖索引"><a href="#对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="对于频繁的查询优先考虑使用覆盖索引"></a>对于频繁的查询优先考虑使用覆盖索引</h2><p>覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by 包含的字段)的索引</p>
<p>覆盖索引的好处:</p>
<ol>
<li>避免 Innodb 表进行索引的二次查询</li>
</ol>
<p>Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，<br>如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据<br>而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率</p>
<ol start="2">
<li>可以把随机 IO 变成顺序 IO 加快查询效率</li>
</ol>
<p>由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，<br>因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO</p>
<h2 id="索引-SET-规范"><a href="#索引-SET-规范" class="headerlink" title="索引 SET 规范"></a>索引 SET 规范</h2><h3 id="尽量避免使用外键约束"><a href="#尽量避免使用外键约束" class="headerlink" title="尽量避免使用外键约束"></a>尽量避免使用外键约束</h3><p>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引<br>外键可用于保证数据的参照完整性，但建议在业务端实现<br>外键会影响父表和子表的写操作从而降低性能</p>
<h2 id="数据库-SQL-开发规范"><a href="#数据库-SQL-开发规范" class="headerlink" title="数据库 SQL 开发规范"></a>数据库 SQL 开发规范</h2><h3 id="1-建议使用预编译语句进行数据库操作"><a href="#1-建议使用预编译语句进行数据库操作" class="headerlink" title="1. 建议使用预编译语句进行数据库操作"></a>1. 建议使用预编译语句进行数据库操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题</span><br><span class="line">只传参数，比传递SQL语句更高效</span><br><span class="line">相同语句可以一次解析，多次使用，提高处理效率</span><br></pre></td></tr></table></figure>

<h3 id="2-避免数据类型的隐式转换"><a href="#2-避免数据类型的隐式转换" class="headerlink" title="2. 避免数据类型的隐式转换"></a>2. 避免数据类型的隐式转换</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">隐式转换会导致索引失效</span><br><span class="line">如:  <span class="keyword">select</span> name,phone <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-充分利用表上已经存在的索引"><a href="#3-充分利用表上已经存在的索引" class="headerlink" title="3. 充分利用表上已经存在的索引"></a>3. 充分利用表上已经存在的索引</h3><h4 id="避免使用双-号的查询条件。"><a href="#避免使用双-号的查询条件。" class="headerlink" title="避免使用双%号的查询条件。"></a>避免使用双%号的查询条件。</h4><p>如 a like ‘%123%’，（如果无前置%,只有后置%，是可以用到列上的索引的）</p>
<h4 id="一个-SQL-只能利用到复合索引中的一列进行范围查询"><a href="#一个-SQL-只能利用到复合索引中的一列进行范围查询" class="headerlink" title="一个 SQL 只能利用到复合索引中的一列进行范围查询"></a>一个 SQL 只能利用到复合索引中的一列进行范围查询</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如 有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，</span><br><span class="line">在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧</span><br></pre></td></tr></table></figure>

<h4 id="使用-left-join-或-not-exists-来优化-not-in-操作"><a href="#使用-left-join-或-not-exists-来优化-not-in-操作" class="headerlink" title="使用 left join 或 not exists 来优化 not in 操作"></a>使用 left join 或 not exists 来优化 not in 操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为 not in 也通常会使用索引失效</span><br></pre></td></tr></table></figure>

<h3 id="4-数据库设计时，应该要对以后扩展进行考虑"><a href="#4-数据库设计时，应该要对以后扩展进行考虑" class="headerlink" title="4. 数据库设计时，应该要对以后扩展进行考虑"></a>4. 数据库设计时，应该要对以后扩展进行考虑</h3><h3 id="5-程序连接不同的数据库使用不同的账号，进制跨库查询"><a href="#5-程序连接不同的数据库使用不同的账号，进制跨库查询" class="headerlink" title="5. 程序连接不同的数据库使用不同的账号，进制跨库查询"></a>5. 程序连接不同的数据库使用不同的账号，进制跨库查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为数据库迁移和分库分表留出余地</span><br><span class="line">降低业务耦合度</span><br><span class="line">避免权限过大而产生的安全风险</span><br></pre></td></tr></table></figure>

<h3 id="6-禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询"><a href="#6-禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询" class="headerlink" title="6. 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询"></a>6. 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原因：</span><br><span class="line">    消耗更多的CPU和IO以网络带宽资源</span><br><span class="line">    无法使用覆盖索引</span><br><span class="line">    可减少表结构变更带来的影响</span><br></pre></td></tr></table></figure>

<h3 id="7-禁止使用不含字段列表的-INSERT-语句"><a href="#7-禁止使用不含字段列表的-INSERT-语句" class="headerlink" title="7. 禁止使用不含字段列表的 INSERT 语句"></a>7. 禁止使用不含字段列表的 INSERT 语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">如： <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">values</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">应使用 <span class="keyword">insert</span> <span class="keyword">into</span> t(c1,c2,c3) <span class="keyword">values</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="8-避免使用子查询，可以把子查询优化为-join-操作"><a href="#8-避免使用子查询，可以把子查询优化为-join-操作" class="headerlink" title="8. 避免使用子查询，可以把子查询优化为 join 操作"></a>8. 避免使用子查询，可以把子查询优化为 join 操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时,才可以把子查询转化为关联查询进行优化</span><br><span class="line"></span><br><span class="line">子查询性能差的原因：</span><br><span class="line"></span><br><span class="line"> 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响</span><br><span class="line"> 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大</span><br><span class="line"> 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询</span><br></pre></td></tr></table></figure>

<h3 id="9-避免使用-JOIN-关联太多的表"><a href="#9-避免使用-JOIN-关联太多的表" class="headerlink" title="9. 避免使用 JOIN 关联太多的表"></a>9. 避免使用 JOIN 关联太多的表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置</span><br><span class="line">在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，</span><br><span class="line">所占用的内存也就越大</span><br><span class="line"></span><br><span class="line">如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，</span><br><span class="line">就会影响到服务器数据库性能的稳定性</span><br><span class="line"></span><br><span class="line">同时对于关联操作来说，会产生临时表操作，影响查询效率</span><br><span class="line">Mysql最多允许关联61个表，建议不超过5个</span><br></pre></td></tr></table></figure>

<h3 id="10-减少同数据库的交互次数"><a href="#10-减少同数据库的交互次数" class="headerlink" title="10. 减少同数据库的交互次数"></a>10. 减少同数据库的交互次数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库更适合处理批量操作</span><br><span class="line">合并多个相同的操作到一起，可以提高处理效率</span><br></pre></td></tr></table></figure>

<h3 id="11-对应同一列进行-or-判断时，使用-in-代替-or"><a href="#11-对应同一列进行-or-判断时，使用-in-代替-or" class="headerlink" title="11. 对应同一列进行 or 判断时，使用 in 代替 or"></a>11. 对应同一列进行 or 判断时，使用 in 代替 or</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">in 的值不要超过500个</span><br><span class="line">in 操作可以更有效的利用索引，or大多数情况下很少能利用到索引</span><br></pre></td></tr></table></figure>

<h3 id="12-禁止使用-order-by-rand-进行随机排序"><a href="#12-禁止使用-order-by-rand-进行随机排序" class="headerlink" title="12. 禁止使用 order by rand() 进行随机排序"></a>12. 禁止使用 order by rand() 进行随机排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，</span><br><span class="line">就会消耗大量的CPU和IO及内存资源</span><br><span class="line">推荐在程序中获取一个随机值，然后从数据库中获取数据的方式</span><br></pre></td></tr></table></figure>

<h3 id="13-WHERE-从句中禁止对列进行函数转换和计算"><a href="#13-WHERE-从句中禁止对列进行函数转换和计算" class="headerlink" title="13. WHERE 从句中禁止对列进行函数转换和计算"></a>13. WHERE 从句中禁止对列进行函数转换和计算</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">对列进行函数转换或计算时会导致无法使用索引</span><br><span class="line"></span><br><span class="line">不推荐：</span><br><span class="line"><span class="keyword">where</span> <span class="type">date</span>(create_time)<span class="operator">=</span><span class="string">&#x27;20190101&#x27;</span></span><br><span class="line">推荐：</span><br><span class="line"><span class="keyword">where</span> create_time <span class="operator">&gt;=</span> <span class="string">&#x27;20190101&#x27;</span> <span class="keyword">and</span> create_time <span class="operator">&lt;</span> <span class="string">&#x27;20190102&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="14-在明显不会有重复值时使用-UNION-ALL-而不是-UNION"><a href="#14-在明显不会有重复值时使用-UNION-ALL-而不是-UNION" class="headerlink" title="14. 在明显不会有重复值时使用 UNION ALL 而不是 UNION"></a>14. 在明显不会有重复值时使用 UNION ALL 而不是 UNION</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UNION</span> 会把两个结果集的所有数据放到临时表中后再进行去重操作</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> 不会再对结果集进行去重操作</span><br></pre></td></tr></table></figure>

<h3 id="15-拆分复杂的大-SQL-为多个小-SQL"><a href="#15-拆分复杂的大-SQL-为多个小-SQL" class="headerlink" title="15. 拆分复杂的大 SQL 为多个小 SQL"></a>15. 拆分复杂的大 SQL 为多个小 SQL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大SQL:逻辑上比较复杂，需要占用大量CPU进行计算的SQL</span><br><span class="line">MySQL 一个SQL只能使用一个CPU进行计算</span><br><span class="line">SQL拆分后可以通过并行执行来提高处理效率</span><br></pre></td></tr></table></figure>

<h2 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="数据库操作行为规范"></a>数据库操作行为规范</h2><h3 id="超-100-万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作"><a href="#超-100-万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作" class="headerlink" title="超 100 万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作"></a>超 100 万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作</h3><h4 id="1-大批量操作可能会造成严重的主从延迟"><a href="#1-大批量操作可能会造成严重的主从延迟" class="headerlink" title="1. 大批量操作可能会造成严重的主从延迟"></a>1. 大批量操作可能会造成严重的主从延迟</h4><p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，<br>而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>
<h4 id="2-binlog-日志为-row-格式时会产生大量的日志"><a href="#2-binlog-日志为-row-格式时会产生大量的日志" class="headerlink" title="2. binlog 日志为 row 格式时会产生大量的日志"></a>2. binlog 日志为 row 格式时会产生大量的日志</h4><p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，<br>产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>
<h4 id="3-避免产生大事务操作"><a href="#3-避免产生大事务操作" class="headerlink" title="3. 避免产生大事务操作"></a>3. 避免产生大事务操作</h4><p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响<br>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p>
<h3 id="对于大表使用-pt-online-schema-change-修改表结构"><a href="#对于大表使用-pt-online-schema-change-修改表结构" class="headerlink" title="对于大表使用 pt-online-schema-change 修改表结构"></a>对于大表使用 pt-online-schema-change 修改表结构</h3><ol>
<li>避免大表修改产生的主从延迟</li>
<li>避免在对表字段进行修改时进行锁表</li>
</ol>
<p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的</p>
<p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器<br>把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉<br>把原来一个 DDL 操作，分解成多个小的批次进行</p>
<h3 id="禁止为程序使用的账号赋予-super-权限"><a href="#禁止为程序使用的账号赋予-super-权限" class="headerlink" title="禁止为程序使用的账号赋予 super 权限"></a>禁止为程序使用的账号赋予 super 权限</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当达到最大连接数限制时，还运行1个有super权限的用户连接</span><br><span class="line">super权限只能留给DBA处理问题的账号使用</span><br></pre></td></tr></table></figure>

<h3 id="对于程序连接数据库账号，遵循权限最小原则"><a href="#对于程序连接数据库账号，遵循权限最小原则" class="headerlink" title="对于程序连接数据库账号，遵循权限最小原则"></a>对于程序连接数据库账号，遵循权限最小原则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">程序使用数据库账号只能在一个DB下使用，不准跨库</span><br><span class="line">程序使用的账号原则上不准有drop权限</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>npm换源与npmrc配置</title>
    <url>/2020/03/30/npm%E6%8D%A2%E6%BA%90%E4%B8%8Enpmrc%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="npm-换源"><a href="#npm-换源" class="headerlink" title="npm 换源"></a>npm 换源</h2><h3 id="修改源地址为淘宝-NPM-镜像"><a href="#修改源地址为淘宝-NPM-镜像" class="headerlink" title="修改源地址为淘宝 NPM 镜像"></a>修改源地址为淘宝 NPM 镜像</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>

<h3 id="修改源地址为官方源"><a href="#修改源地址为官方源" class="headerlink" title="修改源地址为官方源"></a>修改源地址为官方源</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure>

<p>在设置 registry 后运行 npm i -g mirror-config-china 安装镜像配置</p>
<h2 id="npmrc-配置"><a href="#npmrc-配置" class="headerlink" title=".npmrc 配置"></a>.npmrc 配置</h2><p>可以通过修改 <code>~/.npmrc</code> 文件指定 npm 源与相关包的镜像, 常用配置如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm 源</span></span><br><span class="line">registry=https://registry.npm.taobao.org/</span><br><span class="line"><span class="comment"># electron 镜像源</span></span><br><span class="line">electron_mirror=https://npm.taobao.org/mirrors/electron/</span><br><span class="line"><span class="comment"># sass 镜像源</span></span><br><span class="line">sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</span><br><span class="line"><span class="comment"># puppeteer 镜像源</span></span><br><span class="line">puppeteer_download_host=https://npm.taobao.org/mirrors</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>udemy 课程下载</title>
    <url>/2020/09/02/udemy-%E8%AF%BE%E7%A8%8B%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="udemy-课程下载"><a href="#udemy-课程下载" class="headerlink" title="udemy 课程下载"></a>udemy 课程下载</h1><ol>
<li><p>下载工具 <code>udemy-dl</code> 下载</p>
<p><code>git clone https://github.com/r0oth3x49/udemy-dl</code></p>
</li>
<li><p>安装依赖</p>
<p><code>pip3 install -r requirement.txt</code></p>
</li>
<li><p>查看课程 cookie 中 access_token 保存至 cookie.txt 文件</p>
<p><code>access_token=XXXXXXXXX</code></p>
</li>
<li><p>命令行运行</p>
<p><code>python3 udemy-dl.py https://&#123;cource_url&#125; -k cookie.txt --sub-lang en</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim Cheat Sheet</title>
    <url>/2020/03/30/vim-cheat-sheet/</url>
    <content><![CDATA[<h1 id="Vim-Cheat-Sheet"><a href="#Vim-Cheat-Sheet" class="headerlink" title="Vim Cheat Sheet"></a>Vim Cheat Sheet</h1><p>转载至 <a href="https://vim.rtorr.com/lang/zh_cn/">https://vim.rtorr.com/lang/zh_cn&#x2F;</a></p>
<span id="more"></span>

<h2 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h2><ul>
<li><code>:help 关键字</code> - 打开关键字帮助</li>
<li><code>:saveas 文件名</code> - 另存为</li>
<li><code>:close</code> - 关闭当前窗口</li>
<li><code>K</code> - 打开光标所在单词的 man 页面</li>
</ul>
<h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><ul>
<li><code>h</code> - 左移光标</li>
<li><code>j</code> - 下移光标</li>
<li><code>k</code> - 上移光标</li>
<li><code>l</code> - 右移光标</li>
<li><code>H</code> - 移动到当前页面顶部</li>
<li><code>M</code> - 移动到当前页面中间</li>
<li><code>L</code> - 移动到当前页面底部</li>
<li><code>w</code> - 移动到下个单词开头</li>
<li><code>W</code> - 移动到下个单词开头(单词含标点)</li>
<li><code>e</code> - 移动到下个单词结尾</li>
<li><code>E</code> - 移动到下个单词结尾(单词含标点)</li>
<li><code>b</code> - 移动到上个单词开头</li>
<li><code>B</code> - 移动到上个单词开头(单词含标点)</li>
<li><code>%</code> - 跳转到配对的符号(默认支持的配对符号组:: ‘()’, ‘{}’, ‘[]’ - 在 vim 中使用 <code>:h matchpairs</code> 获得更多信息)</li>
<li><code>0</code> - 移动到行首</li>
<li><code>^</code> - 移动到行首的非空白符</li>
<li><code>$</code> - 移动到行尾</li>
<li><code>g_</code> - 移动到行内最后一个非空白符</li>
<li><code>gg</code> - 移动到文件第一行</li>
<li><code>G</code> - 移动到文件最后一行</li>
<li><code>5G</code> - 移动到第五行</li>
<li><code>fx</code> - 移动到字符 x 下次出现的位置</li>
<li><code>tx</code> - 移动到字符 x 下次出现的位置的前一个字符</li>
<li><code>Fx</code> - 移动到字符 x 上次出现的位置</li>
<li><code>Tx</code> - 移动到字符 x 上次出现的位置的后一个字符</li>
<li><code>;</code> - 重复之前的 f、t、F、T 操作</li>
<li><code>,</code> - 反向重复之前的 f、t、F、T 操作</li>
<li><code>&#125;</code> - 移动到下一个段落 (当编辑代码时则为函数／代码块)</li>
<li><code>&#123;</code> - 移动到上一个段落 (当编辑代码时则为函数／代码块)</li>
<li><code>zz</code> - 移动屏幕使光标居中</li>
<li><code>Ctrl + e</code> - 向下移动屏幕一行(保持光标不动)</li>
<li><code>Ctrl + y</code> - 向上移动屏幕一行(保持光标不动)</li>
<li><code>Ctrl + b</code> - 向上滚动一屏</li>
<li><code>Ctrl + f</code> - 向下滚动一屏</li>
<li><code>Ctrl + d</code> - 向下滚动半屏</li>
<li><code>Ctrl + u</code> - 向上滚动半屏</li>
</ul>
<p><strong>Tip</strong> 命令前追加数字表示命令的重复次数, 比如 <code>4j</code> 表示向下移动四行</p>
<h2 id="插入模式-插入-x2F-追加文本"><a href="#插入模式-插入-x2F-追加文本" class="headerlink" title="插入模式 - 插入&#x2F;追加文本"></a>插入模式 - 插入&#x2F;追加文本</h2><ul>
<li><code>i</code> - 从光标前开始插入字符</li>
<li><code>I</code> - 从行首开始插入字符</li>
<li><code>a</code> - 从光标后开始插入字符</li>
<li><code>A</code> - 从行尾开始插入字符</li>
<li><code>o</code> - 在当前行之下另起一行, 开始插入字符</li>
<li><code>O</code> - 在当前行之上另起一行, 开始插入字符</li>
<li><code>ea</code> - 从当前单词末尾开始插入</li>
<li><code>Esc</code> - 退出插入模式</li>
</ul>
<h2 id="编辑文本"><a href="#编辑文本" class="headerlink" title="编辑文本"></a>编辑文本</h2><ul>
<li><code>r</code> - 替换当前字符</li>
<li><code>J</code> - 将下一行合并到当前行, 并在两部分文本之间插入一个空格</li>
<li><code>gJ</code> - 将下一行合并到当前行, 两部分文本之间不含空格</li>
<li><code>gwip</code> - 重新调整段落</li>
<li><code>cc</code> - 将光标所在的行删除, 然后进入插入模式</li>
<li><code>C</code> - 将光标处到行尾删除, 然后进入插入模式</li>
<li><code>c$</code> - 将光标处到行尾删除, 然后进入插入模式</li>
<li><code>ciw</code> - 将光标所在的单词删除, 然后进入插入模式</li>
<li><code>cw</code> - 从光标位置开始, 修改单词</li>
<li><code>s</code> - 删除当前字符, 然后进入插入模式</li>
<li><code>S</code> - 清空当前行, 然后进入插入模式 (同&lt;kbd&gt;cc&lt;&#x2F;kbd&gt;)</li>
<li><code>xp</code> - 当前字符后移</li>
<li><code>u</code> - 撤销</li>
<li><code>Ctrl + r</code> - 重复</li>
<li><code>.</code> - 再次执行上个命令</li>
</ul>
<h2 id="选择文本（可视化模式）"><a href="#选择文本（可视化模式）" class="headerlink" title="选择文本（可视化模式）"></a>选择文本（可视化模式）</h2><ul>
<li><code>v</code> - 进入可视化模式, 移动光标高亮选择, 然后可以对选择的文本执行命令(比如&lt;kbd&gt;y&lt;&#x2F;kbd&gt;-复制)</li>
<li><code>V</code> - 进入可视化模式(行粒度选择)</li>
<li><code>o</code> - 切换光标到选择区开头&#x2F;结尾</li>
<li><code>Ctrl + v</code> - 进入可视化模式(矩阵选择)</li>
<li><code>O</code> - 切换光标到选择区的角</li>
<li><code>aw</code> - 选择当前单词</li>
<li><code>ab</code> - 选择被 () 包裹的区域(含括号)</li>
<li><code>aB</code> - 选择被 {} 包裹的区域(含花括号)</li>
<li><code>ib</code> - 选择被 () 包裹的区域(不含括号)</li>
<li><code>iB</code> - 选择被 {} 包裹的区域(不含花括号)</li>
<li><code>Esc</code> - 退出可视化模式</li>
</ul>
<h2 id="可视化模式命令"><a href="#可视化模式命令" class="headerlink" title="可视化模式命令"></a>可视化模式命令</h2><ul>
<li><code>&gt;</code> - 向右缩进</li>
<li><code>&lt;</code> - 向左缩进</li>
<li><code>y</code> - 复制</li>
<li><code>d</code> - 剪切</li>
<li><code>~</code> - 大小写切换</li>
</ul>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><ul>
<li><code>:reg</code> - 显示寄存器内容</li>
<li><code>&quot;xy</code> - 复制内容到寄存器 x</li>
<li><code>&quot;xp</code> - 粘贴寄存器 x 中的内容</li>
</ul>
<p><strong>Tip</strong> 寄存器被存储在 ~&#x2F;.viminfo 中, 在下次重启 vim 时仍会加载</p>
<p><strong>Tip</strong> 寄存器 0 存储上一次复制的值</p>
<h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><ul>
<li><code>:marks</code> - 标记列表</li>
<li><code>ma</code> - 设置当前位置为标记 a</li>
<li>&#96;a - 跳转到标记 a 的位置</li>
<li>y`a - 复制当前位置到标记 a 的内容</li>
</ul>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><ul>
<li><code>qa</code> - 录制宏 a</li>
<li><code>q</code>- 停止录制宏</li>
<li><code>@a</code> - 执行宏 a</li>
<li><code>@@</code> - 重新执行上次执行的宏</li>
</ul>
<h2 id="剪切-复制-粘贴"><a href="#剪切-复制-粘贴" class="headerlink" title="剪切, 复制, 粘贴"></a>剪切, 复制, 粘贴</h2><ul>
<li><code>yy</code> - 复制当前行</li>
<li><code>2yy</code> - 复制 2 行</li>
<li><code>yw</code> - 复制当前单词</li>
<li><code>y$</code> - 复制, 从光标位置到行末</li>
<li><code>p</code> - 在光标后粘贴</li>
<li><code>P</code> - 在光标前粘贴</li>
<li><code>dd</code> - 剪切当前行</li>
<li><code>2dd</code> - 剪切 2 行</li>
<li><code>dw</code> - 剪切当前单词</li>
<li><code>D</code> - 剪切, 从光标位置到行末</li>
<li><code>d$</code> - 剪切, 从光标位置到行末 (同&lt;kbd&gt;D&lt;&#x2F;kbd&gt;)</li>
<li><code>x</code> - 剪切当前字符</li>
</ul>
<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><ul>
<li><code>:w</code> - 保存</li>
<li><code>:w !sudo tee %</code> - 使用 sudo 保存当前文件</li>
<li><code>:wq or :x or ZZ</code> - 保存并退出</li>
<li><code>:q</code> - 退出(修改未保存时警告)</li>
<li><code>:q! or ZQ</code> - 不保存强制退出</li>
<li><code>:wqa</code> - 保存所有标签页并全部退出</li>
</ul>
<h2 id="查找-x2F-替换"><a href="#查找-x2F-替换" class="headerlink" title="查找&#x2F;替换"></a>查找&#x2F;替换</h2><ul>
<li><code>/pattern</code> - 查找&lt;kbd&gt;pattern&lt;&#x2F;kbd&gt;</li>
<li><code>?pattern</code> - 向上查找&lt;kbd&gt;pattern&lt;&#x2F;kbd&gt;</li>
<li><code>\vpattern</code> - &lt;kbd&gt;pattern&lt;&#x2F;kbd&gt; 中的非字母数字字符被视为正则表达式特殊字符 (不需转义字符)</li>
<li><code>n</code> - 查找下一个</li>
<li><code>N</code> - 查找上一个</li>
<li><code>:%s/old/new/g</code> - 替换全部</li>
<li><code>:%s/old/new/gc</code> - (逐个)替换</li>
<li><code>:noh</code> - 移除搜索结果的高亮显示</li>
</ul>
<h2 id="多文件搜索"><a href="#多文件搜索" class="headerlink" title="多文件搜索"></a>多文件搜索</h2><ul>
<li><code>:vimgrep /pattern/ &#123;&#39;&#123;file&#125;&#39;&#125;</code> - 在多个文件中搜索 &lt;kbd&gt;pattern&lt;&#x2F;kbd&gt;</li>
</ul>
<p><code>e.g. :vimgrep /foo/ **/*</code></p>
<ul>
<li><code>:cn</code> - 移动至下一个</li>
<li><code>:cp</code> - 移动至上一个</li>
<li><code>:copen</code> - 打开搜索结果列表</li>
</ul>
<h2 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h2><ul>
<li><code>:e</code> 文件名 - 新建缓冲区打开 filename</li>
<li><code>:bnext or :bn</code> - 切换到下个缓冲区</li>
<li><code>:bprev or :bp</code> - 切换到上个缓冲区</li>
<li><code>:bd</code> - 关闭缓冲区</li>
<li><code>:ls</code> - 列出所有打开的缓冲区</li>
<li><code>:sp 文件名</code> - 新建缓冲区打开 filename 并水平分割窗口</li>
<li><code>:vsp 文件名</code> - 新缓冲区打开 filename 并垂直分割窗口</li>
<li><code>Ctrl + ws</code> - 水平分割窗口</li>
<li><code>Ctrl + ww</code> - 在窗口间切换</li>
<li><code>Ctrl + wq</code> - 关闭窗口</li>
<li><code>Ctrl + wv</code> - 垂直分割窗口</li>
<li><code>Ctrl + wh</code> - 切换到右侧窗口</li>
<li><code>Ctrl + wl</code> - 切换到左侧窗口</li>
<li><code>Ctrl + wj</code> - 切换到下侧窗口</li>
<li><code>Ctrl + wk</code> - 切换到上侧窗口</li>
</ul>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul>
<li><code>:tabnew or :tabnew &#123;page.words.file&#125;</code> - 在新标签中打开文件</li>
<li><code>Ctrl + wT</code> - 将窗口变成标签</li>
<li><code>gt or :tabnext or :tabn</code> - 切换到下一个标签</li>
<li><code>gT or :tabprev or :tabp</code> - 切换到上一个标签</li>
<li><code>#gt</code> - 切换到第 &lt;kbd&gt;#&lt;&#x2F;kbd&gt; 个标签</li>
<li><code>:tabmove #</code> - 移动标签到第 &lt;kbd&gt;#&lt;&#x2F;kbd&gt; 位(下标从 0 开始)</li>
<li><code>:tabclose or :tabc</code> - 关闭当前标签</li>
<li><code>:tabonly or :tabo</code> - 关闭其他标签</li>
<li><code>:tabdo command</code> - 在所有标签中执行命令 (例如 :tabdo q 关闭所有标签)</li>
</ul>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 配置</title>
    <url>/2019/07/23/webpack-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>转载至 <a href="https://www.yuque.com/fe9/basic/fnvdeu">语雀&#x2F;Webpack 基本配置</a></p>
<h2 id="章节简介"><a href="#章节简介" class="headerlink" title="章节简介"></a>章节简介</h2><p><a href="https://webpack.js.org/">Webpack</a> 是目前最为流行的前端构建工具。同时在前端工程化中，Webpack 在开发&#x2F;编译&#x2F;构建中都起到了最关键的作用。所以在当下阶段，webpack 的基本配置，是每一个前端程序员应当掌握的基本技能。</p>
<span id="more"></span>

<p>2014 年 2 月，Webpack 发布了第一个正式版，而如今已经到了 Webpack@4。Webpack 版本变更似乎是参考了同行的一些功能。<a href="https://rollupjs.org/guide/en">Rollup</a> 推出后，Webpack2 通过 UglifyJs 实现了 tree-shaking，Webpack3 实现了作用域提升(scope-hosting)。而在<a href="https://parceljs.org/">Parcel</a> 推出后，Webpack4 也开始降低配置化。在这之前，用户需要引入大量插件来做构建优化，开发环境与生产环境还需要做不同配置。而 Webpack4 通过设置模式（mode），可以减少开发与生产环境的插件引入与相应逻辑。</p>
<p>所以鉴于此，本章节立足当下，主要介绍 Webpack@4 的基本配置。根据开发构建的不同流程环节与构建的不同需求，我将 webpack 基本配置分为如下几块介绍：</p>
<ol>
<li><p>基本配置</p>
</li>
<li><p>开发配置</p>
</li>
<li><p>构建配置</p>
</li>
<li><p>库开发相关</p>
</li>
</ol>
<p>由于搭建 webpack 工程，会涉及多个维度的相关配置。但分散的配置介绍又显得凌乱，故而我选择系统的介绍相关配置，方便大家阅读后上手。我会从最基础的开始讲，尽量让一个 webpack 小白，看完文章以后，能利用 webpack 搭建基本的前端工程。但是具体详细的配置，我不会穷举，因为无论文章怎么写，必定不如官方文档详实与及时。我不指望一篇文章会成为一本工具书，只希望本文可以告诉入门用户 webpack 的大致套路与某些场景下的配置情况。建议实际操作需要查阅配置时，还是要查阅此时官网的相应文档。</p>
<h2 id="配置前言"><a href="#配置前言" class="headerlink" title="配置前言"></a>配置前言</h2><p>介绍配置之前，我们应该对 webpack 有个初始认识，不然对配置会缺乏一些基本概念。<a href="https://webpack.js.org/">官网</a>对自身有着明确定义：</p>
<blockquote>
<p>webpack 是一个模块打包器。它的主要目标是将 JavaScript 文件打包在一起，打包后的文件用于在浏览器中使用，但它也能够胜任转换(transform)、打包(bundle)或包裹(package)任何资源(resource or asset)。</p>
</blockquote>
<p>在开发 web 应用时，假如我们没有任何构建工具。我们一开始会编写一个 index.html 、index.js、index.less。随着功能的增多，我们的代码开始变的复杂、甚至可能会引用一些开源的库或者框架，这不可避免的要将代码拆分成模块，然后模块之间可能会有依赖。怎么管理不同模块的依赖引入、又如何打包和输出就成了一个大问题。</p>
<p>但不管模块如何多，开发人员总要先编写一个最初始的 js 文件。webpack 就以这个初始 js 文件为「入口」，根据代码中声明的模块引用来加载其他资源文件，根据 webpack 配置来对加载的模块进行编译、打包，最终「输出」开发人员期望的打包结果。</p>
<p>（不同于 webpack，另一款打包工具<a href="https://parceljs.org/">Parcel</a>更倾向于用 html 作为打包的入口文件）。</p>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口[entry]"></a>入口[entry]</h3><p>从上节中，我们明白了「入口」的意义。一个 webpack 工程，首先至少要有一个入口，配置也很简单，官网有介绍：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./index.js&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，因为工程可能是多个 HTML 页面的，每个页面都希望有各自的入口，那可能就是这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">pageA</span>: <span class="string">&quot;./pageA.js&quot;</span>,</span><br><span class="line">    <span class="attr">pageB</span>: <span class="string">&quot;./pageB.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>entry 也可以为数组，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: [<span class="string">&quot;./fileA.js&quot;</span>, <span class="string">&quot;./fileB.js&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样：</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">main</span>: [<span class="string">&quot;./fileA.js&quot;</span>, <span class="string">&quot;./fileB.js&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样配置后会将多个 js 文件，最终打包成一个入口。数组型的入口，在工程开发中使用较少。某些插件可能会利用此特性来实现一些功能，如往入口中注入热更新相关代码以实现热更新[HMR]。</p>
<h3 id="出口-output"><a href="#出口-output" class="headerlink" title="出口[output]"></a>出口[output]</h3><p>我们所定义的「入口」是开发时的程序入口，最终编译构建后，真正被浏览器加载的资源文件则是「出口」文件。「出口」的相关配置定义了输出文件的路径与文件名。最基本的配置为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;output.js&quot;</span>, <span class="comment">// 文件名</span></span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&quot;/dist&quot;</span>, <span class="comment">// 文件输出路径，必须为系统绝对路径</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于「入口」会存在多个，同样的「出口」文件也会有多个，多出口的定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">pageA</span>: <span class="string">&quot;./a.js&quot;</span>,</span><br><span class="line">    <span class="attr">pageB</span>: <span class="string">&quot;./b.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;[name].js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&quot;/dist&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样配置后，将会输出 <code>/dist/pageA.js</code> 与  <code>/dist/pageB.js</code> 。占位符 <code>[name]</code> 为 <code>chunkName</code> ，在此处则即是 entry 中多入口配置对象的 key 值，即 pageA 与 pageB。</p>
<h4 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h4><p>在这里又引入了一个 <code>chunk</code> 的概念。<code>chunk</code> 的中文意思是“块”，在这里即是代码块。我们可以将一个 webpack 打包出的一个 js 文件认为是一个 chunk 。如果我们不做任何的拆包处理，那我们的每一个 entry 就会输出一个 chunk。output 的 filename 的配置中，占位符即代表了 chunk 的一些属性。如[id]代表 chunkId，[chunkhash]代表 chunk 文件的内容哈希值。当然 <code>filename</code> 也可以配置为函数，函数入参则为包含 chunk 信息的对象。</p>
<h4 id="path-与-publicPath"><a href="#path-与-publicPath" class="headerlink" title="path 与 publicPath"></a>path 与 publicPath</h4><p><code>path</code> 配置决定了最终打包后输出资源的文件路径，且它必须要求为系统绝对路径（这不等同于 html 中最终引入的路径）。如果使用了 html 插件（这在后续章节会讲到），那 webpack 会智能的判断生成的 html 与 chunk 的相对路径，再以 script 方式引入。</p>
<p>有时候我们 html 与静态资源并非分发到同一个地方。如 html 为服务端渲染输出、亦或者发至专门的 html 输出服务器以便方便控制版本，而 js&#x2F;css 等静态资源则专门分发到 cdn。这样就需要 html 中引入资源时以完整路径引入。这时就需要用使用 <code>publicPath</code> ，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">pageA</span>: <span class="string">&quot;./a.js&quot;</span>,</span><br><span class="line">    <span class="attr">pageB</span>: <span class="string">&quot;./b.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;[name].js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&quot;/dist&quot;</span>,</span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&quot;https://cdn.antfin.com&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，html 中引用的 js 资源从 <code>pageA.js</code>   变为 <code>https://cdn.antfin.com/pageA.js</code> 。</p>
<p>还有一种常见的情况是“按需加载”。这时 js 资源会异步的去加载，而不是直接以 script 资源方式构建在 html 文件中。这种情况下，webpack 无法判断 js 与 html 的相对路径（因为这是在 js 文件中执行脚本引入的，这个 js 文件也可能被不同的页面引入，不确定此时具体的 html 文件与其路径）。所以，需要配置 <code>publicPath</code> 固化此 <code>异步chunk</code> 的地址。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><code>output</code> 还有个很重要的配置属性是 <code>library</code> ，这个属性决定了 webpack 构建出来的包是做什么用途的，能被以何种方式引用、加载执行。但对于日常工程构建来说，可以默认不配置。后续在 <strong>库开发相关</strong>这一章节中，我会再具体介绍。</p>
<p>除此外，output 还有非常多的配置，但都比较偏门，同学们可以在输出文件遇到问题时，查询官方文档。</p>
<h3 id="模式-mode"><a href="#模式-mode" class="headerlink" title="模式[mode]"></a>模式[mode]</h3><p>模式是 webpack@4 新增的配置属性，目的是为了简化 webpack 繁琐的配置。上两节中我们介绍了文件的入口与输出。在一个工程化的项目中：生产环境下，我们希望输出的文件是经过压缩、混淆（丑化）的。而开发环境时由于调试需要，我们希望文件是未压缩与混淆的。</p>
<p>在 webpack@4 以前，我们往往通过执行不同的 npm script 命令，从而设置不同的 process.env.NODE_ENV，进而在 webpack 配置文件中判断此时环境变量，加载不同的 webpack 插件，输出不同的配置。</p>
<p>由于大部分工程项目的开发环境与生产环境有着较为统一的需求，因此 webpack@4+通过配置不同模式[mode]，来默认执行该模式下的一些通用操作。如生产模式时，默认引入代码压缩混淆插件 <code>UglifyJsPlugin</code> 与作用域提升的插件 <code>ModuleConcatenationPlugin</code> 。</p>
<p>目前已有的模式有：<code>production</code> 、<code>development</code> 、<code>none</code> ，默认为<code>production</code>。设置为 <code>production</code> 与 <code>development</code> 时会同时默认设置 process.env.NODE_ENV 为 production 或 development。 设置 <code>none</code> 时，webpack 不做任何附加操作。</p>
<h3 id="模块-module"><a href="#模块-module" class="headerlink" title="模块[module]"></a>模块[module]</h3><p>我们知道 webpack 是一个模块打包器，它不仅仅能处理 js 文件，还能处理 css、图片。而且也能将 ES6 的代码、甚至是 TypeScript 的代码引用并打包输出成当下可执行的 js 文件。而 webpack 自身不可能穷举处理所有的相关文件。于是就采用了 <code>loader</code> 方式。</p>
<blockquote>
<p>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或 “加载” 模块时预处理文件。</p>
</blockquote>
<p>不同的文件类型可能需要匹配不同的 loader，做不同的文件转化。而有的模块可能需要处理，有的模块可能需要忽略，这一切相关的配置就在 <code>module</code> 中。</p>
<h4 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h4><p><code>module</code> 的主要配置项为 <code>rules</code> 。这是一个数组配置，rules 中的每一项 rule 即配置了如何去处理一个模块。比如我们希望将 ES6 代码转成 ES5 代码，这需要引用 <code>babel-loader</code> 。它的 rule 配置即为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(js)\$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 <code>test</code> 可以为一个正则，其匹配的对象是 引用模块的绝对路径，我们通过配置上述配置将所有引入的 js 文件都通过 babel-loader 来转化。</p>
<p>作为 loader，可能需要一些额外的配置，比如 <code>babel-loader</code> 可能需要做一些编译配置，来设置最终转化后的结果。这需要 <code>use</code> 属性值为对象，不可简写为字符串，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.(js)\$/</span>,</span><br><span class="line">  <span class="attr">use</span>: &#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>] <span class="comment">// 根据目标浏览器自动转换为相应 es5 代码</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ps: babel 的配置我们更多是以.babelrc 配置文件的方式存在项目根目录</span></span><br></pre></td></tr></table></figure>

<p>一般来说，node_modules 中我们加载的外部库文件已经被 babel 编译成 es5 代码，因此是不需要再进行一次 babel 编译的。为了节省开发、构建性能，我们会通过配置 <code>exclude</code> 或 <code>include</code> 来过滤或者指定需要执行 loader 的文件目录。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(js)$/</span>,</span><br><span class="line">  <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">  <span class="attr">exclude</span>: path.<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(), <span class="string">&#x27;./node_modules&#x27;</span>), <span class="comment">// 过滤node_modules目录</span></span><br><span class="line">  <span class="attr">include</span>: path.<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(), <span class="string">&#x27;./src&#x27;</span>) <span class="comment">// 只匹配src目录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时候，我们一个模块文件需要转化多次，需要多个 loader。比如一个 css 文件，先通过 <code>css-loader</code> 解释 css 文件内的 <code>@import</code> 和 <code>url()</code> ， 最后通过 <code>style-loader</code> 将 css 以标签插入至 dom 中。这时，<code>use</code> 配置可以为一个数组。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(css|less)$/</span>,</span><br><span class="line">  <span class="attr">use</span>: [</span><br><span class="line">    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某些 loader 需要增加配置，也可以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(css|less)$/</span>,</span><br><span class="line">  <span class="attr">use</span>: [</span><br><span class="line">    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">sourceMap</span>: <span class="literal">true</span> <span class="comment">// 启用sourceMap</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此外，<code>rule</code> 还有一些较少用的配置如 <code>oneOf</code> 等，可自行查阅官网文档。</p>
<h4 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h4><p>这个配置其实用的比较少。但鉴于 <code>module</code> 也仅有 <code>noParse</code> 与 <code>rule</code> 两个子配置，那我也介绍一下。</p>
<p>我们经常会在模块代码文件中又 import&#x2F;require 其他模块。这就需要 webpack 去解析文件，判断内部是否有模块导入。但某些库文件可能内部并无 import&#x2F;require ，比如 <code>jquery</code> 的 npm 包。再去解析这些文件无疑是浪费性能。故可以配置 noParse 字段，过滤某些你确定不需要递归解析模块加载的包。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">noParse</span>: <span class="regexp">/jquery/</span>, <span class="comment">// 可以为正则</span></span><br><span class="line">    <span class="attr">noParse</span>: <span class="keyword">function</span> (<span class="params">content</span>) &#123;</span><br><span class="line">      <span class="comment">// 亦可以为函数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/jquery/</span>.<span class="title function_">test</span>(content);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解析-resolve"><a href="#解析-resolve" class="headerlink" title="解析[resolve]"></a>解析[resolve]</h3><p>这个配置决定如何去解析模块。（这不是去编译转化文件，不能与上述 loader 所做的事混淆）如：是否需要缓存此模块；是否自动识别扩展文件名等。不过我们最常用的配置只有一个 <code>alias</code> : 创建 <code>import</code> 或 <code>require</code> 的别名，借此来简写某些模块文件的路径。最常见的如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;#&#x27;</span>: path.<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(), <span class="string">&#x27;./src&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样在某些需要相对路径比较深的模块引入时，可以从这样：</p>
<p><code>import utils from &#39;../../../utils&#39;</code></p>
<p>变为这样：</p>
<p><code>import utils from &#39;#/utils&#39;</code></p>
<p>PS: 这样有一个坏处就是编辑器没办法自动匹配文件路径了，不过可以在 vscode 中配置 <code>jsconfig.json</code> ，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;#/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/*&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="统计信息-stats"><a href="#统计信息-stats" class="headerlink" title="统计信息[stats]"></a>统计信息[stats]</h3><p>当我们执行 webpack 命令时，终端中会打印非常多的信息。有时候有些信息并不是很重要，有时候我们只在意出错的信息，这时候 <code>stats</code> 配置就派上了用场。</p>
<p>如果是开发环境，启动了 webpack-dev-server，那这个配置需要 <code>devServer</code> 对象中。关于 webpack-dev-server 的配置，将会在下一节-开发配置 中谈及。</p>
<p><code>stats</code> 对应的配置有四十多个，选项非常精细，所以 webpack 提供一些预设选项，只要配置一个预设值，就对应了一系列配置。具体如下：</p>
<table>
<thead>
<tr>
<th>Preset</th>
<th>Alternative</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;errors-only&quot;</code></td>
<td>none</td>
<td>只在发生错误时输出</td>
</tr>
<tr>
<td><code>&quot;minimal&quot;</code></td>
<td>none</td>
<td>只在发生错误 或是 新的编译时输出</td>
</tr>
<tr>
<td><code>&quot;none&quot;</code></td>
<td><code>false</code></td>
<td>没有输出</td>
</tr>
<tr>
<td><code>&quot;normal&quot;</code></td>
<td><code>true</code></td>
<td>标准输出</td>
</tr>
<tr>
<td><code>&quot;detailed&quot;</code></td>
<td>none</td>
<td>详细输出（从 webpack 3.0.0 开始）</td>
</tr>
<tr>
<td><code>&quot;verbose&quot;</code></td>
<td>none</td>
<td>全部输出</td>
</tr>
</tbody></table>
<p>但是在实际使用中，可能还是有些局限，不一定满足自身定制化的需求，所幸大部分配置都是默认开启，实际需求中只要关闭几个不必要的配置即可。笔者的日常配置如下： <code>devServer</code>   中配置 <code>stats</code> 为 <code>errors-only</code> 。在生产环境时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">stats</span>: &#123;</span><br><span class="line"> <span class="attr">warnings</span>: <span class="literal">false</span>, <span class="comment">// 取消警告信息</span></span><br><span class="line"> <span class="attr">children</span>: <span class="literal">false</span>, <span class="comment">// 取消子级信息</span></span><br><span class="line"> <span class="attr">modules</span>: <span class="literal">false</span>, <span class="comment">// 取消模块构建信息</span></span><br><span class="line"> <span class="attr">entrypoints</span>: <span class="literal">false</span> <span class="comment">// 不显示入口起点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="loader-与-plugin"><a href="#loader-与-plugin" class="headerlink" title="loader 与 plugin"></a>loader 与 plugin</h2><p>上一节，主要介绍了入口文件从解析到编译输出的一些基本配置。但 webpack 强大的功能主要还是依赖于 <code>loader</code> 与 <code>plugin</code> 机制。本节将简单介绍日常配置中，基本必须的一些 loader 与 plugin。</p>
<h3 id="必备-loader"><a href="#必备-loader" class="headerlink" title="必备 loader"></a>必备 loader</h3><p>关于 <code>loader</code> 的概念，上节的 <code>module</code> 配置中已有简单介绍，此处不重复了。</p>
<h4 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h4><p>利用<a href="https://babeljs.io/">babel</a> 将最新标准的代码转成当下浏览器可执行的 js 代码。<code>babel-loader</code> 的配置即是 <code>babel</code> 的配置，其主要是以 <code>.babelrc</code> 配置文件的方式存在项目根目录。如配置有特殊逻辑处理，可以在 <code>module.rules</code> 中引用</p>
<p><code>babel-loader</code> 处做配置覆盖。</p>
<h4 id="css-相关-loaders"><a href="#css-相关-loaders" class="headerlink" title="css 相关 loaders"></a>css 相关 loaders</h4><ul>
<li>less-loader&#x2F;sass-loader: 现代工程基本基本已离不开 <code>less/sass</code> 预处理。</li>
</ul>
<ul>
<li>postcss-loader: css 样式后处理工具。css 压缩、合并、自动兼容浏览器等功能利器。</li>
</ul>
<ul>
<li>css-loader: 解释 css 文件内的 <code>@import</code> 和 <code>url()</code> ；可开启 <code>css-module</code> 。</li>
</ul>
<ul>
<li>style-loader: 将 css 以 <code>style</code> 标签插入 dom 中。</li>
</ul>
<ul>
<li>css-hot-loader: css 热更新 loader，<strong>线上环境时勿加，会引起 js 文件 contentHash 每次都不同</strong>。</li>
</ul>
<h4 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h4><p>对于图片这样的静态资源，我们在代码中引入时，常以当前文件为基准，引入其相对路径下的图片。而当我们访问 html 时，这个相对路径其实是基于 html 此时的路径的，故而会导致引入路径错误。 <code>file-loader</code> 主要解决这个问题。可以自动的识别 webpack 配置，打包资源图片，修复引入路径，进而保证资源引入正确。同时也支持修改输出后文件的路径与文件名、携带 hash 值等功能。</p>
<h4 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h4><p>基本功能同 <code>file-loader</code> ，在它基础上，可以设置一个 <code>limit</code> 配置项，意义为文件的体积大小，单位为字节。对于小于此大小的文件，会转化成 base64 的数据，替换 url 引入。对于小图片等资源常用这样的操作，好处是减少资源的请求次数；或者在某些场景下，保证图片在 html 加载或渲染时就能展示，不需要再发起请求。</p>
<h3 id="必备-plugin"><a href="#必备-plugin" class="headerlink" title="必备 plugin"></a>必备 plugin</h3><p>有些新手同学一开始可能会混淆 <code>plugin</code> 与 <code>loader</code> 。关于 loader 上面已经阐述多次，也能较为清晰的明白，   <code>loader</code> 主要负责对于某些文件的处理与转化。</p>
<p>但构建过程中的很多场景，并非都是针对单个文件去做处理的。比如我需要把最终编译后的 js 文件压缩混淆一下。如果单个文件去压缩，有些全局变量或上下文关系处理起来就很麻烦。比如我想在编译期定义几个全局常量，如定义_DEV_为当前编译环境。这个跟某些文件并没有关系。而这些都需要相应的 <code>plugin</code> 来支持。</p>
<p>我们能大致的感受到，<code>plugin</code> 是作用于 webpack 命令执行的整个生命周期的。在 webpack 编译的生命周期中，会暴露出对应的一系列生命周期钩子，以便于 <code>plugin</code> 调用与执行相应的行为。其具体的原理与深入的了解在下一章《深入了解 webpack》中会继续讲到。本节主要介绍几个日常使用必不可少的几个插件。</p>
<h4 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h4><p>只要是 web 应用的工程，必须要有 html 文件或者其他 html 模板文件。那么 <code>html-webpack-plugin</code> 就必不可少。这个插件在上述中也有使用过，主要功能就是可以根据项目中的 html 模板（没有也行），生成想要的 html 文件，并插入我们构建出来的 js 与 css 等资源。</p>
<p>有一个需要注意的点是，对于构建多页应用来说，每需要一个 html 文件，就需增加一个 <code>html-webpack-plugin</code>，并引入相应的 chunk。配置举例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">pageA</span>: <span class="string">&quot;./a.js&quot;</span>,</span><br><span class="line">    <span class="attr">pageB</span>: <span class="string">&quot;./b.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;[name].js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&quot;/dist&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;pageA.html&quot;</span>,</span><br><span class="line">      <span class="attr">chunks</span>: [<span class="string">&quot;pageA&quot;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;pageB.html&quot;</span>,</span><br><span class="line">      <span class="attr">chunks</span>: [<span class="string">&quot;pageB&quot;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该插件配置非常丰富，包括修改 html 标题、注入 meta 标签、向 html 模板中注入某些自定义变量等。具体可参考其<a href="https://github.com/jantimon/html-webpack-plugin">github 文档</a> 。</p>
<h4 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h4><p>之前我们介绍的配置，一直没有谈及如何抽离 css 文件。我们的 css 一直是以 <code>style</code> 标签的形式插入至 dom 中的。这明显不是我们想要的结果。<code>mini-css-extract-plugin</code> 就是干这样的活的。需要注意的是，如果引入了本插件，那么就需要在 css 文件的相关 <code>loaders</code> 中需要使用 <code>MiniCssExtractPlugin.loader</code> 替换<code>style-loader</code> 。<br>配置举例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line"><span class="attr">fileName</span>: <span class="string">&#x27;[name].css&#x27;</span> <span class="comment">// 生产环境需要 hash 可配置为 [name].[contenthash].css</span></span><br><span class="line">   &#125;)</span><br><span class="line"> ],</span><br><span class="line"><span class="attr">modules</span>: &#123;</span><br><span class="line"><span class="attr">rules</span>: [</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.css\$/</span>,</span><br><span class="line"><span class="attr">use</span>: [</span><br><span class="line">    <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">    <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">     ]</span><br><span class="line">]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HotModuleReplacementPlugin"><a href="#HotModuleReplacementPlugin" class="headerlink" title="HotModuleReplacementPlugin"></a>HotModuleReplacementPlugin</h4><p>HMR 在上文中有多次提到，webpack 官网中的介绍也非常清晰：</p>
<blockquote>
<p>模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除<a href="https://webpack.docschina.org/concepts/modules/">模块</a>，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度:</p>
</blockquote>
<blockquote>
<ul>
<li>保留在完全重新加载页面时丢失的应用程序状态。</li>
</ul>
<ul>
<li>只更新变更内容，以节省宝贵的开发时间。</li>
</ul>
<ul>
<li>调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。</li>
</ul>
</blockquote>
<p>从介绍中我们明白，热替换是以模块为维度的，HMR 是可选的，也只会影响包含 HMR 代码的模块。而模块的加载与处理可能会经过 <code>loader</code> ，这就需要相应的 <code>loader</code> 去实现 HMR 接口。基于此，我们有一些注意点</p>
<ol>
<li><p>webpack-dev-server 中需要设置 <code>hot</code> 为 <code>true</code> 。</p>
</li>
<li><p><code>style-loader</code> 支持热替换，但是上小节中为了抽离 css 文件引入的 <code>MiniCssExtractPlugin.loader</code> 暂时未支持热替换，故而需要开发环境时采用 <code>style-loader</code> ，或者引入 <code>css-hot-loader</code> 。</p>
</li>
<li><p>react 工程需要实现组件热替换的话，需引入 <code>react-hot-loader</code> 。<code>vue-loader</code> 已经实现了 HMR，无需要增加其他 loader。</p>
</li>
</ol>
<h4 id="uglifyjs-webpack-plugin"><a href="#uglifyjs-webpack-plugin" class="headerlink" title="uglifyjs-webpack-plugin"></a>uglifyjs-webpack-plugin</h4><p>这个插件已经耳熟能详了，就是要来实现代码压缩、混淆、tree-shaking 的。过于常用，故而 webpack 也已内置。</p>
<h4 id="commons-chunk-plugin"><a href="#commons-chunk-plugin" class="headerlink" title="commons-chunk-plugin"></a>commons-chunk-plugin</h4><p>这个插件用来抽离多个入口 chunk 内的公共代码，这在 webpack@4 以前很常用。在 webpack@4 中，已使用</p>
<p><code>optimization.splitChunks</code> 来实现这样的功能，其内部实现基于内置的 <code>SplitChunksPlugin</code> 。具体详细介绍会在「构建配置」一章中再阐述。</p>
<h4 id="webpack-bundle-analyzer"><a href="#webpack-bundle-analyzer" class="headerlink" title="webpack-bundle-analyzer"></a>webpack-bundle-analyzer</h4><p>提供可视化的界面，以用来分析 webpack 构建后的打包情况。建议工程项目都可以添加，才能清晰掌握自己工程项目具体加载了哪些代码，进而做相应的打包优化。</p>
<h2 id="开发配置"><a href="#开发配置" class="headerlink" title="开发配置"></a>开发配置</h2><p>至此我们对 webpack 的大致配置与需要的额外插件与 loader 已基本清楚。但是实际开发中还存在一些问题，如：构建出的 web 应用本地如何预览？如何实时构建编译？如何不刷新页面加载最新代码？</p>
<p>在上古时代时，开发人员会引入一些工具检测文件变化（如 nodemon），进而执行重编译。然后本地再搭建一个静态 server 预览构建出来的 html，(往往是用 express)。这不免太过麻烦，后续 webpack 便出了 <a href="https://github.com/webpack/webpack-dev-middleware">webpack-dev-middleware</a> 、<a href="https://github.com/webpack-contrib/webpack-hot-middleware">webpack-hot-middleware</a> 等中间件方便用户快速的实现页面预览，热加载等功能。</p>
<p>但是中间件的引入方式还是有些麻烦，在 webpack@4 中，更进一步，推出 <code>webpack-dev-server</code> 。设置 webpack 的 <code>devServer</code> 配置项，在开发环境时，以<code>webpack-dev-server</code>替换 <code>webpack</code> 来执行 webpack 配置文件，便能按照配置满足自己的开发需要。</p>
<p>我们明白 <code>devServer</code> 主要就是启动了一个静态服务，让开发者可以方便的预览自己工程构建的 webApp。其配置项也主要是围绕服务器。</p>
<h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><h4 id="host-string"><a href="#host-string" class="headerlink" title="host[string]"></a>host[string]</h4><p>服务的 host，默认为 <code>localhost</code> ，如果有需要非本机访问的需求（如想通过手机访问页面），可配成 <code>0.0.0.0</code></p>
<h4 id="port-number"><a href="#port-number" class="headerlink" title="port[number]"></a>port[number]</h4><p>服务端口号。不配置时，默认为 8080，如若端口不可用，会自增寻找可用端口。但手动配置且端口号不可用时，不会自动寻找其他端口号。</p>
<h4 id="disableHostCheck-boolean"><a href="#disableHostCheck-boolean" class="headerlink" title="disableHostCheck[boolean]"></a>disableHostCheck[boolean]</h4><p>默认为 <code>false</code> 。如果有绑定域名访问的需要的话，需设置为 <code>true</code> 。</p>
<h4 id="allowedHosts-array"><a href="#allowedHosts-array" class="headerlink" title="allowedHosts[array]"></a>allowedHosts[array]</h4><p>如果你觉得 <code>disableHostCheck</code> 直接设为 true 存在一些安全隐患，那可以自己配置允许的 hosts 白名单。将指定的域名添加至配置项中，即可通过该域名访问本服务。</p>
<h4 id="contentBase-boolean-string-array"><a href="#contentBase-boolean-string-array" class="headerlink" title="contentBase[boolean|string|array]"></a>contentBase[boolean|string|array]</h4><p>可以理解为静态服务器的内容目录地址。或者说，就是访问服务器的 ip&#x2F;域名时，对应访问的工程里的文件夹。举个例子，假设配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么访问 <code>http://localhost:8080</code> 则会 访问工程目录下的 <code>dist</code> 文件夹，域名的多级路径，也会映射成文件夹内的多级目录。（webpack-dev-server 访问的是内存中文件，此时文件并未真正输出到 <code>dist</code> 目录下）</p>
<p>如果是 <code>contentBase</code> 配置项为数组，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">  <span class="attr">contentBase</span>: [path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;dist&quot;</span>), path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;www&quot;</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，<code>dist</code> 与 <code>www</code> 目录下的文件都能通过 <code>http://localhost:8080</code>访问。</p>
<p>也可以设置为 false，则会禁用 <code>contentBase</code> 。</p>
<h4 id="index-string"><a href="#index-string" class="headerlink" title="index[string]"></a>index[string]</h4><p>配置完 <code>contentBase</code> 后，我们访问 <code>http://localhost:8080</code> 时，会自动加载设置的内部目录下的</p>
<p><code>index.html</code> 文件。当然某些特殊情况下，我们的主页文件名并非 <code>index.html</code> ，比如是叫 <code>home.html</code> 。那么我们可以改变 index 配置来实现这样的效果，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">  <span class="attr">index</span>: <span class="string">&quot;home.html&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hot-boolean"><a href="#hot-boolean" class="headerlink" title="hot[boolean]"></a>hot[boolean]</h4><p>启动 webpack 的模块热替换。即不需要刷新页面则更新代码。不过这需要插入热更新插件，这回会在本节后续讲到。</p>
<h4 id="clientLogLevel-string"><a href="#clientLogLevel-string" class="headerlink" title="clientLogLevel[string]"></a>clientLogLevel[string]</h4><p>默认为 <code>info</code> ，可选为 <code>none</code>, <code>error</code>, <code>warning</code> 。默认开启时会在浏览器命令台输出很多信息。不利于开发调试，如无必要，可以设置为 <code>none</code> 或 <code>error</code> 。</p>
<h4 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h4><p>这里的 <code>stats</code> 配置同 上一大节中的 <strong>统计信息[stats]</strong> 配置一模一样。上文也讲到，如果是开发环境，启动了 webpack-dev-server，那关于统计信息的输出，将以 <code>devServer</code> 中的 <code>stats</code> 为准。</p>
<p><code>devServer</code> 的其他配置场景较少，不再穷举。</p>
<h2 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h2><p>上小节我们讲到开发环境下的特殊配置，那么在生产环境时，我们也有特殊的构建需求。而生产环境的主要矛盾就是日益增长的工程代码量同用户落后的网速之间的矛盾。在 webpack 这一层，主要的解决方法就是尽量减小构建包的体积。这在下一章节中会详细的介绍如何优化构建。在本章中，先简单的介绍下设计的配置项。</p>
<h3 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h3><p>在 webpack@4 以前，想做构建优化，需要引入不少插件。webpack@4 中尽量将这些插件内置，并将其配置化，主要收敛在 <code>optimization</code> 这个配置项中。其主要配置有：</p>
<h4 id="minimize"><a href="#minimize" class="headerlink" title="minimize"></a>minimize</h4><p>当 <code>mode</code> 配置为 <code>production</code> 时，<code>minimize</code> 值为 true。若设为 false 时取消引入 <code>uglifyjs-webpack-plugin</code> 。</p>
<h4 id="minimizer"><a href="#minimizer" class="headerlink" title="minimizer"></a>minimizer</h4><p>配置执行代码压缩的工具，默认为 <code>uglifyjs-webpack-plugin</code> ，如果需要替换成其他的或者增加新的</p>
<p>代码压缩插件的话，可以手动覆盖，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">OptimizeCSSAssetsPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;optimize-css-assets-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UglifyJsPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;uglifyjs-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">UglifyJsPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">cache</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">parallel</span>: <span class="literal">true</span>, <span class="comment">// 多进程压缩</span></span><br><span class="line">        <span class="attr">sourceMap</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">OptimizeCSSAssetsPlugin</span>(&#123;&#125;), <span class="comment">// 优化压缩 css</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="splitChunks"><a href="#splitChunks" class="headerlink" title="splitChunks"></a>splitChunks</h4><p>该配置项的配置即是 <code>SplitChunkPlugin</code> 的配置，其用处是可以按一定规则将工程中代码提取一部分到一个新的 chunk 文件。常见的场景有：</p>
<ul>
<li><p>把不同页面公共的代码抽离到一个 <code>commonChunk</code> 。</p>
</li>
<li><p>把外部依赖包单独抽离到一个 <code>vendor</code> 。</p>
</li>
<li><p>把 React&#x2F;Vue 等项目必引的库单独抽离成 <code>dll</code> 。</p>
</li>
</ul>
<p>其基本配置如下：</p>
<ul>
<li><p>name: 分离出的 chunk 名字，默认为 true，chunk name 会自动生成。</p>
</li>
<li><p>maxInitialRequests: 最大可分割出来的 chunk 数。</p>
</li>
<li><p>maxAsyncRequests: 最大可分割出来的异步 chunk 数（按需加载时使用）。</p>
</li>
<li><p>cacheGroups: 这个配置项是分割代码的核心配置，这是一个对象，key 为 chunk 的唯一识别 key，value 为 chunk 的具体分割规则配置，如下：</p>
<ul>
<li><p>name: 分离出的 chunk 的名字，若未设置且 <code>splitChunks.name</code> 为 true 时，以 chunk 的 key 为 name。</p>
</li>
<li><p>minChunks: 抽离公共代码时，该公共代码最少被几个 chunk 引用了。</p>
</li>
<li><p>test: 模块匹配的规则</p>
</li>
<li><p>priority: 分离规则优先级。有时候一个模块可能被多个规则匹配到，设置优先级可以让某个规则分离的 chunk 具有更高匹配模块的优先级。</p>
</li>
</ul>
</li>
</ul>
<h4 id="runtimeChunk"><a href="#runtimeChunk" class="headerlink" title="runtimeChunk"></a>runtimeChunk</h4><p>webpack 打包代码后，为了控制模块的依赖与加载，必不可少的需要往工程项目中加入 webpack 提供的相应执行代码。这部分代码会因模块的增删改变化而变化。故而可以通过配置 <code>runtimeChunk</code> ，将这部分运行时代码抽离出来。 <code>runtimeChunk</code> 默认为 false，可以配置为 <code>&#123; name: &#39;manifest&#39; &#125;</code> ，设为对象，指定 name 即可。</p>
<h2 id="库开发相关"><a href="#库开发相关" class="headerlink" title="库开发相关"></a>库开发相关</h2><p>上述所说主要是针对 web 应用工程项目的配置。但有时候我们利用 webpack 是想构建一个函数工具库&#x2F;组件库，并非是一个 web 应用。不需要 html，也往往不需要什么按需加载，最主要的就是考虑外部如何去引用本库。</p>
<p>对于 web 应用而言，webpack 构建的是一堆 chunk 文件。在 html 中引入它们或者在 js 脚本中再执行按需引入。而对于库而言则不是。一个工具库往往是暴露出一个或多个函数、类、值等。这同 web 应用有明显区别，这相关的配置主要也是在<strong>出口[output]</strong> 的配置项中。</p>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><h4 id="library"><a href="#library" class="headerlink" title="library"></a>library</h4><p>设置该配置为一个字符串，当此库加载完成时，即会将其返回值分配给一个变量，变量名即为 <code>library</code> 设置的值。若通过 script 标签引入本库，在全局环境下声明此变量，则其就会挂载到全局对象上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"> <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line"> <span class="attr">output</span>: &#123;</span><br><span class="line">  <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;your-library.js&#x27;</span></span><br><span class="line">  <span class="attr">library</span>: <span class="string">&#x27;yourLibrary&#x27;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="libraryTarget"><a href="#libraryTarget" class="headerlink" title="libraryTarget"></a>libraryTarget</h4><p>如果只是暴露出一个变量，通过 script 标签引入，那也太不优雅了。我们自然是希望自己构建的库可以通过 <code>require</code> 或 <code>import</code> 去加载。或者最粗暴的，什么样的加载方式都能支持。这就需要 <code>libraryTarget</code> 这个配置。它的值为字符串，存在如下几种情况</p>
<ul>
<li><p><strong>var</strong>:   默认配置。会在当前作用域通过 <code>var</code> 声明一个变量，值为库的返回值，变量名为 <code>library</code> 配置的值，如果为空，则无法赋值。</p>
</li>
<li><p><strong>assign</strong>: 不通过 <code>var</code> 声明。直接在 变量上赋值。如果本作用域内之前未声明该变量，则会由于作用域提升而挂载在全局作用域。<strong>危险操作，不建议使用本配置值。</strong></p>
</li>
<li><p><strong>this&#x2F;window&#x2F;global</strong>: 将变量挂载在当前作用域的 <code>this/window/global</code> 对象下。</p>
</li>
<li><p><strong>commonjs</strong>: 以 <code>commonjs</code> 的模块规范导出模块。其值分配给 <code>exports[library]</code> 。</p>
</li>
<li><p><strong>commonjs2</strong>: 以 <code>commonjs</code> 的模块规范导出模块。其值分配给 <code>export</code> 。</p>
</li>
<li><p><strong>amd</strong>: 以 amd 的模块规范导出模块（用的越来越少了）。</p>
</li>
<li><p><strong>umd</strong>: 所有的模块定义下都可运行。</p>
</li>
</ul>
<p>还有一些特殊的情况，比如构建的模块是专门给 <code>node</code> 环境或者 <code>electron</code> 下使用的。这样的场景需要修改 <strong>构建目标[targets]，</strong>但这跟 <code>output.libraryTarget</code> 是完全两个概念，解决的也不是同维度的问题。</p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>代码命名规范</title>
    <url>/2021/04/29/%E4%BB%A3%E7%A0%81%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h2><p>方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从<code>驼峰形式</code>。</p>
<p><code>正例： localValue / getHttpMessage() / inputUserId</code></p>
<p><em>其中 method 方法命名必须是 动词, 或者 动词+名词 形式</em></p>
<p><code>正例：saveShopCarData /openShopCarInfoDialog</code></p>
<p><code>反例：save / open / show / go</code></p>
<p><em>特此说明，增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）</em></p>
<p><code>add / update / delete / detail / get</code></p>
<span id="more"></span>

<h2 id="函数方法常用的动词"><a href="#函数方法常用的动词" class="headerlink" title="函数方法常用的动词"></a>函数方法常用的动词</h2><table>
<thead>
<tr>
<th>动词</th>
<th>说明</th>
<th>动词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>get</td>
<td>获取</td>
<td>set</td>
<td>设置</td>
</tr>
<tr>
<td>add</td>
<td>增加</td>
<td>remove</td>
<td>删除</td>
</tr>
<tr>
<td>create</td>
<td>创建</td>
<td>destroy</td>
<td>移除</td>
</tr>
<tr>
<td>start</td>
<td>启动</td>
<td>stop</td>
<td>停止</td>
</tr>
<tr>
<td>open</td>
<td>打开</td>
<td>close</td>
<td>关闭</td>
</tr>
<tr>
<td>read</td>
<td>读取</td>
<td>write</td>
<td>写入</td>
</tr>
<tr>
<td>load</td>
<td>载入</td>
<td>save</td>
<td>保存</td>
</tr>
<tr>
<td>create</td>
<td>创建</td>
<td>destroy</td>
<td>销毁</td>
</tr>
<tr>
<td>begin</td>
<td>开始</td>
<td>end</td>
<td>结束</td>
</tr>
<tr>
<td>backup</td>
<td>备份</td>
<td>restore</td>
<td>恢复</td>
</tr>
<tr>
<td>import</td>
<td>导入</td>
<td>export</td>
<td>导出</td>
</tr>
<tr>
<td>split</td>
<td>分割</td>
<td>merge</td>
<td>合并</td>
</tr>
<tr>
<td>inject</td>
<td>注入</td>
<td>extract</td>
<td>提取</td>
</tr>
<tr>
<td>attach</td>
<td>附着</td>
<td>detach</td>
<td>脱离</td>
</tr>
<tr>
<td>bind</td>
<td>绑定</td>
<td>separate</td>
<td>分离</td>
</tr>
<tr>
<td>view</td>
<td>查看</td>
<td>browse</td>
<td>浏览</td>
</tr>
<tr>
<td>edit</td>
<td>编辑</td>
<td>modify</td>
<td>修改</td>
</tr>
<tr>
<td>select</td>
<td>选取</td>
<td>mark</td>
<td>标记</td>
</tr>
<tr>
<td>copy</td>
<td>复制</td>
<td>paste</td>
<td>粘贴</td>
</tr>
<tr>
<td>undo</td>
<td>撤销</td>
<td>redo</td>
<td>重做</td>
</tr>
<tr>
<td>insert</td>
<td>插入</td>
<td>delete</td>
<td>移除</td>
</tr>
<tr>
<td>add</td>
<td>加入</td>
<td>append</td>
<td>添加</td>
</tr>
<tr>
<td>clean</td>
<td>清理</td>
<td>clear</td>
<td>清除</td>
</tr>
<tr>
<td>index</td>
<td>索引</td>
<td>sort</td>
<td>排序</td>
</tr>
<tr>
<td>find</td>
<td>查找</td>
<td>search</td>
<td>搜索</td>
</tr>
<tr>
<td>increase</td>
<td>增加</td>
<td>decrease</td>
<td>减少</td>
</tr>
<tr>
<td>play</td>
<td>播放</td>
<td>pause</td>
<td>暂停</td>
</tr>
<tr>
<td>launch</td>
<td>启动</td>
<td>run</td>
<td>运行</td>
</tr>
<tr>
<td>compile</td>
<td>编译</td>
<td>execute</td>
<td>执行</td>
</tr>
<tr>
<td>debug</td>
<td>调试</td>
<td>trace</td>
<td>跟踪</td>
</tr>
<tr>
<td>observe</td>
<td>观察</td>
<td>listen</td>
<td>监听</td>
</tr>
<tr>
<td>build</td>
<td>构建</td>
<td>publish</td>
<td>发布</td>
</tr>
<tr>
<td>input</td>
<td>输入</td>
<td>output</td>
<td>输出</td>
</tr>
<tr>
<td>encode</td>
<td>编码</td>
<td>decode</td>
<td>解码</td>
</tr>
<tr>
<td>encrypt</td>
<td>加密</td>
<td>decrypt</td>
<td>解密</td>
</tr>
<tr>
<td>compress</td>
<td>压缩</td>
<td>decompress</td>
<td>解压缩</td>
</tr>
<tr>
<td>pack</td>
<td>打包</td>
<td>unpack</td>
<td>解包</td>
</tr>
<tr>
<td>parse</td>
<td>解析</td>
<td>emit</td>
<td>生成</td>
</tr>
<tr>
<td>connect</td>
<td>连接</td>
<td>disconnect</td>
<td>断开</td>
</tr>
<tr>
<td>send</td>
<td>发送</td>
<td>receive</td>
<td>接收</td>
</tr>
<tr>
<td>download</td>
<td>下载</td>
<td>upload</td>
<td>上传</td>
</tr>
<tr>
<td>refresh</td>
<td>刷新</td>
<td>sync</td>
<td>同步</td>
</tr>
<tr>
<td>update</td>
<td>更新</td>
<td>revert</td>
<td>复原</td>
</tr>
<tr>
<td>lock</td>
<td>锁定</td>
<td>unlock</td>
<td>解锁</td>
</tr>
<tr>
<td>checkOut</td>
<td>签出</td>
<td>checkIn</td>
<td>签入</td>
</tr>
<tr>
<td>submit</td>
<td>提交</td>
<td>commit</td>
<td>交付</td>
</tr>
<tr>
<td>push</td>
<td>推</td>
<td>pull</td>
<td>拉</td>
</tr>
<tr>
<td>expand</td>
<td>展开</td>
<td>collapse</td>
<td>折叠</td>
</tr>
<tr>
<td>begin</td>
<td>起始</td>
<td>end</td>
<td>结束</td>
</tr>
<tr>
<td>start</td>
<td>开始</td>
<td>finish</td>
<td>完成</td>
</tr>
<tr>
<td>enter</td>
<td>进入</td>
<td>exit</td>
<td>退出</td>
</tr>
<tr>
<td>abort</td>
<td>放弃</td>
<td>quit</td>
<td>离开</td>
</tr>
<tr>
<td>obsolete</td>
<td>废弃</td>
<td>depreciate</td>
<td>废旧</td>
</tr>
<tr>
<td>collect</td>
<td>收集</td>
<td>aggregate</td>
<td>聚集</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>基础开发</category>
      </categories>
      <tags>
        <tag>基础开发</tag>
        <tag>前端开发</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工作手册</title>
    <url>/2019/07/23/%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="推荐工具与索引"><a href="#推荐工具与索引" class="headerlink" title="推荐工具与索引"></a>推荐工具与索引</h2><p><a href="https://www.docschina.org/">印记中文 - 前端开发文档索引</a></p>
<p><a href="https://devdocs.io/">代码片段速查</a></p>
<p><a href="https://www.jsdelivr.com/">jsDelivr CDN</a></p>
<span id="more"></span>

<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><p>建议使用 Google 搜索作为常用搜索引擎</p>
<h3 id="markdown-文档"><a href="#markdown-文档" class="headerlink" title="markdown 文档"></a>markdown 文档</h3><p>推荐使用 <code>vscode</code> 用于 markdown 文档编写, 配合 <a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">prettier 插件</a> 用于文档格式化</p>
<p><a href="https://www.jianshu.com/p/b03a8d7b1719">markdown 语法</a></p>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p><a href="https://git-scm.com/book/zh/v2">git 官方文档</a></p>
<p><a href="https://backlog.com/git-tutorial/cn/">git 教程</a></p>
<a href="/2021/04/29/Git-%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/" title="Git 使用规范">Git使用规范</a>

<h3 id="Terminal-命令行"><a href="#Terminal-命令行" class="headerlink" title="Terminal 命令行"></a>Terminal 命令行</h3><p>推荐使用 <code>git bash</code> 替换 windows 自带命令行, 并集成至编辑器中</p>
<a href="/2019/07/25/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="Linux 常用命令">Linux-常用命令</a>

<h3 id="Chrome-开发者工具"><a href="#Chrome-开发者工具" class="headerlink" title="Chrome 开发者工具"></a>Chrome 开发者工具</h3><p><a href="https://developers.google.com/web/tools/chrome-devtools/?hl=zh-cn">Chrome 开发者工具</a></p>
<p><a href="https://developers.google.com/web/tools/chrome-devtools/remote-debugging/?hl=zh-cn">Android 设备的远程调试</a></p>
<h3 id="CI-x2F-CD"><a href="#CI-x2F-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h3><p>公司根据代码仓库类型设置需要集成的 CI&#x2F;CD 服务.</p>
<p>现在使用的是 <code>Gitea</code> 代码仓库服务配合 <a href="https://github.com/drone/drone">Drone CI</a> 完成产品的自动构建与发放.</p>
<a href="/2021/04/29/CI-CD-%E8%AF%B4%E6%98%8E/" title="CI&#x2F;CD 说明">CI&#x2F;CD 说明</a>
<p><a href="https://docs.gitlab.com/ee/ci/">GitLab CI&#x2F;CD</a><br><a href="https://blog.51cto.com/flyfish225/2156602">GitLab CI&#x2F;CD 配置管理</a><br><a href="https://docs.drone.io/">Drone CI 文档</a></p>
<h2 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h2><h3 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h3><p><a href="https://zh.javascript.info/">现代 Javascript 教程</a></p>
<h3 id="ES6-语法"><a href="#ES6-语法" class="headerlink" title="ES6 语法"></a>ES6 语法</h3><p><a href="http://es6.ruanyifeng.com/">ECMAScript 6 入门</a></p>
<h3 id="Promise-与异步函数"><a href="#Promise-与异步函数" class="headerlink" title="Promise 与异步函数"></a>Promise 与异步函数</h3><p><a href="https://developers.google.com/web/fundamentals/primers/promises?hl=zh-cn">JavaScript Promise 简介</a></p>
<p><a href="https://developers.google.com/web/fundamentals/primers/async-functions?hl=zh-cn">异步函数 - 提高 Promise 的易用性</a></p>
<h3 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h3><p>Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox">flex 布局</a></p>
<p><a href="https://yoksel.github.io/flex-cheatsheet">flexbox 示例</a></p>
<h3 id="yarn-包管理器"><a href="#yarn-包管理器" class="headerlink" title="yarn 包管理器"></a>yarn 包管理器</h3><p>快速、可靠、安全的依赖管理。</p>
<p><a href="https://yarnpkg.com/zh-Hant/">yarn 包管理器</a></p>
<h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p>IndexedDB 是一种低级 API，用于客户端存储大量结构化数据(包括, 文件&#x2F; blobs)。该 API 使用索引来实现对该数据的高性能搜索</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">IndexedDB</a></p>
<p>在<code>数据量不大</code>的情况, 一般使用 localForage 简化 indexedDB 操作. 对于需要大量数据储存(<code>&gt;100MB</code>)的网页, 最好使用原生 indexedDB, localForage 存在单个键值对最大容量限制(128M)</p>
<p><a href="http://localforage.docschina.org/">localForage</a></p>
<h3 id="eslint-规范"><a href="#eslint-规范" class="headerlink" title="eslint 规范"></a>eslint 规范</h3><p>ESLint - 可组装的 JavaScript 检查工具</p>
<p>项目一般使用 airbnb + eslint-plugin-vue 作为格式要求</p>
<p><a href="https://github.com/lin-123/javascript">Airbnb eslint config</a></p>
<p><a href="https://cn.vuejs.org/v2/style-guide/">Vue 风格指南</a></p>
<h3 id="vue-全家桶"><a href="#vue-全家桶" class="headerlink" title="vue 全家桶"></a>vue 全家桶</h3><p><a href="https://cn.vuejs.org/v2/guide/">Vue.js</a></p>
<p><a href="https://cli.vuejs.org/zh/">Vue CLI</a></p>
<p><a href="https://router.vuejs.org/zh/">Vue Router</a></p>
<p><a href="https://vuex.vuejs.org/zh/">Vuex</a></p>
<p><a href="https://github.com/vuejs/awesome-vue">Vue 资源</a></p>
<h3 id="react-全家桶-了解"><a href="#react-全家桶-了解" class="headerlink" title="react 全家桶(了解)"></a>react 全家桶(了解)</h3><p><a href="https://react.docschina.org/">react</a></p>
<p><a href="https://facebook.github.io/create-react-app/docs/getting-started">Create React App</a></p>
<p><a href="https://reacttraining.com/react-router/web/guides/quick-start">react router</a></p>
<p><a href="https://cn.redux.js.org/">redux</a></p>
<p><a href="https://medium.freecodecamp.org/the-react-handbook-b71c27b0a795">The React Handbook</a> (推荐阅读)</p>
<p><a href="https://ant-design.gitee.io/index-cn">antd</a></p>
<h3 id="service-worker-了解"><a href="#service-worker-了解" class="headerlink" title="service worker (了解)"></a>service worker (了解)</h3><p>Service Worker 是浏览器在后台独立于网页运行的脚本，它可以用于增强页面的离线功能</p>
<p><a href="https://developers.google.com/web/fundamentals/primers/service-workers/?hl=zh-cn">Service Worker：简介</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">Service Worker API</a></p>
<p>Workbox 是谷歌开发的 Service Worker 工具, 通常使用 workbox-webpack-plugin 与现有配置整合打包</p>
<p><a href="https://developers.google.com/web/tools/workbox/">Workbox</a></p>
<p><a href="https://webpack.docschina.org/guides/progressive-web-application/">Workbox-webpack-plugin</a></p>
<h3 id="性能优化-强烈建议完整阅读"><a href="#性能优化-强烈建议完整阅读" class="headerlink" title="性能优化(强烈建议完整阅读)"></a>性能优化(强烈建议完整阅读)</h3><p>谷歌推荐的 web 开发性能优化方法 <a href="https://developers.google.com/web/fundamentals/performance/why-performance-matters/">Web Fundamentals performance</a></p>
<h2 id="地理信息系统与地图理论"><a href="#地理信息系统与地图理论" class="headerlink" title="地理信息系统与地图理论"></a>地理信息系统与地图理论</h2><h3 id="GIS-与-webGIS"><a href="#GIS-与-webGIS" class="headerlink" title="GIS 与 webGIS"></a>GIS 与 webGIS</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F">地理信息系统</a></p>
<p><a href="http://enterprise.arcgis.com/zh-cn/server/latest/create-web-apps/windows/about-web-gis.htm">webGIS</a></p>
<h3 id="GeoJSON-格式"><a href="#GeoJSON-格式" class="headerlink" title="GeoJSON 格式"></a>GeoJSON 格式</h3><p>GeoJson 格式是常用的 web 端地理信息数据格式, 通常用于地理信息数据的绘制</p>
<p><a href="https://www.oschina.net/translate/geojson-spec">GeoJson 格式</a></p>
<h3 id="Mapbox-gl"><a href="#Mapbox-gl" class="headerlink" title="Mapbox-gl"></a>Mapbox-gl</h3><p>Mapbox-gl 是一个使用 webGL 用于地图绘制的库, 主要包括地图控制与地图样式绘制两个部分</p>
<p><a href="https://docs.mapbox.com/mapbox-gl-js/api/">Mapbox GL JS API</a></p>
<p><a href="https://docs.mapbox.com/mapbox-gl-js/style-spec/">样式配置手册</a></p>
<p>具体的样式操作与地图编辑可以使用 <a href="https://gitlab.com/signp/mapbox-style-editor">mapbox-style-editor</a> 仓库进行练习</p>
<h3 id="Turf-js-了解"><a href="#Turf-js-了解" class="headerlink" title="Turf.js (了解)"></a>Turf.js (了解)</h3><p>地理信息数据分析处理库, 可以借鉴相应的地理信息算法</p>
<p><a href="https://github.com/Turfjs/turf">Turf.js</a></p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发人员能力要求</title>
    <url>/2021/04/29/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E8%83%BD%E5%8A%9B%E8%A6%81%E6%B1%82/</url>
    <content><![CDATA[<h2 id="基础要求"><a href="#基础要求" class="headerlink" title="基础要求"></a>基础要求</h2><h3 id="Git-版本控制"><a href="#Git-版本控制" class="headerlink" title="Git - 版本控制"></a>Git - 版本控制</h3><ul>
<li>基本操作</li>
<li>分支管理</li>
<li>日志规范</li>
</ul>
<p><a href="https://backlog.com/git-tutorial/cn/">Git 教程</a></p>
<h3 id="bash-命令行终端"><a href="#bash-命令行终端" class="headerlink" title="bash - 命令行终端"></a>bash - 命令行终端</h3><ul>
<li>常用功能</li>
<li>Windows 与 Linux 终端使用区别</li>
</ul>
<a href="/2019/07/25/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="Linux 常用命令">Linux 常用命令</a>

<span id="more"></span>

<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><a href="/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构">数据结构</a>

<a href="/2019/07/24/%E7%AE%97%E6%B3%95/" title="算法基础">算法</a>

<h3 id="HTTP-amp-HTTPS"><a href="#HTTP-amp-HTTPS" class="headerlink" title="HTTP &amp; HTTPS"></a>HTTP &amp; HTTPS</h3><ul>
<li>常用的 REST API 类型与功能</li>
<li>Post 和 Get 的区别</li>
<li>TLS 与加密</li>
<li>常见状态码</li>
</ul>
<a href="/2019/07/24/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" title="网络基础">网络基础</a>

<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><ul>
<li>通用 utf8</li>
<li>windows 下更改字符编码</li>
</ul>
<h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul>
<li>常用的浏览器内核</li>
<li>HTML 语义化</li>
</ul>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul>
<li>CSS 盒子模型</li>
</ul>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul>
<li>数据类型</li>
<li>原型, 原型链</li>
<li>闭包</li>
<li>ajax</li>
<li>异步编程</li>
<li>跨域</li>
<li>ECMAScript6 与兼容处理</li>
</ul>
<h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><h2 id="现代前端开发"><a href="#现代前端开发" class="headerlink" title="现代前端开发"></a>现代前端开发</h2><h3 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h3><ul>
<li>npm</li>
<li>yarn</li>
<li>常用命令</li>
</ul>
<h3 id="css-预处理器"><a href="#css-预处理器" class="headerlink" title="css 预处理器"></a>css 预处理器</h3><ul>
<li>sass&#x2F;scss</li>
<li>less</li>
<li>stylus</li>
</ul>
<h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><ul>
<li>webpack</li>
<li>webpack 配置相关</li>
</ul>
<h3 id="lint-格式化工具"><a href="#lint-格式化工具" class="headerlink" title="lint - 格式化工具"></a>lint - 格式化工具</h3><ul>
<li>eslint</li>
<li>prettier</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>单元测试</li>
<li>集成测试</li>
<li>功能测试</li>
<li>jest</li>
</ul>
<h3 id="PWA-应用"><a href="#PWA-应用" class="headerlink" title="PWA 应用"></a>PWA 应用</h3><ul>
<li>localStorage</li>
<li>indexedDB</li>
<li>service worker</li>
<li>web sockets</li>
</ul>
<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><ul>
<li>MVVM</li>
<li>生命周期</li>
<li>双向绑定原理</li>
<li>参数传递</li>
<li>SPA(单页面应用)</li>
</ul>
<h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><ul>
<li>目的与意义</li>
<li>state, mutations, getters, actions</li>
</ul>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ul>
<li>history &amp; hash</li>
<li>动态路由</li>
<li>路由懒加载</li>
</ul>
<h2 id="评分表"><a href="#评分表" class="headerlink" title="评分表"></a>评分表</h2><table>
<thead>
<tr>
<th>项目</th>
<th>类别</th>
<th>权重</th>
<th>评分</th>
</tr>
</thead>
<tbody><tr>
<td>基础技能</td>
<td>git</td>
<td>0.025</td>
<td></td>
</tr>
<tr>
<td>基础技能</td>
<td>terminal</td>
<td>0.025</td>
<td></td>
</tr>
<tr>
<td>基础技能</td>
<td>debug</td>
<td>0.05</td>
<td></td>
</tr>
<tr>
<td>前端基础</td>
<td>CSS</td>
<td>0.05</td>
<td></td>
</tr>
<tr>
<td>前端基础</td>
<td>JS</td>
<td>0.2</td>
<td></td>
</tr>
<tr>
<td>前端工具</td>
<td>package</td>
<td>0.05</td>
<td></td>
</tr>
<tr>
<td>前端工具</td>
<td>webpack</td>
<td>0.05</td>
<td></td>
</tr>
<tr>
<td>前端工具</td>
<td>lint</td>
<td>0.025</td>
<td></td>
</tr>
<tr>
<td>前端工具</td>
<td>test</td>
<td>0.025</td>
<td></td>
</tr>
<tr>
<td>前端工具</td>
<td>PWA</td>
<td>0.05</td>
<td></td>
</tr>
<tr>
<td>前端框架</td>
<td>vue</td>
<td>0.15</td>
<td></td>
</tr>
<tr>
<td>算法</td>
<td>sort</td>
<td>0.05</td>
<td></td>
</tr>
<tr>
<td>算法</td>
<td>geo</td>
<td>0.05</td>
<td></td>
</tr>
<tr>
<td>沟通能力</td>
<td></td>
<td>0.1</td>
<td></td>
</tr>
<tr>
<td>学习能力</td>
<td></td>
<td>0.1</td>
<td></td>
</tr>
<tr>
<td>总分</td>
<td></td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发配置规范</title>
    <url>/2019/06/11/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><table>
<thead>
<tr>
<th>适用性</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><strong>强烈推荐</strong></td>
<td>VSCode</td>
</tr>
<tr>
<td><strong>可用</strong></td>
<td>jetBrain 的大型 IDE, 如 webStorm 等配合相应插件</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="vscode-插件与配置"><a href="#vscode-插件与配置" class="headerlink" title="vscode 插件与配置"></a>vscode 插件与配置</h2><table>
<thead>
<tr>
<th>适用性</th>
<th>插件名称</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><strong>必须</strong></td>
<td>ESlint</td>
<td>用于针对需要进行代码标准检查的构建项目的静态检查</td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>Git Graph</td>
<td>用于查看代码记录与管理的 git 工具</td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>Prettier</td>
<td>用于通常项目的代码格式化, 使用默认配置</td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>Code Spell Checker</td>
<td>用于对英文拼写进行检查提示</td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>Todo Tree</td>
<td>TODO 标记</td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>Vetur</td>
<td>Vue 官方 vscode 插件</td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>Vue VSCode Snippets</td>
<td>vue 代码补全</td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>ES7 React snippets</td>
<td>ES7, react 代码片段补全</td>
</tr>
<tr>
<td><strong>推荐</strong></td>
<td>Bracket Pair Colorizer 2</td>
<td>括号高亮</td>
</tr>
<tr>
<td><strong>推荐</strong></td>
<td>change-case</td>
<td>名称格式转换(驼峰, 首字母大写, 横线连接)</td>
</tr>
<tr>
<td><strong>推荐</strong></td>
<td>Markdown Preview Enhanced</td>
<td>markdown 预览增强</td>
</tr>
</tbody></table>
<h3 id="vscode-settings-json"><a href="#vscode-settings-json" class="headerlink" title="vscode settings.json"></a>vscode settings.json</h3><p>复制下面 json 配置至 settings.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;terminal.integrated.shell.windows&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Program Files/Git/bin/bash.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;eslint.validate&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;javascript&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;javascriptreact&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;typescript&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;vue&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;html&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;files.eol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\n&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;files.autoSave&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onFocusChange&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;editor.wordWrap&quot;</span><span class="punctuation">:</span> <span class="string">&quot;on&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;editor.tabSize&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;editor.codeActionsOnSave&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;source.fixAll&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;[vue]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;octref.vetur&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;cSpell.userWords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;Noto&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;Unmount&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;antd&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;axios&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;concat&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;errcode&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;fontstack&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;geojson&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;gitignore&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;gitlab&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;keyframes&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;kubernetes&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;linestring&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;mapbox&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;mapboxgl&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;nginx&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;nowrap&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;pannellum&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;polyfills&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;promisify&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;qrcode&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;readwrite&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;rgba&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;signp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;statechange&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;stringify&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;swiper&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;touchend&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;touchmove&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;touchstart&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;unproject&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;updatefound&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;vetur&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;vuepress&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;vuex&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;webview&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;wechat&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;cSpell.enableFiletypes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;asciidoc&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;csharp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;css&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;go&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;handlebars&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;html&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;jade&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;javascript&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;javascriptreact&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;json&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;latex&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;less&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;markdown&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;php&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;plaintext&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;pub&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;python&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;restructuredtext&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;rust&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;scss&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;typescript&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;typescriptreact&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;vue&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;yml&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h2 id="npm-x2F-yarn-全局安装扩展"><a href="#npm-x2F-yarn-全局安装扩展" class="headerlink" title="npm &#x2F; yarn 全局安装扩展"></a>npm &#x2F; yarn 全局安装扩展</h2><p>安装方法: <code>npm i -g XXX</code>, 尽可能使用 <code>npm</code> 而不是 <code>yarn</code> 进行全局依赖的安装以便于全局依赖的管理</p>
<table>
<thead>
<tr>
<th>适用性</th>
<th>插件名称</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><strong>必须</strong></td>
<td>yarn</td>
<td>更快更好用的 npm 工具, 能够保证版本的统一性</td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>serve 或 http-server</td>
<td>在本地方便的启动一个本地 web server, 针对所有需要进行本地开发与测试的项目目录, 包括 Vue, React 的构建目录</td>
</tr>
<tr>
<td><strong>可用</strong></td>
<td>@vue&#x2F;cli</td>
<td>vue 命令行</td>
</tr>
<tr>
<td><strong>禁止</strong></td>
<td>cnpm</td>
<td>国内的 npm 工具, 要求使用 yarn 用于 node 包管理, 能够保证版本的统一性</td>
</tr>
</tbody></table>
<h2 id="npm-镜像配置"><a href="#npm-镜像配置" class="headerlink" title="npm 镜像配置"></a>npm 镜像配置</h2><h3 id="npm-换源"><a href="#npm-换源" class="headerlink" title="npm 换源"></a>npm 换源</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改源地址为淘宝 NPM 镜像</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复源地址为官方源</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure>

<p>在设置 <code>registry</code> 至淘宝镜像后运行 <code>npm i -g mirror-config-china</code> 安装镜像配置</p>
<h3 id="npmrc-配置"><a href="#npmrc-配置" class="headerlink" title=".npmrc 配置"></a>.npmrc 配置</h3><p><code>mirror-config-china</code> 会自动完成下列配置</p>
<p>可以通过修改 <code>~/.npmrc</code> 文件指定 npm 源与相关包的镜像, 常用配置如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm 源</span></span><br><span class="line">registry=https://registry.npm.taobao.org/</span><br><span class="line"><span class="comment"># electron 镜像源</span></span><br><span class="line">electron_mirror=https://npm.taobao.org/mirrors/electron/</span><br><span class="line"><span class="comment"># sass 镜像源</span></span><br><span class="line">sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</span><br><span class="line"><span class="comment"># puppeteer 镜像源</span></span><br><span class="line">puppeteer_download_host=https://npm.taobao.org/mirrors</span><br></pre></td></tr></table></figure>

<h2 id="git-配置与使用"><a href="#git-配置与使用" class="headerlink" title="git 配置与使用"></a>git 配置与使用</h2><h3 id="ssh-key-生成方法"><a href="#ssh-key-生成方法" class="headerlink" title="ssh key 生成方法"></a>ssh key 生成方法</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在本地查看email地址</span></span><br><span class="line">$ git config --list</span><br><span class="line"><span class="comment">#如果没有，需要运行</span></span><br><span class="line">$ git config --global user.name test123</span><br><span class="line">$ git config --global user.email test123@qq.com</span><br><span class="line"><span class="comment"># 设置换行符为 LF</span></span><br><span class="line">git config --global core.autocrlf input</span><br><span class="line">git config --global core.eol lf</span><br><span class="line"><span class="comment"># 设置 git 对文件名大小写敏感</span></span><br><span class="line">git config --global core.ignorecase <span class="literal">false</span></span><br><span class="line"><span class="comment">#在本地根目录生成公钥:</span></span><br><span class="line">$ <span class="built_in">cd</span></span><br><span class="line">$ ssh-keygen -t rsa -C test123@qq.com</span><br></pre></td></tr></table></figure>

<p>复制生成的公钥 <code>id_rsa.pub</code> 至个人设置 SSH 密钥处或者服务器 <code>~/.ssh/authorized_keys</code> 文件中.</p>
<h3 id="使用前须知"><a href="#使用前须知" class="headerlink" title="使用前须知"></a>使用前须知</h3><ol>
<li>管理员会提供登录使用的 <code>Gitea</code> 账号密码</li>
<li>复制本地 ssh key 至 Gitea 账号中<br><img src="/ssh.jpg" alt="ssh"></li>
<li>git clone 代码仓库至本地<br><img src="/clone.jpg" alt="git clone"></li>
</ol>
<p>如上图所示, 复制项目 git ssh 地址, 在项目目录下打开命令行, 输入</p>
<p><code>git clone ssh://git@XXXXXXXXX.git</code></p>
<h2 id="代码与书写规范"><a href="#代码与书写规范" class="headerlink" title="代码与书写规范"></a>代码与书写规范</h2><h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><p>此配置已写在 <a href="#vscode-%E6%8F%92%E4%BB%B6%E4%B8%8E%E9%85%8D%E7%BD%AE">vscode settings.json</a> 配置中</p>
<table>
<thead>
<tr>
<th>适用性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>必须</strong></td>
<td>使用 <code>prettier</code> 用作代码格式化工具, 使用默认配置并整合 <code>eslint</code></td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>代码使用空格进行缩进, 且缩进设置为 2 个空格</td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>对于包含 <code>eslint</code> 配置的项目, 必须保证 <code>eslint</code> 的正常运行与自动格式化, 所有代码编写规范均以 <code>eslint</code> 为准</td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>使用 <code>git bash</code> 替换 windows 自带命令行工具</td>
</tr>
</tbody></table>
<h3 id="注释与说明"><a href="#注释与说明" class="headerlink" title="注释与说明"></a>注释与说明</h3><table>
<thead>
<tr>
<th>适用性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>必须</strong></td>
<td>变量的定义, 函数定义以及方法中较难理解或者复杂逻辑的地方<strong>必须</strong>存在注释</td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>在文档编写中<strong>汉字</strong>与英文, 数字字符串之间增加<strong>空格</strong>, 以便复制与更改</td>
</tr>
<tr>
<td><strong>推荐</strong></td>
<td>函数的注释使用 <code>JSDoc</code> 进行标注, 通常包括简介, 输入的格式与说明, 输出的说明, 使用示例等</td>
</tr>
<tr>
<td><strong>禁止</strong></td>
<td><strong>禁止</strong>在任何地方(<strong>包括注释</strong>)出现汉字标点, 汉字输入法的标点<strong>必须</strong>设置成英文输出</td>
</tr>
</tbody></table>
<h3 id="项目配置规范"><a href="#项目配置规范" class="headerlink" title="项目配置规范"></a>项目配置规范</h3><table>
<thead>
<tr>
<th>适用性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>必须</strong></td>
<td>对于 <code>Vue</code> 以及 <code>React</code> 等构建项目, 注意保留 <code>eslint</code> 静态检查与 <code>babel</code> 代码优化输出</td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>在硬件上运行的页面输出时需要保留 <a href="https://webpack.docschina.org/configuration/devtool/">sourceMap</a> 输出文件以便调试</td>
</tr>
<tr>
<td><strong>禁止</strong></td>
<td>服务器上运行的网页输出时 <strong>禁止</strong> 输出 sourceMap 以防止暴露原始代码</td>
</tr>
<tr>
<td><strong>禁止</strong></td>
<td>非构建项目或者无兼容处理时, <strong>禁止</strong>使用 ES6 写法, 源码可能因为没有 <code>polyfill</code> 而无法运行</td>
</tr>
</tbody></table>
<h3 id="文件与目录命名规范"><a href="#文件与目录命名规范" class="headerlink" title="文件与目录命名规范"></a>文件与目录命名规范</h3><table>
<thead>
<tr>
<th>适用性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>禁止</strong></td>
<td><strong>禁止</strong>在任何地方使用汉字命名, 包括<strong>说明文档</strong></td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>项目名字<strong>必须</strong>使用 <code>横线连接 (kebab-case)</code>, <strong>禁止</strong> 使用<code>驼峰格式</code>, <code>大写字母开头</code>, <code>下划线连接</code> 作为项目名字</td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>文件夹名字<strong>必须</strong>使用 <code>横线连接 (kebab-case)</code>, <strong>禁止</strong> 使用<code>驼峰格式</code>, <code>大写字母开头</code>, <code>下划线连接</code> 作为文件夹名字</td>
</tr>
<tr>
<td><strong>必须</strong></td>
<td>所有文件命名要求使用 <code>横线连接 (kebab-case)</code>, <strong>禁止</strong> 使用<code>驼峰格式</code>, <code>大写字母开头</code>, <code>下划线连接</code> 作为文件夹名字</td>
</tr>
</tbody></table>
<h3 id="方法命名规范"><a href="#方法命名规范" class="headerlink" title="方法命名规范"></a>方法命名规范</h3><p>见 <a href="/2021/04/29/%E4%BB%A3%E7%A0%81%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/" title="代码命名规范">代码命名规范</a></p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>栈是一个线性结构，在计算机中是一个相当常见的数据结构。</p>
<p>栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则</p>
<p><img src="/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/stack.png"></p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>每种数据结构都可以用很多种方式来实现，其实可以把栈看成是数组的一个子集，所以这里使用数组来实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">push</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="title function_">getCount</span>() - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getCount</span>() === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>选取了 <a href="https://leetcode.com/problems/valid-parentheses/submissions/1">LeetCode 上序号为 20 的题目</a></p>
<p>题意是匹配括号，可以通过栈的特性来完成这道题目</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;</span><br><span class="line">    <span class="string">&quot;(&quot;</span>: -<span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;)&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;[&quot;</span>: -<span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;]&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;&#123;&quot;</span>: -<span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;&#125;&quot;</span>: <span class="number">3</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[s[i]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(s[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> last = stack.<span class="title function_">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (map[last] + map[s[i]] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。</p>
<p><img src="/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/queue.png"></p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>这里会讲解两种实现队列的方式，分别是单链队列和循环队列。</p>
<h3 id="单链队列"><a href="#单链队列" class="headerlink" title="单链队列"></a>单链队列</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">enQueue</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">deQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getHeader</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getLength</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getLength</span>() === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 O(1) 的时间复杂度。</p>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SqQueue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(length + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 队头</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 队尾</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">last</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前队列大小</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">enQueue</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断队尾 + 1 是否为队头</span></span><br><span class="line">    <span class="comment">// 如果是就代表需要扩容数组</span></span><br><span class="line">    <span class="comment">// % this.queue.length 是为了防止数组越界</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">first</span> === (<span class="variable language_">this</span>.<span class="property">last</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">resize</span>(<span class="variable language_">this</span>.<span class="title function_">getLength</span>() * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">last</span>] = item;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">last</span> = (<span class="variable language_">this</span>.<span class="property">last</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">deQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">first</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">first</span>] = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first</span> = (<span class="variable language_">this</span>.<span class="property">first</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span>--;</span><br><span class="line">    <span class="comment">// 判断当前队列大小是否过小</span></span><br><span class="line">    <span class="comment">// 为了保证不浪费空间，在队列空间等于总长度四分之一时</span></span><br><span class="line">    <span class="comment">// 且不为 2 时缩小总长度为当前的一半</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">size</span> === <span class="variable language_">this</span>.<span class="title function_">getLength</span>() / <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">getLength</span>() / <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">resize</span>(<span class="variable language_">this</span>.<span class="title function_">getLength</span>() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getHeader</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">first</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getLength</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span> === <span class="variable language_">this</span>.<span class="property">last</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">resize</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> q = <span class="keyword">new</span> <span class="title class_">Array</span>(length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      q[i] = <span class="variable language_">this</span>.<span class="property">queue</span>[(i + <span class="variable language_">this</span>.<span class="property">first</span>) % <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = q;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">last</span> = <span class="variable language_">this</span>.<span class="property">size</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p>
<p><img src="/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/linkedList.png"></p>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>单向链表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">v, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = v;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 链表长度</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 虚拟头部</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dummyNode</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">find</span>(<span class="params">header, index, currentIndex</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === currentIndex) <span class="keyword">return</span> header;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">find</span>(header.<span class="property">next</span>, index, currentIndex + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addNode</span>(<span class="params">v, index</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">checkIndex</span>(index);</span><br><span class="line">    <span class="comment">// 当往链表末尾插入时，prev.next 为空</span></span><br><span class="line">    <span class="comment">// 其他情况时，因为要插入节点，所以插入的节点</span></span><br><span class="line">    <span class="comment">// 的 next 应该是 prev.next</span></span><br><span class="line">    <span class="comment">// 然后设置 prev.next 为插入的节点</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="variable language_">this</span>.<span class="title function_">find</span>(<span class="variable language_">this</span>.<span class="property">dummyNode</span>, index, <span class="number">0</span>);</span><br><span class="line">    prev.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(v, prev.<span class="property">next</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">    <span class="keyword">return</span> prev.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">insertNode</span>(<span class="params">v, index</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">addNode</span>(v, index);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addToFirst</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">addNode</span>(v, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addToLast</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">addNode</span>(v, <span class="variable language_">this</span>.<span class="property">size</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeNode</span>(<span class="params">index, isLast</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">checkIndex</span>(index);</span><br><span class="line">    index = isLast ? index - <span class="number">1</span> : index;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="variable language_">this</span>.<span class="title function_">find</span>(<span class="variable language_">this</span>.<span class="property">dummyNode</span>, index, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> node = prev.<span class="property">next</span>;</span><br><span class="line">    prev.<span class="property">next</span> = node.<span class="property">next</span>;</span><br><span class="line">    node.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span>--;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeFirstNode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeLastNode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(<span class="variable language_">this</span>.<span class="property">size</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">checkIndex</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&quot;Index error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getNode</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">checkIndex</span>(index);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">find</span>(<span class="variable language_">this</span>.<span class="property">dummyNode</span>, index, <span class="number">0</span>).<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。</p>
<p>二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树。</p>
<p><img src="/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/tree.png"></p>
<h2 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h2><p>二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小。</p>
<p>这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率。</p>
<p><img src="/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/BST.png"></p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addNode</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="variable language_">this</span>.<span class="title function_">_addChild</span>(<span class="variable language_">this</span>.<span class="property">root</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加节点时，需要比较添加的节点值和当前</span></span><br><span class="line">  <span class="comment">// 节点值的大小</span></span><br><span class="line">  <span class="title function_">_addChild</span>(<span class="params">node, v</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">value</span> &gt; v) &#123;</span><br><span class="line">      node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">_addChild</span>(node.<span class="property">left</span>, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">value</span> &lt; v) &#123;</span><br><span class="line">      node.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">_addChild</span>(node.<span class="property">right</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是最基本的二分搜索树实现，接下来实现树的遍历。</p>
<p>对于树的遍历来说，有三种遍历方法，分别是先序遍历、中序遍历、后序遍历。三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先序遍历可用于打印树的结构</span></span><br><span class="line"><span class="comment">// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。</span></span><br><span class="line"><span class="title function_">preTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_pre</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_pre</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_pre</span>(node.<span class="property">left</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_pre</span>(node.<span class="property">right</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历可用于排序</span></span><br><span class="line"><span class="comment">// 对于 BST 来说，中序遍历可以实现一次遍历就</span></span><br><span class="line"><span class="comment">// 得到有序的值</span></span><br><span class="line"><span class="comment">// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</span></span><br><span class="line"><span class="title function_">midTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_mid</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_mid</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_mid</span>(node.<span class="property">left</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_mid</span>(node.<span class="property">right</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历可用于先操作子节点</span></span><br><span class="line"><span class="comment">// 再操作父节点的场景</span></span><br><span class="line"><span class="comment">// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</span></span><br><span class="line"><span class="title function_">backTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_back</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_back</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_back</span>(node.<span class="property">left</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_back</span>(node.<span class="property">right</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">breadthTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> q = <span class="keyword">new</span> <span class="title class_">Queue</span>()</span><br><span class="line">  <span class="comment">// 将根节点入队</span></span><br><span class="line">  q.<span class="title function_">enQueue</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">  <span class="comment">// 循环判断队列是否为空，为空</span></span><br><span class="line">  <span class="comment">// 代表树遍历完毕</span></span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 将队首出队，判断是否有左右子树</span></span><br><span class="line">    <span class="comment">// 有的话，就先左后右入队</span></span><br><span class="line">    <span class="keyword">let</span> n = q.<span class="title function_">deQueue</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">value</span>)</span><br><span class="line">    <span class="keyword">if</span> (n.<span class="property">left</span>) q.<span class="title function_">enQueue</span>(n.<span class="property">left</span>)</span><br><span class="line">    <span class="keyword">if</span> (n.<span class="property">right</span>) q.<span class="title function_">enQueue</span>(n.<span class="property">right</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getMin</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_getMin</span>(<span class="variable language_">this</span>.<span class="property">root</span>).<span class="property">value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_getMin</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.<span class="property">left</span>) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_getMin</span>(node.<span class="property">left</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getMax</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_getMax</span>(<span class="variable language_">this</span>.<span class="property">root</span>).<span class="property">value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_getMax</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.<span class="property">right</span>) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_getMin</span>(node.<span class="property">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>向上取整和向下取整</strong>，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">floor</span>(<span class="params">v</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="title function_">_floor</span>(<span class="variable language_">this</span>.<span class="property">root</span>, v)</span><br><span class="line">  <span class="keyword">return</span> node ? node.<span class="property">value</span> : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_floor</span>(<span class="params">node, v</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">value</span> === v) <span class="keyword">return</span> v</span><br><span class="line">  <span class="comment">// 如果当前节点值还比需要的值大，就继续递归</span></span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">value</span> &gt; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_floor</span>(node.<span class="property">left</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断当前节点是否拥有右子树</span></span><br><span class="line">  <span class="keyword">let</span> right = <span class="variable language_">this</span>.<span class="title function_">_floor</span>(node.<span class="property">right</span>, v)</span><br><span class="line">  <span class="keyword">if</span> (right) <span class="keyword">return</span> right</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>排名</strong>，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 <code>size</code> 属性。该属性表示该节点下有多少子节点（包含自身）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增代码</span></span><br><span class="line"><span class="title function_">_getSize</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> node ? node.<span class="property">size</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_addChild</span>(<span class="params">node, v</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">value</span> &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.<span class="property">size</span>++</span><br><span class="line">    node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">_addChild</span>(node.<span class="property">left</span>, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">value</span> &lt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.<span class="property">size</span>++</span><br><span class="line">    node.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">_addChild</span>(node.<span class="property">right</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">select</span>(<span class="params">k</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="title function_">_select</span>(<span class="variable language_">this</span>.<span class="property">root</span>, k)</span><br><span class="line">  <span class="keyword">return</span> node ? node.<span class="property">value</span> : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_select</span>(<span class="params">node, k</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 先获取左子树下有几个节点</span></span><br><span class="line">  <span class="keyword">let</span> size = node.<span class="property">left</span> ? node.<span class="property">left</span>.<span class="property">size</span> : <span class="number">0</span></span><br><span class="line">  <span class="comment">// 判断 size 是否大于 k</span></span><br><span class="line">  <span class="comment">// 如果大于 k，代表所需要的节点在左节点</span></span><br><span class="line">  <span class="keyword">if</span> (size &gt; k) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_select</span>(node.<span class="property">left</span>, k)</span><br><span class="line">  <span class="comment">// 如果小于 k，代表所需要的节点在右节点</span></span><br><span class="line">  <span class="comment">// 注意这里需要重新计算 k，减去根节点除了右子树的节点数量</span></span><br><span class="line">  <span class="keyword">if</span> (size &lt; k) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_select</span>(node.<span class="property">right</span>, k - size - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来讲解的是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况</p>
<ul>
<li>需要删除的节点没有子树</li>
<li>需要删除的节点只有一条子树</li>
<li>需要删除的节点有左右两条树</li>
</ul>
<p>对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">delectMin</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">root</span> = <span class="variable language_">this</span>.<span class="title function_">_delectMin</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_delectMin</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="comment">// 一直递归左子树</span></span><br><span class="line">  <span class="comment">// 如果左子树为空，就判断节点是否拥有右子树</span></span><br><span class="line">  <span class="comment">// 有右子树的话就把需要删除的节点替换为右子树</span></span><br><span class="line">  <span class="keyword">if</span> ((node != <span class="literal">null</span>) &amp; !node.<span class="property">left</span>) <span class="keyword">return</span> node.<span class="property">right</span></span><br><span class="line">  node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">_delectMin</span>(node.<span class="property">left</span>)</span><br><span class="line">  <span class="comment">// 最后需要重新维护下节点的 `size`</span></span><br><span class="line">  node.<span class="property">size</span> = <span class="variable language_">this</span>.<span class="title function_">_getSize</span>(node.<span class="property">left</span>) + <span class="variable language_">this</span>.<span class="title function_">_getSize</span>(node.<span class="property">right</span>) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后讲解的就是如何删除任意节点了。对于这个操作，T.Hibbard 在 1962 年提出了解决这个难题的办法，也就是如何解决第三种情况。</p>
<p>当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。</p>
<p>你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">delect</span>(<span class="params">v</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">root</span> = <span class="variable language_">this</span>.<span class="title function_">_delect</span>(<span class="variable language_">this</span>.<span class="property">root</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_delect</span>(<span class="params">node, v</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 寻找的节点比当前节点小，去左子树找</span></span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">value</span> &lt; v) &#123;</span><br><span class="line">    node.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">_delect</span>(node.<span class="property">right</span>, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">value</span> &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 寻找的节点比当前节点大，去右子树找</span></span><br><span class="line">    node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">_delect</span>(node.<span class="property">left</span>, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进入这个条件说明已经找到节点</span></span><br><span class="line">    <span class="comment">// 先判断节点是否拥有拥有左右子树中的一个</span></span><br><span class="line">    <span class="comment">// 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样</span></span><br><span class="line">    <span class="keyword">if</span> (!node.<span class="property">left</span>) <span class="keyword">return</span> node.<span class="property">right</span></span><br><span class="line">    <span class="keyword">if</span> (!node.<span class="property">right</span>) <span class="keyword">return</span> node.<span class="property">left</span></span><br><span class="line">    <span class="comment">// 进入这里，代表节点拥有左右子树</span></span><br><span class="line">    <span class="comment">// 先取出当前节点的后继结点，也就是取当前节点右子树的最小值</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="variable language_">this</span>.<span class="title function_">_getMin</span>(node.<span class="property">right</span>)</span><br><span class="line">    <span class="comment">// 取出最小值后，删除最小值</span></span><br><span class="line">    <span class="comment">// 然后把删除节点后的子树赋值给最小值节点</span></span><br><span class="line">    min.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">_delectMin</span>(node.<span class="property">right</span>)</span><br><span class="line">    <span class="comment">// 左子树不动</span></span><br><span class="line">    min.<span class="property">left</span> = node.<span class="property">left</span></span><br><span class="line">    node = min</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 维护 size</span></span><br><span class="line">  node.<span class="property">size</span> = <span class="variable language_">this</span>.<span class="title function_">_getSize</span>(node.<span class="property">left</span>) + <span class="variable language_">this</span>.<span class="title function_">_getSize</span>(node.<span class="property">right</span>) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>二分搜索树实际在业务中是受到限制的，因为并不是严格的 O(logN)，在极端情况下会退化成链表，比如加入一组升序的数字就会造成这种情况。</p>
<p>AVL 树改进了二分搜索树，在 AVL 树中任意节点的左右子树的高度差都不大于 1，这样保证了时间复杂度是严格的 O(logN)。基于此，对 AVL 树增加或删除节点时可能需要旋转树来达到高度的平衡。</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>因为 AVL 树是改进了二分搜索树，所以部分代码是于二分搜索树重复的，对于重复内容不作再次解析。</p>
<p>对于 AVL 树来说，添加节点会有四种情况</p>
<p><img src="/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/avl.png"></p>
<p>对于左左情况来说，新增加的节点位于节点 2 的左侧，这时树已经不平衡，需要旋转。因为搜索树的特性，节点比左节点大，比右节点小，所以旋转以后也要实现这个特性。</p>
<p>旋转之前：new &lt; 2 &lt; C &lt; 3 &lt; B &lt; 5 &lt; A，右旋之后节点 3 为根节点，这时候需要将节点 3 的右节点加到节点 5 的左边，最后还需要更新节点的高度。</p>
<p>对于右右情况来说，相反于左左情况，所以不再赘述。</p>
<p>对于左右情况来说，新增加的节点位于节点 4 的右侧。对于这种情况，需要通过两次旋转来达到目的。</p>
<p>首先对节点的左节点左旋，这时树满足左左的情况，再对节点进行一次右旋就可以达到目的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVL</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addNode</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="variable language_">this</span>.<span class="title function_">_addChild</span>(<span class="variable language_">this</span>.<span class="property">root</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_addChild</span>(<span class="params">node, v</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">value</span> &gt; v) &#123;</span><br><span class="line">      node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">_addChild</span>(node.<span class="property">left</span>, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">value</span> &lt; v) &#123;</span><br><span class="line">      node.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">_addChild</span>(node.<span class="property">right</span>, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.<span class="property">value</span> = v;</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">height</span> =</span><br><span class="line">      <span class="number">1</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="variable language_">this</span>.<span class="title function_">_getHeight</span>(node.<span class="property">left</span>), <span class="variable language_">this</span>.<span class="title function_">_getHeight</span>(node.<span class="property">right</span>));</span><br><span class="line">    <span class="keyword">let</span> factor = <span class="variable language_">this</span>.<span class="title function_">_getBalanceFactor</span>(node);</span><br><span class="line">    <span class="comment">// 当需要右旋时，根节点的左树一定比右树高度高</span></span><br><span class="line">    <span class="keyword">if</span> (factor &gt; <span class="number">1</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">_getBalanceFactor</span>(node.<span class="property">left</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_rightRotate</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当需要左旋时，根节点的左树一定比右树高度矮</span></span><br><span class="line">    <span class="keyword">if</span> (factor &lt; -<span class="number">1</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">_getBalanceFactor</span>(node.<span class="property">right</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_leftRotate</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右情况</span></span><br><span class="line">    <span class="comment">// 节点的左树比右树高，且节点的左树的右树比节点的左树的左树高</span></span><br><span class="line">    <span class="keyword">if</span> (factor &gt; <span class="number">1</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">_getBalanceFactor</span>(node.<span class="property">left</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">_leftRotate</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_rightRotate</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右左情况</span></span><br><span class="line">    <span class="comment">// 节点的左树比右树矮，且节点的右树的右树比节点的右树的左树矮</span></span><br><span class="line">    <span class="keyword">if</span> (factor &lt; -<span class="number">1</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">_getBalanceFactor</span>(node.<span class="property">right</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      node.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">_rightRotate</span>(node.<span class="property">right</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_leftRotate</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_getHeight</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> node.<span class="property">height</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_getBalanceFactor</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_getHeight</span>(node.<span class="property">left</span>) - <span class="variable language_">this</span>.<span class="title function_">_getHeight</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 节点右旋</span></span><br><span class="line">  <span class="comment">//           5                    2</span></span><br><span class="line">  <span class="comment">//         /   \                /   \</span></span><br><span class="line">  <span class="comment">//        2     6   ==&gt;       1      5</span></span><br><span class="line">  <span class="comment">//       /  \               /       /  \</span></span><br><span class="line">  <span class="comment">//      1    3             new     3    6</span></span><br><span class="line">  <span class="comment">//     /</span></span><br><span class="line">  <span class="comment">//    new</span></span><br><span class="line">  <span class="title function_">_rightRotate</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="comment">// 旋转后新根节点</span></span><br><span class="line">    <span class="keyword">let</span> newRoot = node.<span class="property">left</span>;</span><br><span class="line">    <span class="comment">// 需要移动的节点</span></span><br><span class="line">    <span class="keyword">let</span> moveNode = newRoot.<span class="property">right</span>;</span><br><span class="line">    <span class="comment">// 节点 2 的右节点改为节点 5</span></span><br><span class="line">    newRoot.<span class="property">right</span> = node;</span><br><span class="line">    <span class="comment">// 节点 5 左节点改为节点 3</span></span><br><span class="line">    node.<span class="property">left</span> = moveNode;</span><br><span class="line">    <span class="comment">// 更新树的高度</span></span><br><span class="line">    node.<span class="property">height</span> =</span><br><span class="line">      <span class="number">1</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="variable language_">this</span>.<span class="title function_">_getHeight</span>(node.<span class="property">left</span>), <span class="variable language_">this</span>.<span class="title function_">_getHeight</span>(node.<span class="property">right</span>));</span><br><span class="line">    newRoot.<span class="property">height</span> =</span><br><span class="line">      <span class="number">1</span> +</span><br><span class="line">      <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="variable language_">this</span>.<span class="title function_">_getHeight</span>(newRoot.<span class="property">left</span>), <span class="variable language_">this</span>.<span class="title function_">_getHeight</span>(newRoot.<span class="property">right</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRoot;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 节点左旋</span></span><br><span class="line">  <span class="comment">//           4                    6</span></span><br><span class="line">  <span class="comment">//         /   \                /   \</span></span><br><span class="line">  <span class="comment">//        2     6   ==&gt;       4      7</span></span><br><span class="line">  <span class="comment">//             /  \         /   \      \</span></span><br><span class="line">  <span class="comment">//            5     7      2     5      new</span></span><br><span class="line">  <span class="comment">//                   \</span></span><br><span class="line">  <span class="comment">//                    new</span></span><br><span class="line">  <span class="title function_">_leftRotate</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="comment">// 旋转后新根节点</span></span><br><span class="line">    <span class="keyword">let</span> newRoot = node.<span class="property">right</span>;</span><br><span class="line">    <span class="comment">// 需要移动的节点</span></span><br><span class="line">    <span class="keyword">let</span> moveNode = newRoot.<span class="property">left</span>;</span><br><span class="line">    <span class="comment">// 节点 6 的左节点改为节点 4</span></span><br><span class="line">    newRoot.<span class="property">left</span> = node;</span><br><span class="line">    <span class="comment">// 节点 4 右节点改为节点 5</span></span><br><span class="line">    node.<span class="property">right</span> = moveNode;</span><br><span class="line">    <span class="comment">// 更新树的高度</span></span><br><span class="line">    node.<span class="property">height</span> =</span><br><span class="line">      <span class="number">1</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="variable language_">this</span>.<span class="title function_">_getHeight</span>(node.<span class="property">left</span>), <span class="variable language_">this</span>.<span class="title function_">_getHeight</span>(node.<span class="property">right</span>));</span><br><span class="line">    newRoot.<span class="property">height</span> =</span><br><span class="line">      <span class="number">1</span> +</span><br><span class="line">      <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="variable language_">this</span>.<span class="title function_">_getHeight</span>(newRoot.<span class="property">left</span>), <span class="variable language_">this</span>.<span class="title function_">_getHeight</span>(newRoot.<span class="property">right</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRoot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>在计算机科学，<strong>trie</strong>，又称<strong>前缀树</strong>或<strong>字典树</strong>，是一种有序树，用于保存关联数组，其中的键通常是字符串。</p>
<p>简单点来说，这个结构的作用大多是为了方便搜索字符串，该树有以下几个特点</p>
<ul>
<li>根节点代表空字符串，每个节点都有 N（假如搜索英文字符，就有 26 条） 条链接，每条链接代表一个字符</li>
<li>节点不存储字符，只有路径才存储，这点和其他的树结构不同</li>
<li>从根节点开始到任意一个节点，将沿途经过的字符连接起来就是该节点对应的字符串</li>
</ul>
<p><img src="/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/trie.png">、</p>
<h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><p>总得来说 Trie 的实现相比别的树结构来说简单的很多，实现就以搜索英文字符为例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 代表每个字符经过节点的次数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">path</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 代表到该节点的字符串有几个</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">end</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 链接</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 根节点，代表空字符</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入字符串</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 获得字符先对应的索引</span></span><br><span class="line">      <span class="keyword">let</span> index = str[i].<span class="title function_">charCodeAt</span>() - <span class="string">&quot;a&quot;</span>.<span class="title function_">charCodeAt</span>();</span><br><span class="line">      <span class="comment">// 如果索引对应没有值，就创建</span></span><br><span class="line">      <span class="keyword">if</span> (!node.<span class="property">next</span>[index]) &#123;</span><br><span class="line">        node.<span class="property">next</span>[index] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      node.<span class="property">path</span> += <span class="number">1</span>;</span><br><span class="line">      node = node.<span class="property">next</span>[index];</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">end</span> += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 搜索字符串出现的次数</span></span><br><span class="line">  <span class="title function_">search</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = str[i].<span class="title function_">charCodeAt</span>() - <span class="string">&quot;a&quot;</span>.<span class="title function_">charCodeAt</span>();</span><br><span class="line">      <span class="comment">// 如果索引对应没有值，代表没有需要搜素的字符串</span></span><br><span class="line">      <span class="keyword">if</span> (!node.<span class="property">next</span>[index]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.<span class="property">next</span>[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.<span class="property">end</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除字符串</span></span><br><span class="line">  <span class="title function_">delete</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">search</span>(str)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = str[i].<span class="title function_">charCodeAt</span>() - <span class="string">&quot;a&quot;</span>.<span class="title function_">charCodeAt</span>();</span><br><span class="line">      <span class="comment">// 如果索引对应的节点的 Path 为 0，代表经过该节点的字符串</span></span><br><span class="line">      <span class="comment">// 已经一个，直接删除即可</span></span><br><span class="line">      <span class="keyword">if</span> (--node.<span class="property">next</span>[index].<span class="property">path</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        node.<span class="property">next</span>[index] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.<span class="property">next</span>[index];</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">end</span> -= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h2><p>并查集是一种特殊的树结构，用于处理一些不交集的合并及查询问题。该结构中每个节点都有一个父节点，如果只有当前一个节点，那么该节点的父节点指向自己。</p>
<p>这个结构中有两个重要的操作，分别是：</p>
<ul>
<li>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li>
<li>Union：将两个子集合并成同一个集合。</li>
</ul>
<p><img src="/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/disjointSet.png"></p>
<h2 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DisjointSet</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化样本</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">count</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化时，每个节点的父节点都是自己</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(count);</span><br><span class="line">    <span class="comment">// 用于记录树的深度，优化搜索复杂度</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rank</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">parent</span>[i] = i;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rank</span>[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">find</span>(<span class="params">p</span>) &#123;</span><br><span class="line">    <span class="comment">// 寻找当前节点的父节点是否为自己，不是的话表示还没找到</span></span><br><span class="line">    <span class="comment">// 开始进行路径压缩优化</span></span><br><span class="line">    <span class="comment">// 假设当前节点父节点为 A</span></span><br><span class="line">    <span class="comment">// 将当前节点挂载到 A 节点的父节点上，达到压缩深度的目的</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="variable language_">this</span>.<span class="property">parent</span>[p]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">parent</span>[p] = <span class="variable language_">this</span>.<span class="property">parent</span>[<span class="variable language_">this</span>.<span class="property">parent</span>[p]];</span><br><span class="line">      p = <span class="variable language_">this</span>.<span class="property">parent</span>[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isConnected</span>(<span class="params">p, q</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">find</span>(p) === <span class="variable language_">this</span>.<span class="title function_">find</span>(q);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 合并</span></span><br><span class="line">  <span class="title function_">union</span>(<span class="params">p, q</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到两个数字的父节点</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="title function_">find</span>(p);</span><br><span class="line">    <span class="keyword">let</span> j = <span class="variable language_">this</span>.<span class="title function_">find</span>(q);</span><br><span class="line">    <span class="keyword">if</span> (i === j) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 判断两棵树的深度，深度小的加到深度大的树下面</span></span><br><span class="line">    <span class="comment">// 如果两棵树深度相等，那就无所谓怎么加</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">rank</span>[i] &lt; <span class="variable language_">this</span>.<span class="property">rank</span>[j]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">parent</span>[i] = j;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">rank</span>[i] &gt; <span class="variable language_">this</span>.<span class="property">rank</span>[j]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">parent</span>[j] = i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">parent</span>[i] = j;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rank</span>[j] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h2><p>堆通常是一个可以被看做一棵树的数组对象。</p>
<p>堆的实现通过构造<strong>二叉堆</strong>，实为二叉树的一种。这种数据结构具有以下性质。</p>
<ul>
<li>任意节点小于（或大于）它的所有子节点</li>
<li>堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。</li>
</ul>
<p>将根节点最大的堆叫做<strong>最大堆</strong>或<strong>大根堆</strong>，根节点最小的堆叫做<strong>最小堆</strong>或<strong>小根堆</strong>。</p>
<p>优先队列也完全可以用堆来实现，操作是一模一样的。</p>
<h2 id="实现大根堆"><a href="#实现大根堆" class="headerlink" title="实现大根堆"></a>实现大根堆</h2><p>堆的每个节点的左边子节点索引是 <code>i * 2 + 1</code>，右边是 <code>i * 2 + 2</code>，父节点是 <code>(i - 1) /2</code>。</p>
<p>堆有两个核心的操作，分别是 <code>shiftUp</code> 和 <code>shiftDown</code> 。前者用于添加元素，后者用于删除根节点。</p>
<p><code>shiftUp</code> 的核心思路是一路将节点与父节点对比大小，如果比父节点大，就和父节点交换位置。</p>
<p><code>shiftDown</code> 的核心思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断父节点和两个子节点的大小，如果子节点大，就把最大的子节点和父节点交换。</p>
<p><img src="/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/heap.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">empty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">size</span>() == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">push</span>(item);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_shiftUp</span>(<span class="variable language_">this</span>.<span class="title function_">size</span>() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeMax</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_shiftDown</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getParentIndex</span>(<span class="params">k</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>((k - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getLeftIndex</span>(<span class="params">k</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> k * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_shiftUp</span>(<span class="params">k</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点比父节点大，就交换</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">heap</span>[k] &gt; <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="variable language_">this</span>.<span class="title function_">getParentIndex</span>(k)]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_swap</span>(k, <span class="variable language_">this</span>.<span class="title function_">getParentIndex</span>(k));</span><br><span class="line">      <span class="comment">// 将索引变成父节点</span></span><br><span class="line">      k = <span class="variable language_">this</span>.<span class="title function_">getParentIndex</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_shiftDown</span>(<span class="params">k</span>) &#123;</span><br><span class="line">    <span class="comment">// 交换首位并删除末尾</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_swap</span>(k, <span class="variable language_">this</span>.<span class="title function_">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">splice</span>(<span class="variable language_">this</span>.<span class="title function_">size</span>() - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断节点是否有左孩子，因为二叉堆的特性，有右必有左</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="title function_">getLeftIndex</span>(k) &lt; <span class="variable language_">this</span>.<span class="title function_">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">let</span> j = <span class="variable language_">this</span>.<span class="title function_">getLeftIndex</span>(k);</span><br><span class="line">      <span class="comment">// 判断是否有右孩子，并且右孩子是否大于左孩子</span></span><br><span class="line">      <span class="keyword">if</span> (j + <span class="number">1</span> &lt; <span class="variable language_">this</span>.<span class="title function_">size</span>() &amp;&amp; <span class="variable language_">this</span>.<span class="property">heap</span>[j + <span class="number">1</span>] &gt; <span class="variable language_">this</span>.<span class="property">heap</span>[j]) j++;</span><br><span class="line">      <span class="comment">// 判断父节点是否已经比子节点都大</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">heap</span>[k] &gt;= <span class="variable language_">this</span>.<span class="property">heap</span>[j]) <span class="keyword">break</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_swap</span>(k, j);</span><br><span class="line">      k = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">_swap</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> rightValue = <span class="variable language_">this</span>.<span class="property">heap</span>[right];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span>[right] = <span class="variable language_">this</span>.<span class="property">heap</span>[left];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span>[left] = rightValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础开发</category>
      </categories>
      <tags>
        <tag>基础开发</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>本地文字切片 - mapbox 本地化</title>
    <url>/2019/07/23/%E6%9C%AC%E5%9C%B0%E6%96%87%E5%AD%97%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<h2 id="本地文字切片"><a href="#本地文字切片" class="headerlink" title="本地文字切片"></a>本地文字切片</h2><p>mapbox 地图字体通常使用 mapbox 线上 glyphs 文件. 字体本地化需要将使用的字体提取至本地 glyphs 文件中, 对应的, 需要修改为本地的地址：<code>&quot;glyphs&quot;: &quot;./font/&#123;fontstack&#125;/&#123;range&#125;.pbf&quot;</code>.</p>
<p>而 fontstack 和 range 会被具体的字体类型和这个字在字体中所处的实际范围给替换了. mapbox 团队开源了一个工具, 将普通的 ttf 和 otf 字体转换成 mapbox GL 渲染需要的字体的工具：<a href="https://github.com/mapbox/node-fontnik">node-fontnik</a>.</p>
<p><a href="http://www.jianshu.com/p/23634e54487e">mapbox&#x2F;node-fontnik 工具使用介绍</a></p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>下载源码<a href="https://github.com/mapbox/node-fontnik/releases">node-fontnik-release</a></li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://github.com/mapbox/node-fontnik/archive/v0.5.0.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解压缩</span></span><br><span class="line">$ tar -xzf v0.5.0.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> node-fontnik-0.5.0</span><br><span class="line"><span class="comment">#安装库文件</span></span><br><span class="line"><span class="comment">#这个必须执行到, 未执行需要卸载重装, 需要curl</span></span><br><span class="line">$ apt-get install curl</span><br><span class="line"><span class="comment">#一定要使用全局代理运行</span></span><br><span class="line"><span class="comment">#一定要使用全局代理运行</span></span><br><span class="line"><span class="comment">#一定要使用全局代理运行</span></span><br><span class="line">$ ./install_mason.sh</span><br><span class="line"><span class="comment">#安装node相关</span></span><br><span class="line">$ npm install</span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>准备需要转换字体的 ttf 文件, 这里使用微软雅黑 <code>msyh.ttf</code></li>
<li>编写需要转换使用的 js <code>convert.js</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fontnik = <span class="built_in">require</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> convert = <span class="keyword">function</span>(<span class="params">fileName, outputDir</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> font = fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">resolve</span>(__dirname + <span class="string">&quot;/&quot;</span> + fileName));</span><br><span class="line">  <span class="title function_">output2pbf</span>(font, <span class="number">0</span>, <span class="number">255</span>, outputDir);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">output2pbf</span>(<span class="params">font, start, end, outputDir</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (start &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;done!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fontnik.<span class="title function_">range</span>(&#123; <span class="attr">font</span>: font, <span class="attr">start</span>: start, <span class="attr">end</span>: end &#125;, <span class="keyword">function</span>(<span class="params">err, res</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> outputFilePath = path.<span class="title function_">resolve</span>(</span><br><span class="line">      __dirname + <span class="string">&quot;/&quot;</span> + outputDir + <span class="string">&quot;/&quot;</span> + start + <span class="string">&quot;-&quot;</span> + end + <span class="string">&quot;.pbf&quot;</span></span><br><span class="line">    );</span><br><span class="line">    fs.<span class="title function_">writeFile</span>(outputFilePath, res, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">output2pbf</span>(font, end + <span class="number">1</span>, end + <span class="number">1</span> + <span class="number">255</span>, outputDir);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">convert</span>(<span class="string">&quot;./msyh.ttf&quot;</span>, <span class="string">&quot;./msyh&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将 <code>msyh.ttf</code> 和 <code>convert.js</code> 复制到 <code>node-fontnik-0.5.0</code> 路径下</li>
<li>运行 js 转换文字, 出现 <code>done!</code> 则为转换成功.</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ node convert.js</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>转换结果为 XX-YY.pbf 的字体文件夹</li>
</ol>
]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
        <tag>mapbox</tag>
      </tags>
  </entry>
  <entry>
    <title>瓦片地图与TMS服务</title>
    <url>/2019/09/03/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E4%B8%8ETMS%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="瓦片切片方式"><a href="#瓦片切片方式" class="headerlink" title="瓦片切片方式"></a>瓦片切片方式</h2><p>切片的规则存在 TMS、Google Maps、百度和 QuadTree 的方式，TMS 定义切片的开始从地图左下角开始，即中心点（origin）在左下角，Google Maps 的切片定义中心点在左上角，QuadTree 是必应地图使用的一种切片命名格式，TMS 和 Google Maps 是将地图以 x&#x2F;y&#x2F;z 的方式存储读取，QuadTree 将 x&#x2F;y 转换成二进制的形式，进行存储读取，原理是一样的，只是命名规则不同。</p>
<span id="more"></span>

<h3 id="瓦片编号"><a href="#瓦片编号" class="headerlink" title="瓦片编号"></a>瓦片编号</h3><p>瓦片生成后，就是一堆图片。怎么对这堆图片进行编号，是目前主流互联网地图商分歧最大的地方。总结起来分为四个流派：</p>
<ol>
<li>谷歌 XYZ：Z 表示缩放层级，Z&#x3D;zoom；XY 的原点在左上角，X 从左向右，Y 从上向下，ArcServer 和高德地图切片规则和谷歌地图一致，WTMS 是 OGC（OGC-WTMS）的标准也和这个一样。</li>
<li>TMS（OSGeo-TMS 标准）：开源产品的标准，Z 的定义与谷歌相同；XY 的原点在左下角，X 从左向右，Y 从下向上。</li>
<li>百度 XYZ：Z 从 1 开始，在最高级就把地图分为四块瓦片；XY 的原点在经度为 0 纬度位 0 的位置，X 从左向右，Y 从下向上。</li>
<li>必应地图的 QuadTree</li>
</ol>
<p><img src="/2019/09/03/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E4%B8%8ETMS%E6%9C%8D%E5%8A%A1/tms.jpg" alt="瓦片编号"></p>
<h2 id="QGIS-配置"><a href="#QGIS-配置" class="headerlink" title="QGIS 配置"></a>QGIS 配置</h2><blockquote>
<p>QGIS 版本需要大于等于 2.16</p>
</blockquote>
<h3 id="浏览器面板"><a href="#浏览器面板" class="headerlink" title="浏览器面板"></a>浏览器面板</h3><p><img src="/2019/09/03/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E4%B8%8ETMS%E6%9C%8D%E5%8A%A1/browser.png" alt="浏览器面板"></p>
<h3 id="新建连接"><a href="#新建连接" class="headerlink" title="新建连接"></a>新建连接</h3><p>右键 -&gt; 新建连接 -&gt; 复制下面常用的 TMS_URL</p>
<p><img src="/2019/09/03/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E4%B8%8ETMS%E6%9C%8D%E5%8A%A1/url.png" alt="新建连接"></p>
<h3 id="加载底图"><a href="#加载底图" class="headerlink" title="加载底图"></a>加载底图</h3><p>添加图层至图层面板</p>
<p><img src="/2019/09/03/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E4%B8%8ETMS%E6%9C%8D%E5%8A%A1/addLayer.png" alt="添加图层"></p>
<h2 id="常用的-TMS-URL"><a href="#常用的-TMS-URL" class="headerlink" title="常用的 TMS_URL"></a>常用的 TMS_URL</h2><ol>
<li>2gis_map: <code>http://tile2.maps.2gis.com/tiles?x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;v=1.1</code></li>
<li>Bingmap: <code>http://ecn.dynamic.t0.tiles.virtualearth.net/comp/CompositionHandler/&#123;q&#125;?mkt=en-us&amp;it=G,VE,BX,L,LA&amp;shading=hill</code></li>
<li>Bing_sat: <code>http://ecn.t3.tiles.virtualearth.net/tiles/a&#123;q&#125;.jpeg?g=0&amp;dir=dir_n</code></li>
<li>cartdb_positron: <code>http://a.basemaps.cartocdn.com/light_all/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png</code></li>
<li>ESRI_national_geographic: <code>http://services.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;</code></li>
<li>ESRI_sat: <code>https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;</code></li>
<li>ESRI_standard: <code>https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;</code></li>
<li>google_CN: <code>http://mt2.google.cn/vt/lyrs=m@177000000&amp;hl=zh-CN&amp;gl=cn&amp;src=app&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;</code></li>
<li>google_road: <code>https://mt1.google.com/vt/lyrs=m&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;</code></li>
<li>google_sat_us: <code>https://mt1.google.com/vt/lyrs=s@110&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;</code></li>
<li>google_sat: <code>http://mt3.google.cn/vt/lyrs=s@110&amp;hl=zh-CN&amp;gl=cn&amp;src=app&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;</code></li>
<li>landsat: <code>http://irs.gis-lab.info/?layers=landsat&amp;request=GetTile&amp;z=&#123;z&#125;&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;</code></li>
<li>OSM: <code>http://c.tile.openstreetmap.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png</code></li>
<li>google_terrain: <code>http://mt0.google.com/vt/lyrs=t@130,r@203000000&amp;hl=en&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;s=Ga</code></li>
<li>高德地图: <code>http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;</code></li>
<li>高德卫星: <code>http://webst04.is.autonavi.com/appmaptile?style=6&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;</code></li>
<li>腾讯地图: <code>http://rt1.map.gtimg.com/realtimerender?z=&#123;z&#125;&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;type=vector&amp;style=0</code></li>
<li><a href="http://map.geoq.cn/">geoq</a>: <code>http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetWarm/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;</code></li>
</ol>
<h2 id="谷歌地址配置说明"><a href="#谷歌地址配置说明" class="headerlink" title="谷歌地址配置说明"></a>谷歌地址配置说明</h2><p><a href="http://mt0.google.com/vt/lyrs=m&hl=en&x=%7Bx%7D&y=%7By%7D&z=%7Bz%7D&s=Ga">http://mt0.google.com/vt/lyrs=m&amp;hl=en&amp;x={x}&amp;y={y}&amp;z={z}&amp;s=Ga</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h = roads only</span><br><span class="line">m = standard roadmap</span><br><span class="line">p = terrain</span><br><span class="line">r = somehow altered roadmap</span><br><span class="line">s = satellite only</span><br><span class="line">t = terrain only</span><br><span class="line">y = hybrid</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
        <tag>TMS</tag>
      </tags>
  </entry>
  <entry>
    <title>瓦片地图制作</title>
    <url>/2021/04/08/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<p>瓦片地图是指使用 GIS 软件或者工具对已有的画布图层按照设置好的显示规则生成供 web 使用的 <a href="/2019/09/03/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E4%B8%8ETMS%E6%9C%8D%E5%8A%A1/" title="瓦片地图与TMS服务">TMS 瓦片地图</a>. 可以通过 <code>GeoServer</code>, <code>ArcGIS Server</code> 或者其他桌面端 GIS 软件生成形如 <code>ZZZZ/XXXX/YYYY.png</code> 的一系列静态图片文件夹.</p>
<span id="more"></span>

<h2 id="制作工具"><a href="#制作工具" class="headerlink" title="制作工具"></a>制作工具</h2><p>通过 <code>GeoServer</code>, <code>ArcGIS Server</code> 需要配置相应的图层设置和显示规则, 对于非开发人员不够直观, 最方便的瓦片地图制作方式是使用桌面端 GIS 软件完成瓦片地图的切片, 因此通常使用 <a href="https://qgis.org/en/site/forusers/download.html">QGIS</a> 的<code>栅格工具</code>完成瓦片地图的生成.</p>
<p>使用的 QGIS 版本需要大于 3.0</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="安装插件查看合适缩放等级"><a href="#安装插件查看合适缩放等级" class="headerlink" title="安装插件查看合适缩放等级"></a>安装插件查看合适缩放等级</h3><p>安装 <em>Zoom Level</em> 插件便于查看当前画布的适合缩放层级.</p>
<p><img src="/2021/04/08/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E5%88%B6%E4%BD%9C/zoom-level.jpg" alt="zoom-level"></p>
<p>调整画布至合适大小, 可查看左下角的缩放等级</p>
<p><img src="/2021/04/08/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E5%88%B6%E4%BD%9C/show-zoom.jpg" alt="show-zoom"></p>
<h3 id="添加图层"><a href="#添加图层" class="headerlink" title="添加图层"></a>添加图层</h3><p>按照需求依次添加底图, 标记点, 线等图层, 尽可能按照底图(可以是影像图, 也可以是 TMS, WTMS 等服务图片)</p>
<p><img src="/2021/04/08/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E5%88%B6%E4%BD%9C/add-layer.jpg" alt="add-layer"></p>
<h3 id="调整图层样式与显示效果"><a href="#调整图层样式与显示效果" class="headerlink" title="调整图层样式与显示效果"></a>调整图层样式与显示效果</h3><ol>
<li><p>修改矢量图层显示样式, 包括规则显示, 图标颜色设置等</p>
</li>
<li><p>修改栅格图层缩放重采样</p>
<p><img src="/2021/04/08/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E5%88%B6%E4%BD%9C/update-symbol.jpg" alt="修改缩放效果"></p>
</li>
<li><p>修改栅格图层显示透明度, 移除边界白条与黑边</p>
<p><img src="/2021/04/08/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E5%88%B6%E4%BD%9C/remove-boundary.jpg" alt="移除白边"><br><img src="/2021/04/08/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E5%88%B6%E4%BD%9C/result.jpg" alt="最终效果"></p>
</li>
</ol>
<h3 id="生成瓦片地图"><a href="#生成瓦片地图" class="headerlink" title="生成瓦片地图"></a>生成瓦片地图</h3><ol>
<li><p>修改样式完成后, 选择 <code>工具箱-栅格工具-生成XYZ图块(目录)</code>, 如果找不到工具箱, 可以在<code>顶部菜单-地理处理-工具箱</code>打开.</p>
<p><img src="/2021/04/08/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E5%88%B6%E4%BD%9C/xyz.jpg" alt="生成瓦片地图"></p>
</li>
<li><p>配置底图切片的相关参数与输出路径, 完成后点击运行(可后台执行)</p>
<p><img src="/2021/04/08/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E5%88%B6%E4%BD%9C/xyz-config.jpg" alt="切片配置"></p>
</li>
</ol>
<p>QGIS 将在指定目录生成如<code>&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png</code>格式的瓦片图片目录.</p>
<p><img src="/2021/04/08/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E5%88%B6%E4%BD%9C/xyz-folder.jpg" alt="瓦片地图"></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>生成的切片目录打包压缩后上传至服务器, 使用如 <code>nginx</code> 的静态资源服务完成 <code>TMS</code> 服务的搭建.</p>
<ul>
<li>可以通过开启 <code>http2</code> 多路复用提升大量图片同时请求的速度</li>
<li>图片文件最好不要开启 gzip, gzip 对图片文件压缩率没有文本文件高, 且消耗资源</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用方法见 <a href="/2019/09/03/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E4%B8%8ETMS%E6%9C%8D%E5%8A%A1/" title="瓦片地图与TMS服务">TMS 瓦片地图</a></p>
]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
        <tag>TMS</tag>
      </tags>
  </entry>
  <entry>
    <title>矢量地图切片 - mapbox 本地化</title>
    <url>/2019/07/23/%E7%9F%A2%E9%87%8F%E5%9C%B0%E5%9B%BE%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<h2 id="矢量地图数据切片"><a href="#矢量地图数据切片" class="headerlink" title="矢量地图数据切片"></a>矢量地图数据切片</h2><p>使用 <a href="https://github.com/mapbox/tippecanoe">tippecanoe</a> 进行矢量地图切片, 切片格式由 geojson 转为 pbf</p>
<span id="more"></span>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>需求 linux 环境</li>
<li>需要 sqlite3, zlib 两个库文件</li>
</ul>
<ol>
<li>安装库文件支持</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">--------------------------------</span><br><span class="line"><span class="comment">#ubuntu系统</span></span><br><span class="line"><span class="comment">#安装make</span></span><br><span class="line">sudo apt-get install build-essential libsqlite3-dev zlib1g-dev</span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment">#centos系统</span></span><br><span class="line"><span class="comment">#安装并升级gcc</span></span><br><span class="line">yum -y install gcc-c++</span><br><span class="line"><span class="comment">#安装gcc-5.4.0</span></span><br><span class="line">wget http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/gcc-5.4.0/gcc-5.4.0.tar.bz2</span><br><span class="line">tar -xvf gcc-5.4.0.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> gcc-5.4.0</span><br><span class="line"><span class="comment">#下面扩展的安装最好使用代理</span></span><br><span class="line">./contrib/download_prerequisites</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">../configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"><span class="comment">#安装完成后重启</span></span><br><span class="line"><span class="comment">#查看GLIBC文件</span></span><br><span class="line">strings /lib64/libstdc++.so.6 | grep GLIBC</span><br><span class="line"><span class="comment">#如果未发现 GLIBCXX_3.4.21, 执行下面SO文件替换</span></span><br><span class="line"><span class="built_in">cp</span> /usr/local/lib64/libstdc++.so.6.0.21 /lib64</span><br><span class="line"><span class="built_in">cd</span> /lib64</span><br><span class="line"><span class="built_in">rm</span> -rf libstdc++.so.6</span><br><span class="line"><span class="built_in">ln</span> -s libstdc++.so.6.0.21 libstdc++.so.6</span><br><span class="line"><span class="comment"># 安装其他库</span></span><br><span class="line">yum install sqlite-devel zlib-devel</span><br><span class="line">----------------------------------------</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装 tippecanoe</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/mapbox/tippecanoe.git</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译及安装</span></span><br><span class="line">$ <span class="built_in">cd</span> tippecanoe</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h3 id="一般数据生产使用"><a href="#一般数据生产使用" class="headerlink" title="一般数据生产使用"></a>一般数据生产使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tippecanoe -e [文件夹名称] -z [最大缩放等级] -Z [最小缩放等级] -pC XX.geojson</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tippecanoe -e test -s EPSG:3857 -z 20 -Z 18  -pC polygon.geojson</span><br><span class="line">//批处理</span><br><span class="line">$ tippecanoe -e maps  -z 20 -Z 18  -pC `ls`</span><br></pre></td></tr></table></figure>

<ul>
<li>将 polygon.geojson 文件进行矢量切片, 传入的坐标系为 3857, 切片等级 12-18, 切片生成的目录名称为 test, 不使用 geobuf 压缩</li>
</ul>
<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><p>通常情况, 我们需要将 geojson 文件转换为 geobuf。</p>
<p>使用方法为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tippecanoe -o file.mbtiles [options] [file.json file.geobuf ...]</span><br></pre></td></tr></table></figure>

<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><ul>
<li><code>-o</code> <em>file</em><code>.mbtiles</code> or <code>--output=</code><em>file</em><code>.mbtiles</code>: 输出 mbtiles 文件</li>
<li><code>-e</code> <em>directory</em> or <code>--output-to-directory</code>&#x3D;<em>directory</em>: 输出文件至指定 <em>目录</em></li>
<li><code>-f</code> or <code>--force</code>: 如果 mbtiles 文件已存在, 则删除它</li>
<li><code>-F</code> or <code>--allow-existing</code>: 如果已经存在对应的文件, 不删除已存在的文件</li>
</ul>
<h4 id="切片描述与水印"><a href="#切片描述与水印" class="headerlink" title="切片描述与水印"></a>切片描述与水印</h4><ul>
<li><code>-n</code> <em>name</em> or <code>--name=</code><em>name</em>: （默认）生成 XXX.json 作为可读的切片描述</li>
<li><code>-A</code> <em>text</em> or <code>--attribution=</code><em>text</em>: 切片水印</li>
<li><code>-N</code> <em>description</em> or <code>--description=</code><em>description</em>: 生成 XXX.mbtiles 作为切片描述</li>
</ul>
<h4 id="输入文件和图层名称"><a href="#输入文件和图层名称" class="headerlink" title="输入文件和图层名称"></a>输入文件和图层名称</h4><ul>
<li><em>name</em><code>.json</code> or <em>name</em><code>.geojson</code>: 将 geojson 的 <em>name</em> 写入图层名称, 命名为 <em>name</em></li>
<li><em>name</em><code>.geobuf</code> or <em>name</em><code>.geobuf</code>: 将 geobuf 的 <em>name</em> 写入图层名称, 命名为 <em>name</em></li>
<li><code>-l</code> <em>name</em> or <code>--layer=</code><em>name</em>: 使用指定的名称而不是输入文件名称作为图层名称</li>
<li><code>-L</code> <em>name</em><code>:</code><em>file.json</em> or <code>--named-layer=</code><em>name</em><code>:</code><em>file.json</em>: 对每一个文件指定图层名称</li>
</ul>
<h4 id="输入文件的投影"><a href="#输入文件的投影" class="headerlink" title="输入文件的投影"></a>输入文件的投影</h4><ul>
<li><code>-s</code> <em>projection</em> or <code>--projection=</code><em>projection</em>: 指定输入文件的坐标系 <code>EPSG:4326</code> (默认 WGS84) and <code>EPSG:3857</code> (Web Mercator). 通常情况下, 使用 WGS84 作为输入文件的坐标系</li>
</ul>
<h4 id="缩放等级"><a href="#缩放等级" class="headerlink" title="缩放等级"></a>缩放等级</h4><ul>
<li><code>-z</code> <em>zoom</em> or <code>--maximum-zoom=</code><em>zoom</em>: 最大缩放等级</li>
<li><code>-zg</code> or <code>--maximum-zoom=g</code>: 默认使用估算合理的最大缩放等级</li>
<li><code>-Z</code> <em>zoom</em> or <code>--minimum-zoom=</code><em>zoom</em>: 最小缩放等级</li>
<li><code>-ae</code> or <code>--extend-zooms-if-still-dropping</code>: 如果最小要素依然存在, 增大最大的缩放等级</li>
</ul>
<h4 id="切片分辨率"><a href="#切片分辨率" class="headerlink" title="切片分辨率"></a>切片分辨率</h4><ul>
<li><code>-d</code> <em>detail</em> or <code>--full-detail=</code><em>detail</em>: 最大缩放等级的分辨率(默认 12 级, 切片分比率 2^12&#x3D;4096)</li>
<li><code>-D</code> <em>detail</em> or <code>--low-detail=</code><em>detail</em>: 较低等级的分辨率(默认 12 级, 切片分比率 2^12&#x3D;4096)</li>
<li><code>-m</code> <em>detail</em> or <code>--minimum-detail=</code><em>detail</em>: 最小的分辨率（默认 7 级）</li>
</ul>
<h4 id="属性表过滤器"><a href="#属性表过滤器" class="headerlink" title="属性表过滤器"></a>属性表过滤器</h4><ul>
<li><code>-x</code> <em>name</em> or <code>--exclude=</code><em>name</em>: 移除所有要素对应的指定字段</li>
<li><code>-y</code> <em>name</em> or <code>--include=</code><em>name</em>: 移除所有空字段要素</li>
<li><code>-X</code> or <code>--exclude-all</code>: 移除所有属性字段, 只保留几何字段</li>
<li><code>-T</code><em>attribute</em><code>:</code><em>type</em> or <code>--attribute-type=</code><em>attribute</em><code>:</code><em>type</em>: 改变指定字段的类别：<code>string</code>, <code>float</code>, <code>int</code>, <code>bool</code>.</li>
<li><code>-j</code> <em>filter</em> or <code>--feature-filter</code>&#x3D;<em>filter</em>: 字段过滤, <code>&quot;*&quot;</code>表示使用所有图层, 使用 mapbox 过滤函数</li>
<li><code>-J</code> <em>filter-file</em> or <code>--feature-filter-file</code>&#x3D;<em>filter-file</em>: 和<code>&quot;-j&quot;</code>一样, 只不过从文件中过滤</li>
</ul>
<p>字段过滤 example:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tippecanoe -z 5 -o filtered.mbtiles -j <span class="string">&#x27;&#123; &quot;ne_10m_admin_0_countries&quot;: [ &quot;all&quot;, [ &quot;&lt;&quot;, &quot;scalerank&quot;, 3 ], [ &quot;&gt;&quot;, &quot;LABELRANK&quot;, 5 ] ] &#125;&#x27;</span> ne_10m_admin_0_countries.geojson</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="线、面的简化"><a href="#线、面的简化" class="headerlink" title="线、面的简化"></a>线、面的简化</h4><ul>
<li><code>-S</code> <em>scale</em> or <code>--simplification=</code><em>scale</em>: 容差</li>
<li><code>-ps</code> or <code>--no-line-simplification</code>: 无线简化</li>
<li><code>-pS</code> or <code>--simplify-only-low-zooms</code>: 在高缩放等级时不简化</li>
<li><code>-pt</code> or <code>--no-tiny-polygon-reduction</code>: 不合并面</li>
</ul>
<h4 id="公共面边界优化"><a href="#公共面边界优化" class="headerlink" title="公共面边界优化"></a>公共面边界优化</h4><ul>
<li><code>-ab</code> or <code>--detect-shared-borders</code>: 检测公共边界并简化</li>
<li><code>-aL</code> or <code>--grid-low-zooms</code>: 线、面吸附</li>
</ul>
<h4 id="裁剪切片边界"><a href="#裁剪切片边界" class="headerlink" title="裁剪切片边界"></a>裁剪切片边界</h4><ul>
<li><code>-b</code> <em>pixels</em> or <code>--buffer=</code><em>pixels</em>: 缓冲区（默认 5, 2^5&#x3D;32）</li>
<li><code>-pc</code> or <code>--no-clipping</code>: 不裁剪</li>
<li><code>-pD</code> or <code>--no-duplication</code>: 无重复</li>
</ul>
<h4 id="切片要素重排"><a href="#切片要素重排" class="headerlink" title="切片要素重排"></a>切片要素重排</h4><ul>
<li><code>-pi</code> or <code>--preserve-input-order</code>: 以输入顺序作为绘制顺序</li>
<li><code>-ao</code> or <code>--reorder</code>: 所有同属性要素按顺序重排</li>
<li><code>-ac</code> or <code>--coalesce</code>: 合并具有相同属性的相邻线、面</li>
<li><code>-ar</code> or <code>--reverse</code>: 合并相邻但反向的线段</li>
</ul>
<h4 id="增加计算的额外字段"><a href="#增加计算的额外字段" class="headerlink" title="增加计算的额外字段"></a>增加计算的额外字段</h4><ul>
<li><code>-ag</code> or <code>--calculate-feature-density</code>: 增加字段<code>tippecanoe_feature_density</code>, 用于描述切片中的要素密度</li>
</ul>
<h4 id="修复破损几何"><a href="#修复破损几何" class="headerlink" title="修复破损几何"></a>修复破损几何</h4><ul>
<li><code>-aw</code> or <code>--detect-longitude-wraparound</code>: 检测相邻点, 并修复几何</li>
</ul>
<h4 id="切片大小设"><a href="#切片大小设" class="headerlink" title="切片大小设"></a>切片大小设</h4><ul>
<li><code>-M</code> <em>bytes</em> or <code>--maximum-tile-bytes=</code><em>bytes</em>: 切片大小指定（默认 500k）</li>
<li><code>-pf</code> or <code>--no-feature-limit</code>: 切片要素数量限制（默认 20W）</li>
<li><code>-pk</code> or <code>--no-tile-size-limit</code>: 不使用切片大小限制</li>
<li><code>-pC</code> or <code>--no-tile-compression</code>: 不使用 PBF 压缩（<strong>此处必须选择, 否则 mapbox 无法使用</strong>）</li>
<li><code>-pg</code> or <code>--no-tile-stats</code>: 不生成切片信息</li>
</ul>
<h4 id="临时储存"><a href="#临时储存" class="headerlink" title="临时储存"></a>临时储存</h4><ul>
<li><code>-t</code> <em>directory</em> or <code>--temporary-directory=</code><em>directory</em>: 临时目录, 如果未指定, 使用<code>/tmp</code>.</li>
</ul>
<h4 id="结果指示器"><a href="#结果指示器" class="headerlink" title="结果指示器"></a>结果指示器</h4><ul>
<li><code>-q</code> or <code>--quiet</code>: 静默模式</li>
<li><code>-v</code> or <code>--version</code>: 返回 Tippecanoe 版本号</li>
</ul>
]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
        <tag>mapbox</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础</title>
    <url>/2019/07/24/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>通常使用最差的时间复杂度来衡量一个算法的好坏。</p>
<p>常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。</p>
<p>对于一个算法来说，可能会计算出如下操作次数 <code>aN + 1</code>，<code>N</code> 代表数据量。那么该算法的时间复杂度就是 O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。</p>
<p>当然可能会出现两个算法都是 O(N) 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。</p>
<span id="more"></span>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>位运算在算法中很有用，速度可以比四则运算快很多。</p>
<p>在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式</p>
<ul>
<li>十进制 <code>33</code> 可以看成是 <code>32 + 1</code> ，并且 <code>33</code> 应该是六位二进制的（因为 <code>33</code> 近似 <code>32</code>，而 <code>32</code> 是 2 的五次方，所以是六位），那么 十进制 <code>33</code> 就是 <code>100001</code> ，只要是 2 的次方，那么就是 1 否则都为 0</li>
<li>那么二进制 <code>100001</code> 同理，首位是 <code>2^5</code> ，末位是 <code>2^0</code> ，相加得出 33</li>
</ul>
<h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> &lt;&lt; <span class="number">1</span>; <span class="comment">// -&gt; 20</span></span><br></pre></td></tr></table></figure>

<p>左移就是将二进制全部往左移动，<code>10</code> 在二进制中表示为 <code>1010</code> ，左移一位后变成 <code>10100</code> ，转换为十进制也就是 20，所以基本可以把左移看成以下公式 <code>a * (2 ^ b)</code></p>
<h3 id="算数右移-gt-gt"><a href="#算数右移-gt-gt" class="headerlink" title="算数右移 &gt;&gt;"></a>算数右移 &gt;&gt;</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> &gt;&gt; <span class="number">1</span>; <span class="comment">// -&gt; 5</span></span><br></pre></td></tr></table></figure>

<p>算数右移就是将二进制全部往右移动并去除多余的右边，<code>10</code> 在二进制中表示为 <code>1010</code> ，右移一位后变成 <code>101</code> ，转换为十进制也就是 5，所以基本可以把右移看成以下公式 <code>int v = a / (2 ^ b)</code></p>
<p>右移很好用，比如可以用在二分算法中取中间值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span> &gt;&gt; <span class="number">1</span>; <span class="comment">// -&gt; 6</span></span><br></pre></td></tr></table></figure>

<h3 id="按位操作"><a href="#按位操作" class="headerlink" title="按位操作"></a>按位操作</h3><p><strong>按位与</strong></p>
<p>每一位都为 1，结果才为 1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span> &amp; <span class="number">7</span>; <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="comment">// 1000 &amp; 0111 -&gt; 0000 -&gt; 0</span></span><br></pre></td></tr></table></figure>

<p><strong>按位或</strong></p>
<p>其中一位为 1，结果就是 1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span> | <span class="number">7</span>; <span class="comment">// -&gt; 15</span></span><br><span class="line"><span class="comment">// 1000 | 0111 -&gt; 1111 -&gt; 15</span></span><br></pre></td></tr></table></figure>

<p><strong>按位异或</strong></p>
<p>每一位都不同，结果才为 1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span> ^ <span class="number">7</span>; <span class="comment">// -&gt; 15</span></span><br><span class="line"><span class="number">8</span> ^ <span class="number">8</span>; <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="comment">// 1000 ^ 0111 -&gt; 1111 -&gt; 15</span></span><br><span class="line"><span class="comment">// 1000 ^ 1000 -&gt; 0000 -&gt; 0</span></span><br></pre></td></tr></table></figure>

<p>从以上代码中可以发现按位异或就是不进位加法</p>
<p><strong>面试题</strong>：两个数不使用四则运算得出和</p>
<p>这道题中可以按位异或，因为按位异或就是不进位加法，<code>8 ^ 8 = 0</code> 如果进位了，就是 16 了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是 1 的位置，左边应该有一个进位 1，所以可以得出以下公式 <code>a + b = (a ^ b) + ((a &amp; b) &lt;&lt; 1)</code> ，然后通过迭代的方式模拟加法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">let</span> newA = a ^ b;</span><br><span class="line">  <span class="keyword">let</span> newB = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">sum</span>(newA, newB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>以下两个函数是排序中会用到的通用函数，就不一一写了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkArray</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!array || array.<span class="property">length</span> &lt;= <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">array, left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> rightValue = array[right];</span><br><span class="line">  array[right] = array[left];</span><br><span class="line">  array[left] = rightValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 <code>length - 1</code> 的位置。</p>
<p><img src="/2019/07/24/%E7%AE%97%E6%B3%95/bubbleSort.gif" alt="冒泡排序"></p>
<p>以下是实现该算法的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubble</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="title function_">checkArray</span>(array);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = array.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 从 0 到 `length - 1` 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) <span class="title function_">swap</span>(array, j, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + 1</code> ，去掉常数项以后得出时间复杂度是 O(n * n)</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作。</p>
<p><img src="/2019/07/24/%E7%AE%97%E6%B3%95/insertSort.gif" alt="插入排序"></p>
<p>以下是实现该算法的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertion</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="title function_">checkArray</span>(array);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; array[j + <span class="number">1</span>]; j--)</span><br><span class="line">      <span class="title function_">swap</span>(array, j, j + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + 1</code> ，去掉常数项以后得出时间复杂度是 O(n * n)</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的原理如下。遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引 1 开始重复上述操作。</p>
<p><img src="/2019/07/24/%E7%AE%97%E6%B3%95/selectSort.gif" alt="选择排序"></p>
<p>以下是实现该算法的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selection</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="title function_">checkArray</span>(array);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; array.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      minIndex = array[j] &lt; array[minIndex] ? j : minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">swap</span>(array, i, minIndex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + 1</code> ，去掉常数项以后得出时间复杂度是 O(n * n)</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的原理如下。递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组 <code>[3, 1, 2, 8, 9, 7, 6]</code>，中间数索引是 3，先排序数组 <code>[3, 1, 2, 8]</code> 。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组 <code>[3, 1]</code> 和 <code>[2, 8]</code> ，然后再排序数组 <code>[1, 3, 2, 8]</code> ，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组 <code>[1, 2, 3, 8]</code> 和 <code>[6, 7, 9]</code> 排序。</p>
<p><img src="/2019/07/24/%E7%AE%97%E6%B3%95/mergeSort.gif" alt="归并排序"></p>
<p>以下是实现该算法的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="title function_">checkArray</span>(array);</span><br><span class="line">  <span class="title function_">mergeSort</span>(array, <span class="number">0</span>, array.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">array, left, right</span>) &#123;</span><br><span class="line">  <span class="comment">// 左右索引相同说明已经只有一个数</span></span><br><span class="line">  <span class="keyword">if</span> (left === right) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 等同于 `left + (right - left) / 2`</span></span><br><span class="line">  <span class="comment">// 相比 `(left + right) / 2` 来说更加安全，不会溢出</span></span><br><span class="line">  <span class="comment">// 使用位运算是因为位运算比四则运算快</span></span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>(left + ((right - left) &gt;&gt; <span class="number">1</span>));</span><br><span class="line">  <span class="title function_">mergeSort</span>(array, left, mid);</span><br><span class="line">  <span class="title function_">mergeSort</span>(array, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> help = [];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> p1 = left;</span><br><span class="line">  <span class="keyword">let</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</span><br><span class="line">    help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">    help[i++] = array[p1++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (p2 &lt;= right) &#123;</span><br><span class="line">    help[i++] = array[p2++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; help.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    array[left + i] = help[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上算法使用了递归的思想。递归的本质就是压栈，每递归执行一次函数，就将该函数的信息（比如参数，内部的变量，执行到的行数）压栈，直到遇到终止条件，然后出栈并继续执行函数。对于以上递归函数的调用轨迹如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mergeSort</span>(data, <span class="number">0</span>, <span class="number">6</span>); <span class="comment">// mid = 3</span></span><br><span class="line"><span class="title function_">mergeSort</span>(data, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">// mid = 1</span></span><br><span class="line"><span class="title function_">mergeSort</span>(data, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// mid = 0</span></span><br><span class="line"><span class="title function_">mergeSort</span>(data, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 遇到终止，回退到上一步</span></span><br><span class="line"><span class="title function_">mergeSort</span>(data, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 遇到终止，回退到上一步</span></span><br><span class="line"><span class="comment">// 排序 p1 = 0, p2 = mid + 1 = 1</span></span><br><span class="line"><span class="comment">// 回退到 `mergeSort(data, 0, 3)` 执行下一个递归</span></span><br><span class="line"><span class="title function_">mergeSort</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// mid = 2</span></span><br><span class="line"><span class="title function_">mergeSort</span>(<span class="number">3</span>, <span class="number">3</span>); <span class="comment">// 遇到终止，回退到上一步</span></span><br><span class="line"><span class="comment">// 排序 p1 = 2, p2 = mid + 1 = 3</span></span><br><span class="line"><span class="comment">// 回退到 `mergeSort(data, 0, 3)` 执行合并逻辑</span></span><br><span class="line"><span class="comment">// 排序 p1 = 0, p2 = mid + 1 = 2</span></span><br><span class="line"><span class="comment">// 执行完毕回退</span></span><br><span class="line"><span class="comment">// 左边数组排序完毕，右边也是如上轨迹</span></span><br></pre></td></tr></table></figure>

<p>该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的一半，并且最后把整个数组迭代了一次，所以得出表达式 <code>2T(N / 2) + T(N)</code> （T 代表时间，N 代表数据量）。根据该表达式可以套用 <a href="https://www.wikiwand.com/zh-hans/%E4%B8%BB%E5%AE%9A%E7%90%86">该公式</a> 得出时间复杂度为 <code>O(N * logN)</code></p>
<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>快排的原理如下。随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。</p>
<p><img src="/2019/07/24/%E7%AE%97%E6%B3%95/quickSort.gif" alt="快排"></p>
<p>以下是实现该算法的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="title function_">checkArray</span>(array);</span><br><span class="line">  <span class="title function_">quickSort</span>(array, <span class="number">0</span>, array.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">array, left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="title function_">swap</span>(array, , right)</span><br><span class="line">    <span class="comment">// 随机取值，然后和末尾交换，这样做比固定取一个位置的复杂度略低</span></span><br><span class="line">    <span class="keyword">let</span> indexs = <span class="title function_">part</span>(array, <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (right - left + <span class="number">1</span>)) + left, right);</span><br><span class="line">    <span class="title function_">quickSort</span>(array, left, indexs[<span class="number">0</span>]);</span><br><span class="line">    <span class="title function_">quickSort</span>(array, indexs[<span class="number">1</span>] + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">part</span>(<span class="params">array, left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> less = left - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> more = right;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; more) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[left] &lt; array[right]) &#123;</span><br><span class="line">      <span class="comment">// 当前值比基准值小，`less` 和 `left` 都加一</span></span><br><span class="line">	   ++less;</span><br><span class="line">       ++left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[left] &gt; array[right]) &#123;</span><br><span class="line">      <span class="comment">// 当前值比基准值大，将当前值和右边的值交换</span></span><br><span class="line">      <span class="comment">// 并且不改变 `left`，因为当前换过来的值还没有判断过大小</span></span><br><span class="line">      <span class="title function_">swap</span>(array, --more, left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 和基准值相同，只移动下标</span></span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将基准值和比基准值大的第一个值交换位置</span></span><br><span class="line">  <span class="comment">// 这样数组就变成 `[比基准值小, 基准值, 比基准值大]`</span></span><br><span class="line">  <span class="title function_">swap</span>(array, right, more);</span><br><span class="line">  <span class="keyword">return</span> [less, more];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法的复杂度和归并排序是相同的，但是额外空间复杂度比归并排序少，只需 O(logN)，并且相比归并排序来说，所需的常数时间也更少。</p>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p><strong>Sort Colors</strong>：该题目来自 <a href="https://leetcode.com/problems/sort-colors/description/">LeetCode</a>，题目需要我们将 <code>[2,0,2,1,1,0]</code> 排序成 <code>[0,0,1,1,2,2]</code> ，这个问题就可以使用三路快排的思想。</p>
<p>以下是代码实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sortColors = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 下标如果遇到 right，说明已经排序完成</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">swap</span>(nums, i++, ++left);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">swap</span>(nums, i, --right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Kth Largest Element in an Array</strong>：该题目来自 <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/">LeetCode</a>，题目需要找出数组中第 K 大的元素，这问题也可以使用快排的思路。并且因为是找出第 K 大元素，所以在分离数组的过程中，可以找出需要的元素在哪边，然后只需要排序相应的一边数组就好。</p>
<p>以下是代码实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findKthLargest = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> l = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> r = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 得出第 K 大元素的索引位置</span></span><br><span class="line">  k = nums.<span class="property">length</span> - k;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="comment">// 分离数组后获得比基准树大的第一个元素索引</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="title function_">part</span>(nums, l, r);</span><br><span class="line">    <span class="comment">// 判断该索引和 k 的大小</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; k) &#123;</span><br><span class="line">      l = index + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; k) &#123;</span><br><span class="line">      r = index - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">part</span>(<span class="params">array, left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> less = left - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> more = right;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; more) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[left] &lt; array[right]) &#123;</span><br><span class="line">      ++less;</span><br><span class="line">      ++left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[left] &gt; array[right]) &#123;</span><br><span class="line">      <span class="title function_">swap</span>(array, --more, left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">swap</span>(array, right, more);</span><br><span class="line">  <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序利用了二叉堆的特性来做，二叉堆通常用数组表示，并且二叉堆是一颗完全二叉树（所有叶节点（最底层的节点）都是从左往右顺序排序，并且其他层的节点都是满的）。二叉堆又分为大根堆与小根堆。</p>
<ul>
<li>大根堆是某个节点的所有子节点的值都比他小</li>
<li>小根堆是某个节点的所有子节点的值都比他大</li>
</ul>
<p>堆排序的原理就是组成一个大根堆或者小根堆。以小根堆为例，某个节点的左边子节点索引是 <code>i * 2 + 1</code>，右边是 <code>i * 2 + 2</code>，父节点是 <code>(i - 1) /2</code>。</p>
<ol>
<li>首先遍历数组，判断该节点的父节点是否比他小，如果小就交换位置并继续判断，直到他的父节点比他大</li>
<li>重新以上操作 1，直到数组首位是最大值</li>
<li>然后将首位和末尾交换位置并将数组长度减一，表示数组末尾已是最大值，不需要再比较大小</li>
<li>对比左右节点哪个大，然后记住大的节点的索引并且和父节点对比大小，如果子节点大就交换位置</li>
<li>重复以上操作 3 - 4 直到整个数组都是大根堆。</li>
</ol>
<p><img src="/2019/07/24/%E7%AE%97%E6%B3%95/heapSort.gif" alt="堆排序"></p>
<p>以下是实现该算法的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">heap</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="title function_">checkArray</span>(array);</span><br><span class="line">  <span class="comment">// 将最大值交换到首位</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">heapInsert</span>(array, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> size = array.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 交换首位和末尾</span></span><br><span class="line">  <span class="title function_">swap</span>(array, <span class="number">0</span>, --size);</span><br><span class="line">  <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="title function_">heapify</span>(array, <span class="number">0</span>, size);</span><br><span class="line">    <span class="title function_">swap</span>(array, <span class="number">0</span>, --size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapInsert</span>(<span class="params">array, index</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果当前节点比父节点大，就交换</span></span><br><span class="line">  <span class="keyword">while</span> (array[index] &gt; array[<span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>)]) &#123;</span><br><span class="line">    <span class="title function_">swap</span>(array, index, <span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 将索引变成父节点</span></span><br><span class="line">    index = <span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapify</span>(<span class="params">array, index, size</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">    <span class="comment">// 判断左右节点大小</span></span><br><span class="line">    <span class="keyword">let</span> largest =</span><br><span class="line">      left + <span class="number">1</span> &lt; size &amp;&amp; array[left] &lt; array[left + <span class="number">1</span>] ? left + <span class="number">1</span> : left;</span><br><span class="line">    <span class="comment">// 判断子节点和父节点大小</span></span><br><span class="line">    largest = array[index] &lt; array[largest] ? largest : index;</span><br><span class="line">    <span class="keyword">if</span> (largest === index) <span class="keyword">break</span>;</span><br><span class="line">    <span class="title function_">swap</span>(array, index, largest);</span><br><span class="line">    index = largest;</span><br><span class="line">    left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码实现了小根堆，如果需要实现大根堆，只需要把节点对比反一下就好。</p>
<p>该算法的复杂度是 O(logN)</p>
<h3 id="系统自带排序实现"><a href="#系统自带排序实现" class="headerlink" title="系统自带排序实现"></a>系统自带排序实现</h3><p>每个语言的排序内部实现都是不同的。</p>
<p>对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序 <a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js##L760:7">源码实现</a> 。选择插入排序是因为虽然时间复杂度很差，但是在数据量很小的情况下和 <code>O(N * logN)</code>相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。</p>
<p>对于 Java 来说，还会考虑内部的元素的类型。对于存储对象的数组来说，会采用稳定性好的算法。稳定性的意思就是对于相同值来说，相对顺序不能改变。</p>
<p><img src="/2019/07/24/%E7%AE%97%E6%B3%95/systemSort.png" alt="系统排序"></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="反转单向链表"><a href="#反转单向链表" class="headerlink" title="反转单向链表"></a>反转单向链表</h3><p>该题目来自 <a href="https://leetcode.com/problems/reverse-linked-list/description/">LeetCode</a>，题目需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是一道面试常考题</p>
<p>以下是实现该算法的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断下变量边界问题</span></span><br><span class="line">  <span class="keyword">if</span> (!head || !head.<span class="property">next</span>) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="comment">// 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null</span></span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> current = head;</span><br><span class="line">  <span class="keyword">let</span> next;</span><br><span class="line">  <span class="comment">// 判断当前节点是否为空</span></span><br><span class="line">  <span class="comment">// 不为空就先获取当前节点的下一节点</span></span><br><span class="line">  <span class="comment">// 然后把当前节点的 next 设为上一个节点</span></span><br><span class="line">  <span class="comment">// 然后把 current 设为下一个节点，pre 设为当前节点</span></span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    next = current.<span class="property">next</span>;</span><br><span class="line">    current.<span class="property">next</span> = pre;</span><br><span class="line">    pre = current;</span><br><span class="line">    current = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树的先序，中序，后序遍历"><a href="#二叉树的先序，中序，后序遍历" class="headerlink" title="二叉树的先序，中序，后序遍历"></a>二叉树的先序，中序，后序遍历</h3><p>先序遍历表示先访问根节点，然后访问左节点，最后访问右节点。</p>
<p>中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</p>
<p>后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</p>
<h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><p>递归实现相当简单，代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TreeNode</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> traversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="comment">// 先序</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(root);</span><br><span class="line">    <span class="title function_">traversal</span>(root.<span class="property">left</span>);</span><br><span class="line">    <span class="comment">// 中序</span></span><br><span class="line">    <span class="comment">// console.log(root);</span></span><br><span class="line">    <span class="title function_">traversal</span>(root.<span class="property">right</span>);</span><br><span class="line">    <span class="comment">// 后序</span></span><br><span class="line">    <span class="comment">// console.log(root);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于递归的实现来说，只需要理解每个节点都会被访问三次就明白为什么这样实现了。</p>
<h4 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h4><p>非递归实现使用了栈的结构，通过栈的先进后出模拟递归实现。</p>
<p>以下是先序遍历代码实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pre</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="comment">// 先将根节点 push</span></span><br><span class="line">    stack.<span class="title function_">push</span>(root);</span><br><span class="line">    <span class="comment">// 判断栈中是否为空</span></span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">      root = stack.<span class="title function_">pop</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(root);</span><br><span class="line">      <span class="comment">// 因为先序遍历是先左后右，栈是先进后出结构</span></span><br><span class="line">      <span class="comment">// 所以先 push 右边再 push 左边</span></span><br><span class="line">      <span class="keyword">if</span> (root.<span class="property">right</span>) &#123;</span><br><span class="line">        stack.<span class="title function_">push</span>(root.<span class="property">right</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root.<span class="property">left</span>) &#123;</span><br><span class="line">        stack.<span class="title function_">push</span>(root.<span class="property">left</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是中序遍历代码实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mid</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="comment">// 中序遍历是先左再根最后右</span></span><br><span class="line">    <span class="comment">// 所以首先应该先把最左边节点遍历到底依次 push 进栈</span></span><br><span class="line">    <span class="comment">// 当左边没有节点时，就打印栈顶元素，然后寻找右节点</span></span><br><span class="line">    <span class="comment">// 对于最左边的叶节点来说，可以把它看成是两个 null 节点的父节点</span></span><br><span class="line">    <span class="comment">// 左边打印不出东西就把父节点拿出来打印，然后再看右节点</span></span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span> || root) &#123;</span><br><span class="line">      <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        stack.<span class="title function_">push</span>(root);</span><br><span class="line">        root = root.<span class="property">left</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = stack.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(root);</span><br><span class="line">        root = root.<span class="property">right</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是后序遍历代码实现，该代码使用了两个栈来实现遍历，相比一个栈的遍历来说要容易理解很多</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pos</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack1 = [];</span><br><span class="line">    <span class="keyword">let</span> stack2 = [];</span><br><span class="line">    <span class="comment">// 后序遍历是先左再右最后根</span></span><br><span class="line">    <span class="comment">// 所以对于一个栈来说，应该先 push 根节点</span></span><br><span class="line">    <span class="comment">// 然后 push 右节点，最后 push 左节点</span></span><br><span class="line">    stack1.<span class="title function_">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (stack1.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      root = stack1.<span class="title function_">pop</span>();</span><br><span class="line">      stack2.<span class="title function_">push</span>(root);</span><br><span class="line">      <span class="keyword">if</span> (root.<span class="property">left</span>) &#123;</span><br><span class="line">        stack1.<span class="title function_">push</span>(root.<span class="property">left</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root.<span class="property">right</span>) &#123;</span><br><span class="line">        stack1.<span class="title function_">push</span>(root.<span class="property">right</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack2.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(s2.<span class="title function_">pop</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历的前驱后继节点"><a href="#中序遍历的前驱后继节点" class="headerlink" title="中序遍历的前驱后继节点"></a>中序遍历的前驱后继节点</h3><p>实现这个算法的前提是节点有一个 <code>parent</code> 的指针指向父节点，根节点指向 <code>null</code> 。</p>
<p><img src="/2019/07/24/%E7%AE%97%E6%B3%95/tree.png" alt="中序遍历"></p>
<p>如图所示，该树的中序遍历结果是 <code>4, 2, 5, 1, 6, 3, 7</code></p>
<h4 id="前驱节点"><a href="#前驱节点" class="headerlink" title="前驱节点"></a>前驱节点</h4><p>对于节点 <code>2</code> 来说，他的前驱节点就是 <code>4</code> ，按照中序遍历原则，可以得出以下结论</p>
<ol>
<li>如果选取的节点的左节点不为空，就找该左节点最右的节点。对于节点 <code>1</code> 来说，他有左节点 <code>2</code> ，那么节点 <code>2</code> 的最右节点就是 <code>5</code></li>
<li>如果左节点为空，且目标节点是父节点的右节点，那么前驱节点为父节点。对于节点 <code>5</code> 来说，没有左节点，且是节点 <code>2</code> 的右节点，所以节点 <code>2</code> 是前驱节点</li>
<li>如果左节点为空，且目标节点是父节点的左节点，向上寻找到第一个是父节点的右节点的节点。对于节点 <code>6</code> 来说，没有左节点，且是节点 <code>3</code> 的左节点，所以向上寻找到节点 <code>1</code> ，发现节点 <code>3</code> 是节点 <code>1</code> 的右节点，所以节点 <code>1</code> 是节点 <code>6</code> 的前驱节点</li>
</ol>
<p>以下是算法实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">predecessor</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 结论 1</span></span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">left</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getRight</span>(node.<span class="property">left</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> parent = node.<span class="property">parent</span>;</span><br><span class="line">    <span class="comment">// 结论 2 3 的判断</span></span><br><span class="line">    <span class="keyword">while</span> (parent &amp;&amp; parent.<span class="property">right</span> === node) &#123;</span><br><span class="line">      node = parent;</span><br><span class="line">      parent = node.<span class="property">parent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRight</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  node = node.<span class="property">right</span>;</span><br><span class="line">  <span class="keyword">while</span> (node) node = node.<span class="property">right</span>;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后继节点"><a href="#后继节点" class="headerlink" title="后继节点"></a>后继节点</h4><p>对于节点 <code>2</code> 来说，他的后继节点就是 <code>5</code> ，按照中序遍历原则，可以得出以下结论</p>
<ol>
<li>如果有右节点，就找到该右节点的最左节点。对于节点 <code>1</code> 来说，他有右节点 <code>3</code> ，那么节点 <code>3</code> 的最左节点就是 <code>6</code></li>
<li>如果没有右节点，就向上遍历直到找到一个节点是父节点的左节点。对于节点 <code>5</code> 来说，没有右节点，就向上寻找到节点 <code>2</code> ，该节点是父节点 <code>1</code> 的左节点，所以节点 <code>1</code> 是后继节点</li>
</ol>
<p>以下是算法实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">successor</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 结论 1</span></span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">right</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getLeft</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 结论 2</span></span><br><span class="line">    <span class="keyword">let</span> parent = node.<span class="property">parent</span>;</span><br><span class="line">    <span class="comment">// 判断 parent 为空</span></span><br><span class="line">    <span class="keyword">while</span> (parent &amp;&amp; parent.<span class="property">left</span> === node) &#123;</span><br><span class="line">      node = parent;</span><br><span class="line">      parent = node.<span class="property">parent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLeft</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  node = node.<span class="property">left</span>;</span><br><span class="line">  <span class="keyword">while</span> (node) node = node.<span class="property">left</span>;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树的深度"><a href="#树的深度" class="headerlink" title="树的深度"></a>树的深度</h3><p><strong>树的最大深度</strong>：该题目来自 <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/">Leetcode</a>，题目需要求出一颗二叉树的最大深度</p>
<p>以下是算法实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title function_">maxDepth</span>(root.<span class="property">left</span>), <span class="title function_">maxDepth</span>(root.<span class="property">right</span>)) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于该递归函数可以这样理解：一旦没有找到节点就会返回 0，每弹出一次递归函数就会加一，树有三层就会得到 3。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划背后的基本思想非常简单。就是将一个问题拆分为子问题，一般来说这些子问题都是非常相似的，那么我们可以通过只解决一次每个子问题来达到减少计算量的目的。</p>
<p>一旦得出每个子问题的解，就存储该结果以便下次使用。</p>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>斐波那契数列就是从 0 和 1 开始，后面的数都是前两个数之和</p>
<p>0，1，1，2，3，5，8，13，21，34，55，89….</p>
<p>那么显然易见，我们可以通过递归的方式来完成求解斐波那契数列</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span> &amp;&amp; n &gt;= <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fib</span>(n - <span class="number">1</span>) + <span class="title function_">fib</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fib</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码已经可以完美的解决问题。但是以上解法却存在很严重的性能问题，当 n 越大的时候，需要的时间是指数增长的，这时候就可以通过动态规划来解决这个问题。</p>
<p>动态规划的本质其实就是两点</p>
<ol>
<li>自底向上分解子问题</li>
<li>通过变量存储已经计算过的解</li>
</ol>
<p>根据上面两点，我们的斐波那契数列的动态规划思路也就出来了</p>
<ol>
<li>斐波那契数列从 0 和 1 开始，那么这就是这个子问题的最底层</li>
<li>通过数组来存储每一位所对应的斐波那契数列的值</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="literal">null</span>);</span><br><span class="line">  array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  array[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    array[i] = array[i - <span class="number">1</span>] + array[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fib</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h3 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0 - 1 背包问题"></a>0 - 1 背包问题</h3><p>该问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。每个问题只能放入至多一次。</p>
<p>假设我们有以下物品</p>
<table>
<thead>
<tr>
<th align="center">物品 ID &#x2F; 重量</th>
<th align="center">价值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">12</td>
</tr>
</tbody></table>
<p>对于一个总容量为 5 的背包来说，我们可以放入重量 2 和 3 的物品来达到背包内的物品总价值最高。</p>
<p>对于这个问题来说，子问题就两个，分别是放物品和不放物品，可以通过以下表格来理解子问题</p>
<table>
<thead>
<tr>
<th align="center">物品 ID &#x2F; 剩余容量</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">7</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">7</td>
<td align="center">12</td>
<td align="center">15</td>
<td align="center">19</td>
</tr>
</tbody></table>
<p>直接来分析能放三种物品的情况，也就是最后一行</p>
<ul>
<li>当容量少于 3 时，只取上一行对应的数据，因为当前容量不能容纳物品 3</li>
<li>当容量 为 3 时，考虑两种情况，分别为放入物品 3 和不放物品 3<ul>
<li>不放物品 3 的情况下，总价值为 10</li>
<li>放入物品 3 的情况下，总价值为 12，所以应该放入物品 3</li>
</ul>
</li>
<li>当容量 为 4 时，考虑两种情况，分别为放入物品 3 和不放物品 3<ul>
<li>不放物品 3 的情况下，总价值为 10</li>
<li>放入物品 3 的情况下，和放入物品 1 的价值相加，得出总价值为 15，所以应该放入物品 3</li>
</ul>
</li>
<li>当容量 为 5 时，考虑两种情况，分别为放入物品 3 和不放物品 3<ul>
<li>不放物品 3 的情况下，总价值为 10</li>
<li>放入物品 3 的情况下，和放入物品 2 的价值相加，得出总价值为 19，所以应该放入物品 3</li>
</ul>
</li>
</ul>
<p>以下代码对照上表更容易理解</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; w 物品重量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; v 物品价值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; C 总容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">knapsack</span>(<span class="params">w, v, C</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> length = w.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对照表格，生成的二维数组，第一维代表物品，第二维代表背包剩余容量</span></span><br><span class="line">  <span class="comment">// 第二维中的元素代表背包物品总价值</span></span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="title class_">Array</span>(length).<span class="title function_">fill</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(C + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成底部子问题的解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= C; i++) &#123;</span><br><span class="line">    <span class="comment">// 对照表格第一行， array[0] 代表物品 1</span></span><br><span class="line">    <span class="comment">// i 代表剩余总容量</span></span><br><span class="line">    <span class="comment">// 当剩余总容量大于物品 1 的重量时，记录下背包物品总价值，否则价值为 0</span></span><br><span class="line">    array[<span class="number">0</span>][i] = i &gt;= w[<span class="number">0</span>] ? v[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自底向上开始解决子问题，从物品 2 开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= C; j++) &#123;</span><br><span class="line">      <span class="comment">// 这里求解子问题，分别为不放当前物品和放当前物品</span></span><br><span class="line">      <span class="comment">// 先求不放当前物品的背包总价值，这里的值也就是对应表格中上一行对应的值</span></span><br><span class="line">      array[i][j] = array[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="comment">// 判断当前剩余容量是否可以放入当前物品</span></span><br><span class="line">      <span class="keyword">if</span> (j &gt;= w[i]) &#123;</span><br><span class="line">        <span class="comment">// 可以放入的话，就比大小</span></span><br><span class="line">        <span class="comment">// 放入当前物品和不放入当前物品，哪个背包总价值大</span></span><br><span class="line">        array[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(array[i][j], v[i] + array[i - <span class="number">1</span>][j - w[i]]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array[length - <span class="number">1</span>][C];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>最长递增子序列意思是在一组数字中，找出最长一串递增的数字，比如</p>
<p>0, 3, 4, 17, 2, 8, 6, 10</p>
<p>对于以上这串数字来说，最长递增子序列就是 0, 3, 4, 8, 10，可以通过以下表格更清晰的理解</p>
<table>
<thead>
<tr>
<th align="center">数字</th>
<th align="center">0</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">17</th>
<th align="center">2</th>
<th align="center">8</th>
<th align="center">6</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">长度</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
</tbody></table>
<p>通过以上表格可以很清晰的发现一个规律，找出刚好比当前数字小的数，并且在小的数组成的长度基础上加一。</p>
<p>这个问题的动态思路解法很简单，直接上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lis</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 创建一个和参数相同大小的数组，并填充值为 1</span></span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="title class_">Array</span>(n.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 从索引 1 开始遍历，因为数组已经所有都填充为 1 了</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 从索引 0 遍历到 i</span></span><br><span class="line">    <span class="comment">// 判断索引 i 上的值是否大于之前的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (n[i] &gt; n[j]) &#123;</span><br><span class="line">        array[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(array[i], <span class="number">1</span> + array[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础开发</category>
      </categories>
      <tags>
        <tag>基础开发</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>系统代理配置</title>
    <url>/2020/03/30/%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="cmd-代理"><a href="#cmd-代理" class="headerlink" title="cmd 代理"></a>cmd 代理</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> http_proxy=http://127.0.0.1:1080</span><br><span class="line"><span class="built_in">set</span> https_proxy=http://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复</span></span><br><span class="line"><span class="built_in">set</span> http_proxy=</span><br><span class="line"><span class="built_in">set</span> https_proxy=</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="unix-代理"><a href="#unix-代理" class="headerlink" title="unix 代理"></a>unix 代理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># unix 下命令为 export</span><br><span class="line">export http_proxy=http://127.0.0.1:1080</span><br><span class="line">export https_proxy=http://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<h2 id="wsl2-代理"><a href="#wsl2-代理" class="headerlink" title="wsl2 代理"></a>wsl2 代理</h2><ol>
<li>安装 Docker Desktop for Windows</li>
<li>WSL2 backend</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export http_proxy=http://host.docker.internal:1080</span><br><span class="line">export https_proxy=http://host.docker.internal:1080</span><br></pre></td></tr></table></figure>

<h2 id="git-ssh-代理"><a href="#git-ssh-代理" class="headerlink" title="git ssh 代理"></a>git ssh 代理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在 /&#123;USER&#125;/.ssh/ 目录下新建 config 文件, 内容如下:</span><br><span class="line"></span><br><span class="line">Host gitlab.com</span><br><span class="line">   HostName gitlab.com</span><br><span class="line">   User git</span><br><span class="line">   ProxyCommand connect -S 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure>

<h2 id="vscode-代理"><a href="#vscode-代理" class="headerlink" title="vscode 代理"></a>vscode 代理</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># User Settings 里设置</span></span><br><span class="line"><span class="string">&quot;http.proxy&quot;</span>: <span class="string">&quot;http://127.0.0.1:1080&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统配置</category>
      </categories>
      <tags>
        <tag>系统配置</tag>
        <tag>wsl2</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础</title>
    <url>/2019/07/24/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><h2 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h2><p>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//example.com&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。</p>
<p>通常浏览器缓存策略分为两种：强缓存和协商缓存。</p>
<span id="more"></span>

<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>实现强缓存可以通过两种响应头实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，<code>state code</code> 为 200</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Expires</span>: <span class="title class_">Wed</span>, <span class="number">22</span> <span class="title class_">Oct</span> <span class="number">2018</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> <span class="variable constant_">GMT</span></span><br></pre></td></tr></table></figure>

<p><code>Expires</code> 是 HTTP &#x2F; 1.0 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Cache</span>-<span class="attr">control</span>: max-age=<span class="number">30</span></span><br></pre></td></tr></table></figure>

<p><code>Cache-Control</code> 出现于 HTTP &#x2F; 1.1，优先级高于 <code>Expires</code> 。该属性表示资源会在 30 秒后过期，需要再次请求。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。</p>
<p>协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。</p>
<h4 id="Last-Modified-和-If-Modified-Since"><a href="#Last-Modified-和-If-Modified-Since" class="headerlink" title="Last-Modified 和 If-Modified-Since"></a>Last-Modified 和 If-Modified-Since</h4><p><code>Last-Modified</code> 表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code> 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p>
<p>但是如果在本地打开缓存文件，就会造成 <code>Last-Modified</code> 被修改，所以在 HTTP &#x2F; 1.1 出现了 <code>ETag</code> 。</p>
<h4 id="ETag-和-If-None-Match"><a href="#ETag-和-If-None-Match" class="headerlink" title="ETag 和 If-None-Match"></a>ETag 和 If-None-Match</h4><p><code>ETag</code> 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 <code>ETag</code> 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code> 优先级比 <code>Last-Modified</code> 高。</p>
<h3 id="选择合适的缓存策略"><a href="#选择合适的缓存策略" class="headerlink" title="选择合适的缓存策略"></a>选择合适的缓存策略</h3><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p>
<ul>
<li>对于某些不需要缓存的资源，可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存</li>
<li>对于频繁变动的资源，可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li>
<li>对于代码文件来说，通常使用 <code>Cache-Control: max-age=31536000</code> 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li>
</ul>
<h2 id="使用-HTTP-x2F-2-0"><a href="#使用-HTTP-x2F-2-0" class="headerlink" title="使用 HTTP &#x2F; 2.0"></a>使用 HTTP &#x2F; 2.0</h2><p>因为浏览器会有并发请求限制，在 HTTP &#x2F; 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。</p>
<p>在 HTTP &#x2F; 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。</p>
<p>更详细的内容你可以查看 <a href="../Network/Network-zh.md##http-20">该小节</a></p>
<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</p>
<p>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p>
<h2 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h2><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prerender&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染</p>
<h1 id="优化渲染过程"><a href="#优化渲染过程" class="headerlink" title="优化渲染过程"></a>优化渲染过程</h1><p>对于代码层面的优化，你可以查阅浏览器系列中的 <a href="../Browser/browser-ch.md#%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6">相关内容</a>。</p>
<h2 id="懒执行"><a href="#懒执行" class="headerlink" title="懒执行"></a>懒执行</h2><p>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。</p>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>懒加载就是将不关键的资源延后加载。</p>
<p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 <code>src</code> 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 <code>src</code> 属性，这样图片就会去下载资源，实现了图片懒加载。</p>
<p>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。</p>
<h1 id="文件优化"><a href="#文件优化" class="headerlink" title="文件优化"></a>文件优化</h1><h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><h3 id="计算图片大小"><a href="#计算图片大小" class="headerlink" title="计算图片大小"></a>计算图片大小</h3><p>对于一张 100 _ 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 &#x3D; 1 个字节），所以该图片大小大概为 39KB（10000 _ 1 * 4 &#x2F; 1024）。</p>
<p>但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。</p>
<p>了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：</p>
<ul>
<li>减少像素点</li>
<li>减少每个像素点能够显示的颜色</li>
</ul>
<h3 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h3><ol>
<li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li>
<li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li>
<li>小图使用 base64 格式</li>
<li>将多个图标文件整合到一张图片中（雪碧图）</li>
<li>选择正确的图片格式：<ul>
<li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li>
<li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li>
<li>照片使用 JPEG</li>
</ul>
</li>
</ol>
<h2 id="其他文件优化"><a href="#其他文件优化" class="headerlink" title="其他文件优化"></a>其他文件优化</h2><ul>
<li>CSS 文件放在 <code>head</code> 中</li>
<li>服务端开启文件压缩功能</li>
<li>将 <code>script</code> 标签放在 <code>body</code> 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 <code>script</code> 标签放在任意位置然后加上 <code>defer</code> ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 <code>async</code> ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。</li>
<li>执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 <code>Webworker</code>。<code>Webworker</code> 可以让我们另开一个线程执行脚本而不影响渲染。</li>
</ul>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="使用-Webpack-优化项目"><a href="#使用-Webpack-优化项目" class="headerlink" title="使用 Webpack 优化项目"></a>使用 Webpack 优化项目</h2><ul>
<li>对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩</li>
<li>使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码</li>
<li>优化图片，对于小图可以使用 base64 的方式写入文件中</li>
<li>按照路由拆分代码，实现按需加载</li>
<li>给打包出来的文件名添加哈希，实现浏览器缓存文件</li>
</ul>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>对于代码运行错误，通常的办法是使用 <code>window.onerror</code> 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外</p>
<ul>
<li>对于跨域的代码运行错误会显示 <code>Script error.</code> 对于这种情况我们需要给 <code>script</code> 标签添加 <code>crossorigin</code> 属性</li>
<li>对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 <code>arguments.callee.caller</code> 来做栈递归</li>
</ul>
<p>对于异步代码来说，可以使用 <code>catch</code> 的方式捕获错误。比如 <code>Promise</code> 可以直接使用 <code>catch</code> 函数，<code>async await</code> 可以使用 <code>try catch</code></p>
<p>但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。</p>
<p>对于捕获的错误需要上传给服务器，通常可以通过 <code>img</code> 标签的 <code>src</code> 发起一个请求。</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><strong>如何渲染几万条数据并不卡住界面</strong></p>
<p>这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 <code>requestAnimationFrame</code> 来每 16 ms 刷新一次。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      控件</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 插入十万条数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> total = <span class="number">100000</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 一次插入 20 条，如果觉得性能不好就减少</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> once = <span class="number">20</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 渲染数据总共需要几次</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> loopCount = total / once;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> countOfRender = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;ul&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 优化性能，插入不会造成回流</span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; once; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            li.<span class="property">innerText</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * total);</span></span><br><span class="line"><span class="language-javascript">            fragment.<span class="title function_">appendChild</span>(li);</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">          ul.<span class="title function_">appendChild</span>(fragment);</span></span><br><span class="line"><span class="language-javascript">          countOfRender += <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">loop</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">loop</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (countOfRender &lt; loopCount) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(add);</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">loop</span>();</span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础开发</category>
      </categories>
      <tags>
        <tag>基础开发</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>雪碧图制作 - mapbox 本地化</title>
    <url>/2019/07/23/%E9%9B%AA%E7%A2%A7%E5%9B%BE%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="雪碧图制作"><a href="#雪碧图制作" class="headerlink" title="雪碧图制作"></a>雪碧图制作</h2><p>插件：<a href="https://github.com/mapbox/spritezero-cli">spritezero-cli</a></p>
<span id="more"></span>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装前最好先进行矢量地图 tippecanoe 扩展的安装</p>
<h4 id="nodejs-安装"><a href="#nodejs-安装" class="headerlink" title="nodejs 安装"></a>nodejs 安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nodejs 版本高于8无法使用</span></span><br><span class="line">$ sudo apt-get install nodejs</span><br><span class="line">$ sudo apt-get install npm</span><br></pre></td></tr></table></figure>

<h4 id="spritezero-cli-安装"><a href="#spritezero-cli-安装" class="headerlink" title="spritezero-cli 安装"></a>spritezero-cli 安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载</span></span><br><span class="line">$ wget https://github.com/mapbox/spritezero-cli/archive/v2.1.0.tar.gz</span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">$ tar -xzf v2.1.0.tar.gz</span><br><span class="line"><span class="comment">#一定要使用全局代理运行</span></span><br><span class="line"><span class="comment">#一定要使用全局代理运行</span></span><br><span class="line"><span class="comment">#一定要使用全局代理运行</span></span><br><span class="line">$ <span class="built_in">cd</span> spritezero-cli-2.1.0/</span><br><span class="line">$ apt-get install nodejs-legacy</span><br><span class="line">$ npm install</span><br><span class="line">$ npm install -g @mapbox/spritezero-cli</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ spritezero [output filename] [input directory]</span><br><span class="line"></span><br><span class="line"><span class="comment"># --retina      shorthand for --ratio=2</span></span><br><span class="line"><span class="comment"># --ratio=[n]   pixel ratio</span></span><br><span class="line"><span class="comment"># --unique      map identical images to multiple names</span></span><br></pre></td></tr></table></figure>

<p>将整个目录的 SVG 文件转为一张 PNG 雪碧图和一份 JSON 样式表</p>
<ul>
<li>example</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一级样式</span></span><br><span class="line">$ spritezero ttt input/</span><br><span class="line"><span class="comment"># retina样式</span></span><br><span class="line">$ spritezero --retina ttt@2x input/</span><br></pre></td></tr></table></figure>

<p>将整个 input 目录中的所有 svg 文件转换为 <code>ttt.png</code> 的雪碧图和 <code>ttt.json</code> 的样式表</p>
]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
        <tag>mapbox</tag>
      </tags>
  </entry>
</search>
